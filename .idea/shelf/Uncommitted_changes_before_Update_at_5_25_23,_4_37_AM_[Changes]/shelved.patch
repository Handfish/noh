Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Newerth of Heroes\n\n<img width=\"320\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236418122-c052ff68-467a-470f-9f90-fc53d51de862.png\">\n\nAn open source implementation of [dota](https://www.youtube.com/watch?v=qTsaS1Tm-Ic&ab_channel=BASSHUNTER). \n\nCross platform; multiplayer; lobby system; map editor; replay system; semicolon. Builds in 3 minutes flat on an M1 Air.\n\n\nTable of Contents\n=================\n\n* [About](#about)\n* [Media](#media)\n  * [Newerth dev stream #1](#newerth-dev-stream-1)\n  * [\"I was a former HoN dev. AMA\"](#i-was-a-former-hon-dev-ama)\n* [License](#license)\n* [Compiling NoH](#compiling-noh)\n  * [Building NoH on macOS](#building-noh-on-macos)\n     * [Install macOS dependencies](#install-macos-dependencies)\n     * [Clone the repository (--recursive is important!)](#clone-the-repository---recursive-is-important)\n     * [Build on macOS with CMake](#build-on-macos-with-cmake)\n     * [Building NoH on macOS with CLion](#building-noh-on-macos-with-clion)\n        * [Open the repo in CLion](#open-the-repo-in-clion)\n        * [Once CLion is open](#once-clion-is-open)\n        * [If things go wrong](#if-things-go-wrong)\n  * [Building NoH on Windows](#building-noh-on-windows)\n     * [Install Git for Windows](#install-git-for-windows)\n     * [Install CMake for Windows](#install-cmake-for-windows)\n     * [Install Visual Studio](#install-visual-studio)\n     * [Install CLion](#install-clion)\n     * [Build with CLion](#build-with-clion)\n\n<!-- Created by https://github.com/ekalinin/github-markdown-toc -->\n\n## About\n\nIntended to be the game engine that my 13yo self wished he'd had. Think of it as a baseline \"here's a fully working game engine, along with an actual game\" reference that you can use for whatever you want. It's small enough that you can understand it, build it yourself, and customize.\n\nMy long term goal is to implement a custom game system reminiscent of the StarCraft 1 \"Use Map Settings\" era. There was [something magical about it](https://www.youtube.com/watch?v=hu_ekZfW6wE&t=76s&ab_channel=RedDevouringOne) that modern \"custom game\" attempts don't really capture. If you remember it, you know what I mean -- point to any modern equivalent that makes you feel the same spark of joy of joining a random lobby and discovering that it's actually a weirdly-detailed esoteric RPG that some 14yo crafted in StarEdit, or an intense tower defense experience that you didn't expect.\n\n<img width=\"595\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236426949-89ac5d63-f391-4701-978c-63f93e31cb5d.png\">\n\nIt also makes my heart ache that your only realistic choices for becoming a professional gamedev circa 2023 is to build everything from scratch yourself (Celeste) or to spend years learning Unreal Engine or Unity. Good luck understanding the inner workings of those behemoths, much less getting UE to build.\n\nSo hopefully this will give you a leg up as a lone wolf gamedev.\n\n<img width=\"595\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236428981-60051d51-eeda-4e99-9846-e5024ae8f37f.png\">\n\nUltimately, I expect this to take somewhere between three months and three years, and for roughly seven people to care about it. But if you're one of those seven, know that you'll have all my heart and soul pushing you forward, for whatever it's worth. I fell in love with the K2 engine when I worked at S2 in 2010. Perhaps one or two others might too.\n\n## Media\n\n### Newerth dev stream #1\n\nhttps://youtu.be/VBj0RcpxCIc?t=132\n\nI wanted to give hackers a sense of how it feels to work with the engine, so I recorded about an hour of random work.\n\nBe sure to read the chapter titles as you watch; it's a detailed blow-by-blow of my thought process as I went.\n\n### \"I was a former HoN dev. AMA\"\n\nhttps://www.reddit.com/r/DotA2/comments/asc14j/i_was_a_former_hon_dev_ama/\n\nThis was an AMA I did when S2 officially shuttered Hon after Valve steamrolled them. The timestamp says four years ago, but it feels like a decade.\n\nI originally joined S2 because I loved the game, and a certain bug was so frustrating that I simply had to annihilate it. Joining the company was the only way I could, so I did.\n\n## License\n\nAll code and assets are MIT licensed, to the extent that I'm authorized to do so. Which is to say, not at all. But nobody cares at this point.\n\n## Compiling NoH\n\n### Building NoH on macOS\n\n##### Install macOS dependencies\n\nInstall [Homebrew](https://brew.sh/):\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\nInstall the dependencies:\n\n```\nbrew install cmake llvm ninja speex speexdsp giflib libpng libjpeg openssl@1.1 freetype fswatch fileicon\n```\n\n##### Clone the repository (`--recursive` is important!)\n\n```\ngit clone --recursive https://github.com/shawwn/noh\n```\n\n##### Build on macOS with CMake\n\n```\ncd noh\nmkdir build\ncd build\ncmake ..\ncmake --build . -j12\n```\n\nThings you can do:\n\n- Run `./K2\\ Model\\ Viewer` and play with some effects\n- Run `./NoH` and click \"Local Game\" to start a game\n- Run `./NoH\\ Editor`\n\n\n### Building NoH on macOS with [CLion](https://www.jetbrains.com/clion/download/#section=mac)\n\n##### Open the repo in [CLion](https://www.jetbrains.com/clion/download/#section=mac):\n```\ncd noh\nclion .\n```\n ##### Once CLion is open\n\n- Open Project view (press `Cmd-1`)\n\n- Open `CMakeLists.txt`\n\n- Click \"Load CMake project\" in the upper right\n\n<img width=\"1512\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236375944-0f028a9f-79b9-4939-b063-a9657fafe59b.png\">\n\nIgnore the scary-looking errors and just click the play button (`Run -> Run 'NoH'`)\n\n<img width=\"1398\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376120-22f8d300-5b8c-4615-bf48-f3c2b03256cb.png\">\n\nIf things go well, NoH will launch. Congratulations!\n\n<img width=\"1440\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376813-77395c90-89e6-4713-9a6b-09859caf33f9.png\">\n\n#### If things go wrong\n\nOpen CMake tab, click \"Reset Cache and Reload Project\" (the icon in the upper left of the tab with two arrows)\n\n<img width=\"889\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376625-105f0786-06b2-4032-bdaf-7d7f97144d17.png\">\n\nBuild -> Rebuild all in Release\n\n<img width=\"297\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376681-1eff6c59-43d8-462f-8a84-20ebe6f341b1.png\">\n\nRun -> Run NoH, or just click the play button\n\nIf things still aren't working, [post an issue](https://github.com/shawwn/noh/issues) or DM me on Twitter: [@theshawwn](https://twitter.com/theshawwn)\n\n### Building NoH on Windows\n\n##### Install Git for Windows\n\nInstall [Git for Windows](https://gitforwindows.org/)\n\nDuring setup, you can leave everything as default, **except make sure you check \"Enable symbolic links\"**:\n\n<img width=\"514\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/0d03e2a0-dac6-4176-b427-6c30c3dcec5e\">\n\n##### Install CMake for Windows\n\n[Download CMake](https://cmake.org/download/) (probably choose \"Windows x64 Installer\")\n\n\n<img width=\"498\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/7735c747-a017-4aae-b775-042fe48c7bfc\">\n\nDuring setup, click \"Add CMake to the system PATH for the current user\":\n\n<img width=\"497\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/a7e6fde2-ef1e-4e86-b753-416ee6390b4d\">\n\n##### Install Visual Studio\n\nIf you have Visual Studio 2019 or later instsalled, you can skip this step.\n\nInstall [Visual Studio 2022 Community](https://visualstudio.microsoft.com/downloads/):\n\n<img width=\"478\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/4fde72d4-204b-4a16-a7d6-40e3b2640de2\">\n\nDuring setup, choose \"Desktop development with C++\":\n\n<img width=\"1238\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/ebbeaefd-9d92-4bff-a3e3-f5dd6116e0d3\">\n\n(If you want to save around 6GB, you can you can uncheck \".NET desktop development\")\n\nCheck \"Install\", then wait awhile.\n\nEventually you'll see this:\n\n<img width=\"985\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/ad9953d8-685d-4489-b251-a8d7b0daf1ba\">\n\n##### Install CLion\n\nInstall CLion: [https://www.jetbrains.com/clion/download/](https://www.jetbrains.com/clion/download/)\n\n##### Build with CLion\n\nOpen CLion and clone the repo:\n\n<img width=\"804\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/67ec32d6-b4b3-4287-9281-6cb7bc8fc009\">\n\nClick \"Trust Project\"\n\n<img width=\"505\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/49fdfb05-fb27-46d3-ae26-d4539ef233ad\">\n\nConfigure Microsoft Defender:\n\n<img width=\"310\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/6826b757-5465-4a0e-ab07-b114c310c118\">\n\nGo to File -> Settings, then \"Build, Execution, Deployment\" and click \"Toolchains\". Verify that your settings look similar to this:\n\n<img width=\"1247\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/cf06074e-1935-4e92-a8b2-5cc232c72688\">\n\nOpen the Project tool window (Press `Alt-1`):\n\n<img width=\"501\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/d7760437-8338-4ca0-8b3b-10345c50619d\">\n\nOpen CMakeLists.txt, then click \"Load CMake project\" in the upper right:\n\n![image](https://github.com/shawwn/noh/assets/59632/eb0f2eda-3d61-4b32-b529-b1a9ea073d52)\n\nYou'll see some errors:\n\n<img width=\"1247\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/467b950c-6f3c-48fb-a9c7-b39c704fc769\">\n\nClick the Vcpkg tab:\n\n<img width=\"553\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/0d2b9025-8096-4f36-8985-bd445142510c\">\n\nClick the plus sign (\"Add vcpkg\")\n\n<img width=\"206\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/e9cc456a-c127-457b-8082-949e65dc9f66\">\n\nVerify that \"Add vcpkg integration to existing CMake profiles\" is selected, then click ok:\n\n<img width=\"335\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/18ab935b-bf8d-405d-8560-8130ce486014\">\n\nVcpkg will now start building the required dependencies:\n\n<img width=\"855\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/db1b4bf2-f744-48df-bb21-1e1a6f5ad295\">\n\nYou can click the \"CMake\" tab to watch its progress:\n\n<img width=\"1052\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/ae0bdfbb-8d0f-4ce3-883e-b042e12f2c4b\">\n\n<img width=\"1240\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/72e1e901-abf8-4c1a-8ff4-43d598f01c02\">\n\nWait awhile (~40 minutes, sorry; luckily you only need to do this once, ever).\n\nEventually \"Loading CMake project...\" in the status bar will disappear.\n\n<img width=\"1260\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/29028649-0feb-4a7c-abaa-32daab3c98b4\">\n\nClick the run button.\n\n<img width=\"683\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/b43a48cf-9432-46c9-b9c3-ec9ddbfda110\">\n\nThe engine will start building:\n\n<img width=\"1264\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/53d043bf-fdc9-4bab-91a7-41a0f8c90f02\">\n\nWith any luck, it'll launch. You're done!\n\nTo get into a game, change the configuration to NoH, then click the run button again. Once NoH starts, click \"Local Game\" -> Create Game, join a lobby\nslot, start game, then choose a hero.\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/README.md	(date 1685006472934)
@@ -150,6 +150,24 @@
 
 If things still aren't working, [post an issue](https://github.com/shawwn/noh/issues) or DM me on Twitter: [@theshawwn](https://twitter.com/theshawwn)
 
+### Building NoH on Ubuntu
+
+```
+sudo apt update
+sudo apt install build-essential libtool autoconf -y
+sudo apt install cmake ninja-build -y
+# graphics deps
+sudo apt-get install -y libgl-dev libglu1-mesa-dev libxrandr-devsudo xorg-dev
+# K2 engine deps
+sudo apt-get install -y libspeex-dev libspeexdsp-dev libssl-dev libgif-dev libpng-dev libcurl4-openssl-dev libjpeg-dev libxml2-dev libfreetype-dev libncurses-dev zlib-devel -y
+```
+
+```
+cd noh
+cmake -S . -B build -G ninja
+cmake --build build
+```
+
 ### Building NoH on Windows
 
 ##### Install Git for Windows
Index: src/shell/main_osx.mm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2008 S2 Games\n// main_osx.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers  \n//=============================================================================\n#ifndef __APPLE__\n#error main_osx.mm can only be compiled for OS X\n#endif\n\n#include \"shell_common.h\"\n#include \"../k2/c_vid.h\"\n\n#include <Cocoa/Cocoa.h>\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\n\n@interface AppDelegate : NSObject<NSApplicationDelegate>\n{\n    BOOL    m_bMinimized;\n}\n- (void)applicationWillFinishLaunching:(NSNotification*)aNotification;\n- (void)applicationDidFinishLaunching:(NSNotification*)aNotification;\n- (void)applicationDidBecomeActive:(NSNotification*)aNotification;\n- (void)applicationDidResignActive:(NSNotification*)aNotification;\n- (void)applicationWillHide:(NSNotification*)aNotification;\n- (void)applicationDidUnhide:(NSNotification *)aNotification;\n- (BOOL)validateMenuItem:(NSMenuItem*)item;\n- (void)toggleFullscreen:(id)sender;\n- (void)minimize:(id)sender;\n- (void)quit:(id)sender;\n@end\n//=============================================================================\n\n\n@implementation AppDelegate\n- (void)applicationWillFinishLaunching:(NSNotification*)aNotification\n{\n    // ensure the menu won't freeze: https://stackoverflow.com/questions/34469718/top-left-menu-bar-is-frozen-when-main-window-shows-up\n    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\n    // set up the menu\n    NSMenu *pMainMenu = [[NSMenu alloc] init];\n    NSMenu *pMenu = [[NSMenu alloc] initWithTitle:@(GAME_TITLE)];\n    // about (standard entry)\n    [pMenu addItemWithTitle:@(\"About \" GAME_TITLE) action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@\"\"];\n    [pMenu addItem:[NSMenuItem separatorItem]];\n    // editor/modelviewer\n    NSMenuItem *pMenuItem;\n    // toggle fullscreen\n    pMenuItem = (NSMenuItem*)[[NSMenuItem alloc] initWithTitle:@\"Toggle Fullscreen\" action:@selector(toggleFullscreen:) keyEquivalent:@\"f\"];\n    [pMenu addItem:pMenuItem];\n    // minimize\n    pMenuItem = (NSMenuItem*)[[NSMenuItem alloc] initWithTitle:@\"Minimize\" action:@selector(minimize:) keyEquivalent:@\"m\"];\n    [pMenu addItem:pMenuItem];\n    // hide/show (standard entries)\n    [pMenu addItemWithTitle:@(\"Hide \" GAME_TITLE) action:@selector(hide:) keyEquivalent:@\"h\"];\n    pMenuItem = (NSMenuItem*)[pMenu addItemWithTitle:@\"Hide Others\" action:@selector(hideOtherApplications:) keyEquivalent:@\"h\"];\n    [pMenuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];\n    [pMenu addItemWithTitle:@\"Show All\" action:@selector(unhideAllApplications:) keyEquivalent:@\"\"];\n    // quit\n    [pMenu addItem:[NSMenuItem separatorItem]];\n    pMenuItem = (NSMenuItem*)[pMenu addItemWithTitle:@(\"Quit \" GAME_TITLE) action:@selector(quit:) keyEquivalent:@\"q\"];\n    [pMenuItem setKeyEquivalentModifierMask:(NSEventModifierFlagCommand)];\n    // add to menu bar\n    pMenuItem = [[NSMenuItem alloc] initWithTitle:@\"\" action:nil keyEquivalent:@\"\"];\n    [pMenuItem setSubmenu:pMenu];\n    [pMainMenu addItem:pMenuItem];\n    #if TKTK\n    // private method that we need to call to set this to be the main/\"apple\" menu\n    [NSApp performSelector:NSSelectorFromString(@\"setAppleMenu:\") withObject:pMenu];\n    #else\n    [NSApp setMainMenu:pMainMenu];\n    #endif\n}\n\n- (void)applicationDidFinishLaunching:(NSNotification*)aNotification\n{\n    // ensure the menu won't freeze: https://stackoverflow.com/questions/34469718/top-left-menu-bar-is-frozen-when-main-window-shows-up\n    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\n    [[[NSApplication sharedApplication] mainWindow] makeKeyAndOrderFront:self];\n    // bring the window to the front\n    #if 1\n    int processID = [[NSProcessInfo processInfo] processIdentifier];\n    NSRunningApplication* app = [NSRunningApplication runningApplicationWithProcessIdentifier: processID];\n    [app activateWithOptions: NSApplicationActivateAllWindows | NSApplicationActivateIgnoringOtherApps];\n    #elif 0\n    Console.Execute(_T(\"BringActiveWindowToFront\"));\n    #endif\n\n    K2System.Init(_T(GAME_TITLE), VERSION_STRING, BUILD_INFO_STRING, BUILDNUMBER, BUILD_OS, BUILD_OS_INFO, BUILD_ARCH, MASTER_SERVER_ADDRESS);\n\n    try\n    {\n        Host.Init(_T(GAME_MODS));\n        Host.Execute();\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_T(\"Unhandled exception - \"), NO_THROW);\n        K2System.Error(ex.GetMsg());\n    }\n    \n    Host.Shutdown();\n    exit(0);\n}\n\n- (void)applicationDidBecomeActive:(NSNotification*)aNotification\n{\n    K2System.SetFocus(true);\n}\n\n- (void)applicationDidResignActive:(NSNotification*)aNotification\n{\n    K2System.SetFocus(false);\n}\n\n- (void)applicationWillHide:(NSNotification*)aNotification\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win respondsToSelector:NSSelectorFromString(@\"willHide:\")])\n            [win performSelector:NSSelectorFromString(@\"willHide:\") withObject:aNotification];\n    }\n}\n\n- (void)applicationDidUnhide:(NSNotification *)aNotification\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win respondsToSelector:NSSelectorFromString(@\"didUnhide:\")])\n            [win performSelector:NSSelectorFromString(@\"didUnhide:\") withObject:aNotification];\n    }\n}\n\n\n- (BOOL)validateMenuItem:(NSMenuItem*)item\n{\n    BOOL enable = [self respondsToSelector:[item action]];\n    \n    if (([item action] == @selector(launchEditor:) || [item action] == @selector(launchModelviewer:))\n        && (Host.HasClient() || Host.HasServer()))\n        enable = NO;\n    \n    return enable;\n}\n\n- (void)toggleFullscreen:(id)sender\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win && [win isMiniaturized])\n        [win deminiaturize:nil];\n    vid_fullscreen = !vid_fullscreen;\n    Console.Execute(_T(\"VidReset\"));\n}\n\n- (void)minimize:(id)sender\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win isMiniaturized])\n            [win deminiaturize:nil];\n        else\n            [win miniaturize:nil];\n    }\n}\n\n- (void)quit:(id)sender\n{\n    Console.Execute(_T(\"Quit\"));\n}\n@end\n\n\nstatic void signal_handler_quit(int signal, siginfo_t* info, void* context)\n{\n    static bool quit_handled = false;\n    if (!quit_handled)\n    {\n        quit_handled = true;\n        Console.Execute(_T(\"quit\"));\n    }\n}\n\n\nint main(int argc, char *argv[])\n{\n    struct sigaction act {};\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_SIGINFO;\n    act.sa_sigaction = signal_handler_quit;\n    sigaction(SIGHUP, &act, nullptr);\n    sigaction(SIGINT, &act, nullptr);\n    sigaction(SIGQUIT, &act, nullptr);\n    sigaction(SIGTERM, &act, nullptr);\n    signal(SIGPIPE, SIG_IGN);\n    // not handling fatal signals, as apple's default crash logging is sufficient\n    \n    // transform it to a gui application & bring it to the front\n    ProcessSerialNumber psn = { 0, kCurrentProcess };\n    TransformProcessType(&psn, kProcessTransformToForegroundApplication);\n#if TKTK  // SetFrontProcess is deprecated\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n    SetFrontProcess(&psn);\n#pragma clang diagnostic pop\n#else\n    int processID = [[NSProcessInfo processInfo] processIdentifier];\n    NSRunningApplication* app = [NSRunningApplication runningApplicationWithProcessIdentifier: processID];\n    [app activateWithOptions: NSApplicationActivateAllWindows];\n#endif\n    \n    #if TKTK\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n    [NSApplication sharedApplication];\n    [NSApp setDelegate:[[AppDelegate alloc] init]];\n    [NSApp run];\n    [pool release];\n    #else\n    @autoreleasepool {\n        NSApplication *pApplication = [NSApplication sharedApplication];\n        AppDelegate *delegate = [AppDelegate new];\n        [pApplication setDelegate:delegate];\n        [pApplication run];\n    }\n    #endif\n    \n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/shell/main_osx.mm b/src/shell/main_osx.mm
--- a/src/shell/main_osx.mm	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/shell/main_osx.mm	(date 1684986529356)
@@ -234,3 +234,108 @@
     
     return 0;
 }
+
+
+/*====================
+  FtoA(CGFloat)
+  ====================*/
+tstring  FtoA(CGFloat f, int flags = FMT_NONE, int width = 0, int minPrecision = 0, int maxPrecision = XTOA_DEFAULT_FLOAT_PRECISION)
+{
+    tstring s;
+    FormatFloat(f, flags, width, minPrecision, maxPrecision, s);
+    return s;
+}
+
+/*====================
+  CConsoleStream::operator<<(const NSString*)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const NSString* it)
+{
+    self << [it UTF8String];
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGPoint&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGPoint& pt)
+{
+    self << _T("");
+    self << _T("x=") << FtoA(pt.x);
+    self << _T(", ");
+    self << _T("y=") << FtoA(pt.y);
+    self << _T("");
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGSize&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGSize& it)
+{
+    self << NSStringFromSize(it);
+//    self << _T("width=") << FtoA(it.width);
+//    self << _T(", ");
+//    self << _T("height=") << FtoA(it.height);
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGRect&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGRect& it)
+{
+    self << NSStringFromRect(it);
+    // self << it.origin << _T(", ") << it.size;
+    return self;
+}
+
+/*====================
+  GetWindowFrame
+  ====================*/
+NSRect GetWindowFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [window frame];
+}
+
+/*====================
+  GetWindowFrameForContent
+  ====================*/
+NSRect GetWindowContentFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [window contentRectForFrameRect:[window frame]];
+}
+
+/*====================
+  GetTitlebarHeight
+  ====================*/
+CGFloat GetTitlebarHeight(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return GetWindowFrame(window).size.height - GetWindowContentFrame(window).size.height;
+}
+
+/*====================
+  GetScreenVisibleFrame
+  ====================*/
+NSRect GetScreenVisibleFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [[window screen] visibleFrame];
+}
+
+CMD(WindowOuterRect)
+{
+    Console.Std << GetWindowFrame() << newl;
+    return true;
+}
+
+CMD(WindowInnerRect)
+{
+    Console.Std << GetWindowContentFrame() << newl;
+    return true;
+}
+
+CMD(ScreenVisibleRect)
+{
+    Console.Std << GetScreenVisibleFrame() << newl;
+    return true;
+}
\ No newline at end of file
Index: src/k2/i_widget.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_widget.h\n//\n//=============================================================================\n#ifndef __I_WIDGET_H__\n#define __I_WIDGET_H__\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"c_widgetreference.h\"\n#include \"c_widgetstyle.h\"\n#include \"c_draw2d.h\"\n#include \"c_lerps.h\"\n//=============================================================================\n\n//=============================================================================\n// Declarations\n//=============================================================================\nclass CUITrigger;\nclass CUIWatcher;\nclass IWidget;\nclass CInterface;\nclass CXMLNode;\nclass CBufferStatic;\nclass CWidgetState;\nclass IDragWidget;\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\nenum EWidgetType\n{\n    WIDGET_INVALID = -1,\n\n    WIDGET_INTERFACE = 0,\n\n    WIDGET_PANEL,\n    WIDGET_BUTTON,\n    WIDGET_LABEL,\n    WIDGET_IMAGE,\n    WIDGET_TEXTBOX,\n    WIDGET_LISTBOX,\n    WIDGET_LISTITEM,\n    WIDGET_SLIDER,\n    WIDGET_SLIDERHANDLE,\n    WIDGET_SCROLLBAR,\n    WIDGET_FRAME,\n    WIDGET_MODELPANEL,\n    WIDGET_EFFECTPANEL,\n    WIDGET_COMBOBOX,\n    WIDGET_TEXTBUFFER,\n    WIDGET_PIEGRAPH,\n    WIDGET_MAP,\n    WIDGET_TABLE,\n    WIDGET_FLOATER,\n    WIDGET_SNAPTARGET,\n    WIDGET_STATE,\n    WIDGET_BUTTONCATCHER,\n    WIDGET_ANIMATEDIMAGE,\n    WIDGET_CHATBUFFER,\n    WIDGET_MENU,\n    WIDGET_WEBIMAGE,\n    WIDGET_AVATAR,\n    WIDGET_WEBPANEL\n};\n\nenum EWidgetEvent\n{\n    WEVENT_FRAME,\n    WEVENT_TRIGGER,\n    WEVENT_SHOW,\n    WEVENT_HIDE,\n    WEVENT_ENABLE,\n    WEVENT_DISABLE,\n    WEVENT_CHANGE,\n    WEVENT_SLIDE,\n    WEVENT_SELECT,\n    WEVENT_DOUBLECLICK,\n    WEVENT_CLICK,\n    WEVENT_RIGHTCLICK,\n    WEVENT_FOCUS,\n    WEVENT_LOSEFOCUS,\n    WEVENT_LOAD,\n    WEVENT_MOUSEOVER,\n    WEVENT_MOUSEOUT,\n    WEVENT_HOTKEY,\n    WEVENT_SNAP,\n    WEVENT_STARTDRAG,\n    WEVENT_ENDDRAG,\n    WEVENT_TRIGGER0,\n    WEVENT_TRIGGER1,\n    WEVENT_TRIGGER2,\n    WEVENT_TRIGGER3,\n    WEVENT_TRIGGER4,\n    WEVENT_TRIGGER5,\n    WEVENT_TRIGGER6,\n    WEVENT_TRIGGER7,\n    WEVENT_TRIGGER8,\n    WEVENT_TRIGGER9,\n    WEVENT_BUTTON,\n    WEVENT_REFRESH,\n    WEVENT_WAKE,\n    WEVENT_MOUSELDOWN,\n    WEVENT_MOUSELUP,\n    WEVENT_MOUSERDOWN,\n    WEVENT_MOUSERUP,\n    WEVENT_RELOAD,\n    WEVENT_EVENT,\n    WEVENT_EVENT0,\n    WEVENT_EVENT1,\n    WEVENT_EVENT2,\n    WEVENT_EVENT3,\n    WEVENT_EVENT4,\n    WEVENT_EVENT5,\n    WEVENT_EVENT6,\n    WEVENT_EVENT7,\n    WEVENT_EVENT8,\n    WEVENT_EVENT9,\n    WEVENT_KEYDOWN,\n    WEVENT_KEYUP,\n    WEVENT_INSTANTIATE,\n    WEVENT_TAB,\n    WEVENT_OPEN,\n    WEVENT_CLOSE,\n    WEVENT_FADED,\n\n    NUM_WEVENTS\n};\n\nconst bool WIDGET_EVENT_RECURSIVE[] =\n{\n    false,  // WEVENT_FRAME\n    false,  // WEVENT_TRIGGER\n    true,   // WEVENT_SHOW\n    true,   // WEVENT_HIDE\n    true,   // WEVENT_ENABLE\n    true,   // WEVENT_DISABLE\n    false,  // WEVENT_CHANGE\n    false,  // WEVENT_SLIDE\n    false,  // WEVENT_SELECT\n    false,  // WEVENT_DOUBLECLICK\n    false,  // WEVENT_CLICK\n    false,  // WEVENT_RIGHTCLICK\n    false,  // WEVENT_FOCUS\n    false,  // WEVENT_LOSEFOCUS\n    true,   // WEVENT_LOAD\n    false,  // WEVENT_MOUSEOVER\n    false,  // WEVENT_MOUSEOUT\n    false,  // WEVENT_HOTKEY\n    false,  // WEVENT_SNAP\n    false,  // WEVENT_STARTDRAG\n    false,  // WEVENT_ENDDRAG\n    false,  // WEVENT_TRIGGER0\n    false,  // WEVENT_TRIGGER1\n    false,  // WEVENT_TRIGGER2\n    false,  // WEVENT_TRIGGER3\n    false,  // WEVENT_TRIGGER4\n    false,  // WEVENT_TRIGGER5\n    false,  // WEVENT_TRIGGER6\n    false,  // WEVENT_TRIGGER7\n    false,  // WEVENT_TRIGGER8\n    false,  // WEVENT_TRIGGER9\n    false,  // WEVENT_BUTTON\n    true,   // WEVENT_REFRESH\n    false,  // WEVENT_WAKE\n    false,  // WEVENT_MOUSELDOWN\n    false,  // WEVENT_MOUSELUP\n    false,  // WEVENT_MOUSERDOWN\n    false,  // WEVENT_MOUSERUP\n    true,   // WEVENT_RELOAD\n    false,  // WEVENT_EVENT\n    false,  // WEVENT_EVENT0\n    false,  // WEVENT_EVENT1\n    false,  // WEVENT_EVENT2\n    false,  // WEVENT_EVENT3\n    false,  // WEVENT_EVENT4\n    false,  // WEVENT_EVENT5\n    false,  // WEVENT_EVENT6\n    false,  // WEVENT_EVENT7\n    false,  // WEVENT_EVENT8\n    false,  // WEVENT_EVENT9\n    false,  // WEVENT_KEYDOWN\n    false,  // WEVENT_KEYUP\n    true,   // WEVENT_INSTANTIATE\n    false,  // WEVENT_TAB\n    false,  // WEVENT_OPEN\n    false,  // WEVENT_CLOSE\n    false   // WEVENT_FADED\n};\n\nenum EWidgetFloat\n{\n    WFLOAT_NONE,\n    WFLOAT_RIGHT,\n    WFLOAT_BOTTOM\n};\n\nenum EAlignment\n{\n    ALIGN_LEFT,\n    ALIGN_TOP = ALIGN_LEFT,\n    ALIGN_CENTER,\n    ALIGN_RIGHT,\n    ALIGN_BOTTOM = ALIGN_RIGHT\n};\n\nenum EWidgetRenderMode\n{\n    WRENDER_NORMAL,\n    WRENDER_ADDITIVE,\n    WRENDER_OVERLAY,\n    WRENDER_GRAYSCALE,\n    WRENDER_BLUR\n};\n\nconst uint WFLAG_VISIBLE                (BIT(0));\nconst uint WFLAG_ENABLED                (BIT(1));\nconst uint WFLAG_NO_CLICK               (BIT(2));\nconst uint WFLAG_GROW_WITH_CHILDREN     (BIT(3));\nconst uint WFLAG_RESIZING               (BIT(4));\nconst uint WFLAG_REGROW                 (BIT(5));\nconst uint WFLAG_ORIENT_VERTICAL        (BIT(6));\nconst uint WFLAG_NO_DRAW                (BIT(7));\nconst uint WFLAG_CAN_GRAB               (BIT(8));\nconst uint WFLAG_INTERACTIVE            (BIT(9));\nconst uint WFLAG_LIST                   (BIT(10));\nconst uint WFLAG_PASSIVE_CHILDREN       (BIT(11));\nconst uint WFLAG_BLOCK_INPUT            (BIT(12));\nconst uint WFLAG_UTILE                  (BIT(13));\nconst uint WFLAG_VTILE                  (BIT(14));\nconst uint WFLAG_REVERSE                (BIT(15));\nconst uint WFLAG_RENDER_TOP             (BIT(16));\nconst uint WFLAG_HFLIP                  (BIT(17));\nconst uint WFLAG_VFLIP                  (BIT(18));\nconst uint WFLAG_STICKY                 (BIT(19));\nconst uint WFLAG_STICKYSIZING           (BIT(20));\nconst uint WFLAG_STICKYTOINVIS          (BIT(21));\nconst uint WFLAG_CROPTEXTURE            (BIT(22));\nconst uint WFLAG_WASVISIBLE             (BIT(23));\nconst uint WFLAG_NEEDSPURGE             (BIT(24));\nconst uint WFLAG_DEAD                   (BIT(25));\nconst uint WFLAG_RELEASED               (BIT(26));\nconst uint WFLAG_PROCESS_AXIS           (BIT(27));\nconst uint WFLAG_PROCESS_CURSOR         (BIT(28));\nconst uint WFLAG_RESIZE_PARENT_WIDTH    (BIT(29));\nconst uint WFLAG_RESIZE_PARENT_HEIGHT   (BIT(30));\nconst uint WFLAG_GROW_WITH_INVIS        (BIT(31));\n\nconst int WIDGET_RENDER_BOTTOM  (BIT(0));\nconst int WIDGET_RENDER_TOP     (BIT(1));\nconst int WIDGET_RENDER_ALL     (WIDGET_RENDER_BOTTOM | WIDGET_RENDER_TOP);\n\n#define MAX_TAB_ORDER   500\nconst uint MAX_WIDGET_TEXTURES(4);\nconst TCHAR IMAGELIST_SEPERATOR(_T('\\x9D'));\n\n#define DO_EVENT(x) \\\n{\\\n    DoEvent(x);\\\n    \\\n    if (IsDead() || IsReleased())\\\n        return;\\\n}\n\n#define DO_EVENT_RETURN(x, y) \\\n{\\\n    DoEvent(x);\\\n    \\\n    if (IsDead() || IsReleased())\\\n        return y;\\\n}\n\n#define DO_EVENT_PARAM(x, y) \\\n{\\\n    DoEvent(x, y);\\\n    \\\n    if (IsDead() || IsReleased())\\\n        return;\\\n}\n\n#define DO_EVENT_PARAM_RETURN(x, y, z) \\\n{\\\n    DoEvent(x, y);\\\n    \\\n    if (IsDead() || IsReleased())\\\n        return z;\\\n}\n\n// DECLARE_SUB_WIDGET_ACCESSOR\n#define DECLARE_SUB_WIDGET_ACCESSOR(type, name) \\\nvirtual bool                Is##name() const    { return false; } \\\nvirtual class type*         GetAs##name()       { return nullptr; } \\\nvirtual const class type*   GetAs##name() const { return nullptr; }\n\n// SUB_ENTITY_ACCESSOR\n#define SUB_WIDGET_ACCESSOR(type, name) \\\npublic: \\\n    bool                    Is##name() const    { return true; } \\\n    class type*             GetAs##name()       { return this; } \\\n    const class type*       GetAs##name() const { return this; } \\\n    static const tstring&   GetBaseTypeName()   { static const tstring sBaseTypeName(_CTS(#name)); return sBaseTypeName; }\n//=============================================================================\n\n//=============================================================================\n// IWidget\n//=============================================================================\nclass K2_API IWidget\n{\nprivate:\n    static int          s_iNumWidgets;\n\nprotected:\n    typedef pair<tstring, tstring>                      TStringPair;\n    typedef map<tstring, tstring, std::less<tstring> >  PropertyMap;\n\n    typedef vector<IWidget*>                            WidgetPointerVector;\n    typedef WidgetPointerVector::iterator               WidgetPointerVector_it;\n    typedef WidgetPointerVector::const_iterator         WidgetPointerVector_cit;\n    typedef WidgetPointerVector::reverse_iterator       WidgetPointerVector_rit;\n\n    typedef pair<IWidget*, IWidget*>                    WidgetPair;\n    typedef vector<WidgetPair>                          WidgetPointerVectorNewParent;\n    typedef vector<WidgetPair>::iterator                WidgetPointerVectorNewParent_it;\n\n    typedef vector<CUIWatcher*>                         WatcherVector;\n    typedef WatcherVector::iterator                     WatcherVector_it;\n\n    typedef vector<WatcherVector>                       WatcherVectorVector;\n    typedef WatcherVectorVector::iterator               WatcherVectorVector_it;\n\n    typedef vector<CWidgetReference*>                   ReferenceVector;\n    typedef ReferenceVector::iterator                   ReferenceVector_it;\n\n    // Frame variables\n    uint                m_uiFlags;\n    uint                m_uiTargetTimeHeight;\n    uint                m_uiMoveStartTimeHeight;\n    uint                m_uiTargetTimeWidth;\n    uint                m_uiMoveStartTimeWidth;\n    uint                m_uiTargetTimeRotation;\n    uint                m_uiMoveStartTimeRotation;\n    uint                m_uiTargetTimeX;\n    uint                m_uiMoveStartTimeX;\n    uint                m_uiTargetTimeY;\n    uint                m_uiMoveStartTimeY;\n    int                 m_iDirectionHeight;\n    int                 m_iDirectionWidth;\n\n    uint                m_uiFadeEndTime;\n    float               m_fUSpeed;\n    float               m_fVSpeed;\n    uint                m_uiHideTime;\n    uint                m_uiWakeTime;\n\n    typedef pair<uint, tstring>     WakeEvent;\n    typedef list<WakeEvent>         WakeEventList;\n    WakeEventList       m_vPendingWakeEvents;\n\n    bool                m_bReGrow;\n    bool                m_bMouseOut;\n    WidgetPointerVector m_vChildren;\n    tsvector            m_WidgetEvents;\n\n    // Render variables\n    CRectf              m_recArea;\n    EWidgetRenderMode   m_eRenderMode;\n    bool                m_bTileU;\n    bool                m_bTileV;\n    CVec4f              m_v4Color;\n    ResHandle           m_hTexture[MAX_WIDGET_TEXTURES];\n    tsvector            m_sTextureName;\n    float               m_fRotation;\n    float               m_fUOffset;\n    float               m_fVOffset;\n    float               m_fUScale;\n    float               m_fVScale;\n\n    IWidget*            m_pParent;\n    CInterface*         m_pInterface;\n    uint                m_uiID;\n    tstring             m_sName;\n    tstring             m_sGroupName;\n    tstring             m_sResourceContext;\n    float               m_fPadding;\n    uint                m_uiTabOrder;\n    EButton             m_eHotkey;\n\n    EWidgetType         m_eWidgetType;\n    EWidgetFloat        m_eFloat;\n    EWidgetFloat        m_eAdhere;\n    EAlignment          m_eAlignment;\n    EAlignment          m_eVAlignment;\n    CWidgetReference    m_refStickyTarget;\n\n    tstring             m_sWidth;\n    tstring             m_sHeight;\n    float               m_fLastWidth;\n    float               m_fLastHeight;\n\n    tstring             m_sBaseX;\n    tstring             m_sBaseY;\n\n    tstring             m_sMarginH;\n    tstring             m_sMarginV;\n\n    float               m_fCropS0, m_fCropS1;\n    float               m_fCropT0, m_fCropT1;\n    float               m_fStartX;\n    float               m_fStartY;\n    float               m_fStartRotation;\n    float               m_fStartWidth;\n    float               m_fStartHeight;\n    float               m_fTargetX;\n    float               m_fTargetY;\n    float               m_fTargetRotation;\n    float               m_fTargetWidth;\n    float               m_fTargetHeight;\n\n    float               m_fSpacing;\n    \n    CWidgetReference    m_refFloatTarget;\n    CWidgetReference    m_refAdhereTarget;\n\n    float               m_fFadeCurrent;\n    float               m_fFadeStart;\n    float               m_fFadeEnd;\n    uint                m_uiFadeStartTime;\n\n    CVec2f              m_v2LastCursorPos;\n    \n    WatcherVector       m_vWatched;\n    WatcherVectorVector m_vvWatched;\n\n    WidgetPointerVector             m_vBringToFront;\n    WidgetPointerVector             m_vAddChild;\n    WidgetPointerVectorNewParent    m_vMoveChild;\n    \n\n    tsvector            m_vEventParam;\n    ReferenceVector     m_vReferences;\n\n    CLerpFloat*     m_pLerp;\n        \n    void                LoadTextures();\n    virtual void        RenderWidget(const CVec2f &vOrigin, float fFade);\n\n    void    AddReference(CWidgetReference *pRef)    { if (pRef != nullptr) m_vReferences.push_back(pRef); }\n    \n    void    RemoveReference(CWidgetReference *pRef)\n    {\n        ReferenceVector_it itFind(find(m_vReferences.begin(), m_vReferences.end(), pRef));\n        while (itFind != m_vReferences.end())\n        {\n            m_vReferences.erase(itFind);\n            itFind = find(m_vReferences.begin(), m_vReferences.end(), pRef);\n        }\n    }\n    \n    void    LostReference(IWidget *pWidget);\n\n    friend class CWidgetReference;\n\npublic:\n    virtual ~IWidget();\n    IWidget(CInterface *pInterface, IWidget *pParent, EWidgetType widgetType, const CWidgetStyle &style, bool bLoadTextures = true);\n\n    DECLARE_SUB_WIDGET_ACCESSOR(IDragWidget, DragWidget)\n\n    void                Kill()                                          { SetFlags(WFLAG_DEAD); }\n    bool                IsDead() const                                  { return HasFlags(WFLAG_DEAD); }\n    bool                IsReleased() const                              { return HasFlags(WFLAG_RELEASED); }\n    void                RequestPurge();\n    bool                NeedsPurge() const                              { return HasFlags(WFLAG_NEEDSPURGE); }\n\n    WidgetPointerVector&    GetChildList()                              { return m_vChildren; }\n    void                    SetParent(IWidget *pParent)                 { m_pParent = pParent; }\n    IWidget*                GetParent() const                           { return m_pParent; }\n    CInterface*             GetInterface() const                        { return m_pInterface; }\n\n    void                SetFloatTarget(const CWidgetReference &ref)     { m_refFloatTarget = ref; }\n    IWidget*            GetFloatTarget() const                          { return m_refFloatTarget.GetTarget(); }\n    bool                HasFloatTarget() const                          { return m_refFloatTarget.IsValid(); }\n    void                SetAdhereTarget(const CWidgetReference &ref)    { m_refAdhereTarget = ref; }\n    IWidget*            GetAdhereTarget() const                         { return m_refAdhereTarget.GetTarget(); }\n    void                SetStickyTarget(const CWidgetReference &ref);\n    IWidget*            GetStickyTarget() const                         { return m_refStickyTarget.GetTarget(); }\n    CVec2f              GetFloatPosition(float fSpacing);\n    void                ApplyStickiness();\n    void                ResizeParent();\n\n    uint                GetID() const                                   { return m_uiID; }\n    void                SetID(uint uiID)                                { m_uiID = uiID; }\n\n    const tstring&      GetName() const                                 { return m_sName; }\n    void                SetName(const tstring &sName)                   { m_sName = sName; }\n    const tstring&      GetGroupName() const                            { return m_sGroupName; }\n\n    tstring             GetResourceContext() const;\n\n    static float        PercentageToScreen(float fSize, float fVal)     { return fSize * (fVal / 100.0f); }\n    static float        GetPositionFromString(const tstring &sPos, float fParentSize, float fParentSize2);\n    static float        GetSizeFromString(const tstring &sSize, float fParentSize, float fParentSize2);\n    float               GetTextureOffsetFromString(const tstring &sOffset, EVectorComponent eMajorAxis);\n    float               GetTextureScaleFromString(const tstring &sScale, EVectorComponent eMajorAxis);\n\n    EAlignment          GetAlign() const                                { return m_eAlignment; }\n    EAlignment          GetVAlign() const                               { return m_eVAlignment; }\n    float               GetX() const                                    { return m_recArea.left; }\n    float               GetY() const                                    { return m_recArea.top; }\n    const CVec2f&       GetPos() const                                  { return m_recArea.lt(); }\n    void                SetAlign(EAlignment eAlignment)                 { m_eAlignment = eAlignment; }\n    void                SetVAlign(EAlignment eAlignment)                { m_eVAlignment= eAlignment; }\n    void                SetX(float x)                                   { m_recArea.MoveToX(x); }\n    void                SetY(float y)                                   { m_recArea.MoveToY(y); }\n    void                SetPos(const CVec2f &v2Pos)                     { m_recArea.MoveTo(v2Pos); }\n    void                ShiftX(float x)                                 { m_recArea.ShiftX(x); }\n    void                ShiftY(float y)                                 { m_recArea.ShiftY(y); }\n\n    void                SetUOffset(float u)                             { m_fUOffset = u; }\n    void                SetVOffset(float v)                             { m_fVOffset = v; }\n    void                SetUScale(float u)                              { m_fUScale = u; }\n    void                SetVScale(float v)                              { m_fVScale = v; }\n    void                SetUSpeed(float u)                              { m_fUSpeed = u; }\n    void                SetVSpeed(float v)                              { m_fVSpeed = v; }\n\n    virtual void        RecalculateChildSize();\n    virtual void        RecalculateSize();\n    virtual void        RecalculatePosition();\n\n    float               GetWidth() const                                { return m_recArea.GetWidth(); }\n    float               GetHeight() const                               { return m_recArea.GetHeight(); }\n    virtual void        SetWidth(float w)                               { m_recArea.SetSizeX(w); }\n    virtual void        SetHeight(float h)                              { m_recArea.SetSizeY(h); }\n    CRectf&             GetRect()                                       { return m_recArea; }\n    CRectf              GetStickyRect();\n    virtual void        SetRect(const CRectf &recArea)                  { m_recArea = recArea; }\n    float               GetRotation() const                             { return m_fRotation; }\n    void                SetRotation(float rot)                          { m_fRotation = rot; }\n\n    virtual float       GetParentWidth() const                          { IWidget *pParent(GetParent()); return pParent ? pParent->GetWidth() : Draw2D.GetScreenW(); }\n    virtual float       GetParentHeight() const                         { IWidget *pParent(GetParent()); return pParent ? pParent->GetHeight() : Draw2D.GetScreenH(); }\n\n    const tstring&      GetBaseWidth() const                            { return m_sWidth; }\n    const tstring&      GetBaseHeight() const                           { return m_sHeight; }\n    const tstring&      GetBaseX() const                                { return m_sBaseX; }\n    const tstring&      GetBaseY() const                                { return m_sBaseY; }\n\n    void                SetBaseWidth(const tstring &sValue)             { m_sWidth = sValue; }\n    void                SetBaseHeight(const tstring &sValue)            { m_sHeight = sValue; }\n    void                SetBaseX(const tstring &sValue)                 { m_sBaseX = sValue; }\n    void                SetBaseY(const tstring &sValue)                 { m_sBaseY = sValue; }\n\n    bool                HasFlags(uint uiFlags) const                    { return (m_uiFlags & uiFlags) != 0; }\n    bool                HasAllFlags(uint uiFlags) const                 { return (m_uiFlags & uiFlags) == uiFlags; }\n    void                SetFlags(uint uiFlags)                          { m_uiFlags |= uiFlags; }\n    void                UnsetFlags(uint uiFlags)                        { m_uiFlags &= ~uiFlags; }\n    void                ClearFlags()                                    { m_uiFlags = 0; }\n\n    void                SetFlagsRecursive(uint uiFlags)                 { if (m_pParent) m_pParent->SetFlagsRecursive(uiFlags); SetFlags(uiFlags); }\n\n    virtual void        SetColor(const CVec4f &v4Color)                 { m_v4Color = v4Color; }\n    void                SetColor(const tstring &sColor)                 { SetColor(GetColorFromString(sColor)); }\n    const CVec4f&       GetColor() const                                { return m_v4Color; }\n    \n    void                SetRenderMode(EWidgetRenderMode eRenderMode)    { m_eRenderMode = eRenderMode; }\n    void                SetRenderMode(const tstring &sRenderMode);\n\n    void                Move(float iX, float iY);\n    void                SlideX(float fX, uint uiTime);\n    void                SlideY(float fY, uint uiTime);\n    void                Rotate(float fRotation, uint uiTime, bool bRecurse = false);\n    void                ScaleWidth(float fWidth, uint uiTime, int iDirection, bool bRecurse = false);\n    void                ScaleHeight(float fHeight, uint uiTime, int iDirection, bool bRecurse = false);\n\n    float               GetCurrentFade() const                          { return m_fFadeCurrent * ((m_pParent == nullptr) ? 1.0f : m_pParent->GetCurrentFade()); }\n    CVec4f              GetFadedColor(const CVec4f &v4ColorIn, float fFade) const;\n    void                FadeOut(uint uiTime);\n    void                FadeIn(uint uiTime);\n    void                Fade(float fStart, float fEnd, uint uiTime);\n\n    virtual void        SetTexture(const tstring &sTexture);\n    virtual void        SetTexture(const tstring &sTexture, const tstring &sSuffix);\n    const tstring&      GetTexture(uint uiIdx);\n\n    void                AddChild(IWidget *pChild);\n    void                SetGroup(const tstring &sGroupName);\n\n    void                SetLerp(tstring sName, float fTarget, uint iTime, uint iType , int iStyle);\n    CLerpFloat*         GetLerp()                                       {return m_pLerp;}\n\n    void                SetWatch(const tstring &sWatch);\n    void                StopWatching(CUITrigger *pTrigger);\n\n    virtual void        Show(uint uiDuration = -1);\n    virtual void        Hide();\n    virtual void        Enable();\n    virtual void        Disable();\n\n    virtual void        SetSleepTimer(uint uiDuration);\n    void                ClearWakeEvents();\n    void                PushWakeEvent(uint uiDuration, const tstring &sCommand);\n\n    void                SetType(EWidgetType widgetType)                 { m_eWidgetType = widgetType; }\n    EWidgetType         GetType()                                       { return m_eWidgetType; }\n\n    uint                GetTabOrder()                                   { return m_uiTabOrder; }\n\n    bool                IsAbsoluteVisible();\n    bool                IsAbsoluteEnabled();\n    bool                IsEnabled()                                     { return HasFlags(WFLAG_ENABLED); }\n    bool                IsInteractive()                                 { return HasFlags(WFLAG_INTERACTIVE); }\n\n    CVec2f&             GetSavedCursorPos()                             { return m_v2LastCursorPos; }\n    bool                HasSavedCursorPos()                             { return (m_v2LastCursorPos.x == -1 && m_v2LastCursorPos.y == -1) ? false : true; }\n\n    virtual CVec2f      GetAbsolutePos();\n\n    virtual IWidget*    GetWidget(const CVec2f &v2Pos, bool bClick = false);\n    bool                Contains(const CVec2f &v2Pos);\n\n    virtual void        SetValue(int i)                                 { SetValue(XtoA(i)); }\n    virtual void        SetValue(float f)                               { SetValue(XtoA(f)); }\n    virtual void        SetValue(const tstring &s)                      {}\n    virtual tstring     GetValue() const                                { return _T(\"\"); }\n\n    virtual void        MouseDown(EButton button, const CVec2f &v2CursorPos)    {};\n    virtual void        MouseUp(EButton button, const CVec2f &v2CursorPos)      {};\n\n    virtual void        Rollover()                                      { DoEvent(WEVENT_MOUSEOVER); }\n    virtual void        Rolloff()                                       { DoEvent(WEVENT_MOUSEOUT); }\n    \n    virtual void        Focus()                                         { DoEvent(WEVENT_FOCUS); }\n    virtual void        LoseFocus()                                     { DoEvent(WEVENT_LOSEFOCUS); }\n\n    virtual bool        ButtonDown(EButton button);\n    virtual bool        ButtonUp(EButton button)                        { return false; }\n    virtual bool        Char(TCHAR ch)                                  { return false; }\n\n    virtual void        Render(const CVec2f &vOrigin, int iFlag, float fFade);\n\n    virtual bool        ProcessInputMouseButton(const CVec2f &v2CursorPos, EButton button, float fValue);\n    virtual bool        ProcessInputAxis(EAxis axis, float fValue);\n    virtual bool        ProcessInputCursor(const CVec2f &v2CursorPos);\n    virtual bool        ProcessHotKeys(EButton eButton);\n    virtual uint        GetMinimapHoverUnit();\n\n    virtual void        Frame(uint uiFrameLength, bool bProcessFrame);\n    virtual void        Purge();\n\n    const tsvector&     GetEventParam()                                 { return m_vEventParam; }\n    void                SetEventParam(const tsvector &vParam)           { m_vEventParam = vParam; }\n\n    void                SetEventCommand(EWidgetEvent eEvent, const tstring &sCommand);\n    void                ClearEventCommand(EWidgetEvent eEvent);\n    virtual void        DoEvent(EWidgetEvent eEvent, const tstring &sParam = TSNULL);\n    virtual void        DoEvent(EWidgetEvent eEvent, const tsvector &vParam);\n    \n    virtual void        Execute(const tstring &sScript);\n    virtual void        Execute(const tstring &sCmd, IBuffer &buffer)   {}\n\n    virtual bool        CheckSnapTargets(CVec2f &v2Pos, IWidget *pWidget);\n    virtual bool        CheckSnapTo(CVec2f &v2Pos, IWidget *pWidget);\n\n    virtual tstring     GetCopyString()                         { return _T(\"\"); }\n    virtual void        PasteString(const tstring &sString)     {}\n\n    virtual CWidgetState*   AllocateWidgetState(const CWidgetStyle &style);\n    virtual bool            AddWidgetState(CWidgetState *pState);\n\n    static int          GetNumWidgets()                         { return s_iNumWidgets; }\n\n    virtual void        WidgetLost(IWidget *pWidget);\n    virtual void        LoseChildren();\n    virtual bool        RemoveChild(IWidget *pChild);\n\n    virtual void        BringChildToFront(IWidget *pWidget);\n    virtual void        AddChildWidget(IWidget *pWidget);\n    virtual void        SetChildNewParent(IWidget *pChild, IWidget *pParent);\n\n    virtual void        Clear()                                 {}\n\n    virtual void        UpdateChildAlignment(IWidget *pUpdateFrom);\n    virtual void        RealignToSticky();\n\n    virtual bool        ChildHasFocus();\n\n    virtual float       GetAbsoluteFractionX(float fFraction) const;\n    virtual float       GetAbsoluteFractionY(float fFraction) const;\n\n    virtual bool        UseMouseDown() const                    { return true; }\n\n    void                SetPassiveChildren(bool bPassiveChildren);\n    void                SetNoClick(bool bNoClick);\n\n    void                SetFocus(bool bFocus);\n    bool                HasFocus() const;\n\n    void                DeleteChildren();\n};\n//=============================================================================\n\n#endif // __I_WIDGET_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_widget.h b/src/k2/i_widget.h
--- a/src/k2/i_widget.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/i_widget.h	(date 1684983393313)
@@ -463,6 +463,9 @@
     friend class CWidgetReference;
 
 public:
+    IWidget() = delete;
+    IWidget(const IWidget&) = delete;
+
     virtual ~IWidget();
     IWidget(CInterface *pInterface, IWidget *pParent, EWidgetType widgetType, const CWidgetStyle &style, bool bLoadTextures = true);
 
Index: src/public/vid_driver_t.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// SVidDriver.h\n//\n//=============================================================================\n#ifndef __VID_DRIVER_T__\n#define __VID_DRIVER_T__\n\n//=============================================================================\n// Declarations\n//=============================================================================\nstruct SVidMode;\nstruct SAAMode;\nclass CTexture;\nclass CVertexShader;\nclass CPixelShader;\nclass CModel;\nclass CBitmap;\nclass CCamera;\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\nenum EVidNotifyMessage\n{\n    VID_NOTIFY_NEW_WORLD = 1,\n    //a new world has been loaded\n    VID_NOTIFY_TERRAIN_COLOR_MODIFIED,\n    //the terrain colormap or dynamap has been modified\n    //param1: xpos   param2: ypos\n    //param3: bool indicating if ALL terrain should be rebuilt (if so, first 2 params are ignored)\n    VID_NOTIFY_TERRAIN_VERTEX_MODIFIED,\n    //world.grid has been modified\n    //param1: xpos   param2: ypos\n    //param3: bool indicating if ALL terrain should be rebuilt (if so, first 2 params are ignored)\n    VID_NOTIFY_TERRAIN_SHADER_MODIFIED,\n    //a shader on the terrain has been changed\n    //param1: xpos   param2: ypos\n    //param3: bool indicating if ALL terrain should be rebuilt (if so, first 2 params are ignored)\n    VID_NOTIFY_TERRAIN_TEXCOORD_MODIFIED,\n    //unused\n    VID_NOTIFY_TERRAIN_NORMAL_MODIFIED,\n    //a normal on the terrain has been changed\n    //param1: xpos   param2: ypos\n    //param3: bool indicating if ALL terrain should be rebuilt (if so, first 2 params are ignored)\n    VID_NOTIFY_TERRAIN_TEXEL_ALPHA_MODIFIED,\n    VID_NOTIFY_WORLD_DESTROYED,\n    //the world has been destroyed\n    VID_NOTIFY_FOLIAGE_DENSITY_MODIFIED,\n    //...\n    VID_NOTIFY_FOLIAGE_SIZE_MODIFIED,\n    //...\n    VID_NOTIFY_FOLIAGE_TEXTURE_MODIFIED,\n    //...\n    VID_NOTIFY_TEXTURE_FILTERING_SETTINGS_MODIFIED,\n    //texture filtering settings modified\n    VID_NOTIFY_X11_EVENT,\n    //pass along X11 events that the renderer needs to know about\n    VID_NOTIFY_UPDATE_SHADERS,\n    //update shaders\n    VID_NOTIFY_RELOAD_SHADER_CACHE,\n    //reload shader cache\n    VID_NOTIFY_ADD_CLIFF,\n    VID_NOTIFY_REMOVE_CLIFF,\n    VID_NOTIFY_REBUILD_CLIFFS,\n    VID_NOTIFY_FOG_OF_WAR\n};\n\nenum ETextureFilteringModes\n{\n    TEXTUREFILTERING_NONE = 0,\n    TEXTUREFILTERING_BILINEAR,\n    TEXTUREFILTERING_TRILINEAR,\n    TEXTUREFILTERING_ANISOTROPIC2,\n    TEXTUREFILTERING_ANISOTROPIC4,\n    TEXTUREFILTERING_ANISOTROPIC6,\n    TEXTUREFILTERING_ANISOTROPIC8,\n    TEXTUREFILTERING_ANISOTROPIC12,\n    TEXTUREFILTERING_ANISOTROPIC16,\n    TEXTUREFILTERING_ANISOTROPIC32,\n\n    NUM_TEXTUREFILTERING_MODES\n};\n\n// This structure holds pointers to all fundamental graphics functions\nstruct SVidDriver\n{\n    tstring         sDriverName;\n\n    int             (*Init)();\n    void            (*Start)();\n    int             (*SetMode)();\n    bool            (*GetMode)(int iMode, SVidMode *pVidMode);\n    bool            (*GetCurrentMode)(SVidMode *pVidMode);\n    bool            (*IsFullScreen)();\n    void            (*Shutdown)();\n    \n    bool            (*TextureFilteringModeAvailable)(ETextureFilteringModes eMode);\n\n    // Rendering\n    void            (*BeginFrame)();\n    void            (*EndFrame)();\n    void            (*RenderScene)(class CCamera &camera);\n    void            (*Add2dRect)(float x, float y, float w, float h, float s1, float t1, float s2, float t2, ResHandle hTexture, int iFlags);\n    void            (*Add2dQuad)(const CVec2f& v1, const CVec2f& v2, const CVec2f& v3, const CVec2f& v4,\n                                    const CVec2f& t1, const CVec2f& t2, const CVec2f& t3, const CVec2f& t4, ResHandle hTexture, int iFlags);\n    void            (*Add2dLine)(const CVec2f& v1, const CVec2f& v2, const CVec4f &v4Color1, const CVec4f &v4Color2, int iFlags);\n    void            (*AddPoint)(const CVec3f &v3Point, const CVec4f &v4Color);\n    void            (*AddLine)(const CVec3f &v3Start, const CVec3f &v3End, const CVec4f &v4Color);\n    void            (*SetColor)(CVec4f v4Color);\n    void            (*Notify)(enum EVidNotifyMessage eMsg, int iParam1, int iParam2, int iParam3, void *pData, const tstring &sResContext);\n    void            (*GetFrameBuffer)(CBitmap &bmp);\n    CVec2f          (*ProjectVertex)(const class CCamera &cam, const CVec3f &vecVertex);\n\n    void*           (*GetHWnd)();\n    void            (*Clear)();\n\n    void            (*OpenTextureArchive)(bool bNoReload);\n    void            (*CloseTextureArchive)();\n    void            (*GetTextureList)(const tstring &sPath, const tstring &sSearch, tsvector &vResult);\n    bool            (*TextureExists)(const tstring &sFilename, uint uiTextureFlags);\n\n    int             (*RegisterTexture)(CTexture *pTexture);\n    void            (*UnregisterTexture)(CTexture *pTexture);\n\n    int             (*RegisterVertexShader)(CVertexShader *pVertexShader);\n    void            (*UnregisterVertexShader)(CVertexShader *pVertexShader);\n\n    int             (*RegisterPixelShader)(CPixelShader *pPixelShader);\n    void            (*UnregisterPixelShader)(CPixelShader *pPixelShader);\n\n    void            (*RegisterShaderPair)(CVertexShader *pVertexShader, CPixelShader *pPixelShader);\n\n    int             (*RegisterModel)(CModel *pModel);\n    void            (*UnregisterModel)(CModel *pModel);\n\n    const CCamera*  (*GetCamera)();\n\n    void            (*RenderFogofWar)(float fClear, bool bTexture, float fLerp);\n    void            (*UpdateFogofWar)(const CBitmap &cBmp);\n\n    void            (*ShowCursor)(bool bShow);\n    void            (*SetCursor)(ResHandle hCursor);\n\n    CVec4f          (*GetTextureColor)(CTexture *pTexture);\n\n    bool            (*GetAAMode)(int iMode, SAAMode *pAAmode);\n    bool            (*GetCurrentAAMode)(SAAMode *pAAmode);\n};\n//=============================================================================\n\n#endif // __VID_DRIVER_T__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/public/vid_driver_t.h b/src/public/vid_driver_t.h
--- a/src/public/vid_driver_t.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/public/vid_driver_t.h	(date 1684987088117)
@@ -92,6 +92,7 @@
     int             (*SetMode)();
     bool            (*GetMode)(int iMode, SVidMode *pVidMode);
     bool            (*GetCurrentMode)(SVidMode *pVidMode);
+    bool            (*GetMaxWindowSize)(SVidMode *pVidMode);
     bool            (*IsFullScreen)();
     void            (*Shutdown)();
     
Index: src/k2/k2_settings.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2006 S2 Games\n// k2_settings.h\n//\n//=============================================================================\n#ifndef __K2_SETTINGS_H__\n#define __K2_SETTINGS_H__\n\n//=============================================================================\n// Definitions\n//=============================================================================\n//#define UNICODE\n//#define K2_PROFILE\n\n#ifdef _WIN32\n#define USE_SECURE_CRT\n\n#ifndef _DEBUG\n#define _SECURE_SCL 0\n#endif\n\n#endif\n//#define K2_NOSOUND\n\n#define TERRAIN_OCCLUSION   0\nconst bool REQUIRE_AUTHENTICATION(true);\n\n//#define K2_PATHFINDING_RESPECTS_TEAM_VISION\n\n//#define K2_GARENA\n\n// Uncomment only one of K2_SERVER or K2_CLIENT, both commented out means the full client\n// GARENA + TEST is valid\n//#define K2_SERVER\n//#define K2_CLIENT\n//#define K2_TEST\n//#define K2_EXPERIMENTAL\n//#define K2_BALANCE_TEST\n//=============================================================================\n\n#ifdef UNICODE\n#define UNICODE_STRING _T(\" [UNICODE]\")\n#else\n#define UNICODE_STRING _T(\"\")\n#endif\n\n#ifdef K2_PROFILE\n#define PROFILER_STRING _T(\" [PROFILER]\")\n#else\n#define PROFILER_STRING _T(\"\")\n#endif\n\n#ifdef USE_SECURE_CRT\n#define SECURE_CRT_STRING _T(\" [SECURE CRT]\")\n#else\n#define SECURE_CRT_STRING _T(\"\")\n#endif\n\n#ifdef _DEBUG\n#define DEBUG_STRING _T(\" [DEBUG]\")\n#else\n#define DEBUG_STRING _T(\"\")\n#endif\n\n#ifdef K2_NOSOUND\n#define NOSOUND_STRING _T(\" [NO SOUND]\")\n#else\n#define NOSOUND_STRING _T(\"\")\n#endif\n\n#ifdef K2_GARENA\n    #ifdef K2_TEST\n#define GARENA_STRING _T(\" [GARENA TEST]\")\n    #else\n#define GARENA_STRING _T(\" [GARENA]\")\n    #endif\n#else\n#define GARENA_STRING _T(\"\")\n#endif\n\n#define BUILD_INFO_STRING GARENA_STRING DEBUG_STRING UNICODE_STRING PROFILER_STRING SECURE_CRT_STRING NOSOUND_STRING\n//=============================================================================\n\n#endif //__K2_SETTINGS_H__
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/k2_settings.h b/src/k2/k2_settings.h
--- a/src/k2/k2_settings.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/k2_settings.h	(date 1684998954381)
@@ -19,7 +19,7 @@
 #endif
 
 #endif
-//#define K2_NOSOUND
+#define K2_NOSOUND
 
 #define TERRAIN_OCCLUSION   0
 const bool REQUIRE_AUTHENTICATION(true);
Index: src/k2/xtoa.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// xtoa.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"xtoa.h\"\n#include \"stringutils.h\"\n\n#include <iostream>\n#include <iomanip>\n\nusing std::ios;\nusing std::setw;\nusing std::setprecision;\nusing std::streamsize;\n//=============================================================================\n\n/*====================\n  FormatInt\n ====================*/\nvoid    FormatInt(ULONGLONG ull, int flags, size_t width, int base, char sign, string &sStr)\n{\n    // Determine sign character, unless it's\n    // already been determined negative\n    if (sign == 0)\n    {\n        if (flags & FMT_SIGN)\n            sign = '+';\n        else if (flags & FMT_PADSIGN)\n            sign = ' ';\n    }\n\n    // Set up Delimeter\n    int dspacing(0);\n    char dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        switch (base)\n        {\n        case 2:\n            dchar = ' ';\n            dspacing = 8;\n            break;\n\n        case 10:\n            dchar = ',';\n            dspacing = 3;\n        }\n    }\n\n    // Build the string of digits\n    ULONGLONG n(base);\n    int d(1);\n    do\n    {\n        TCHAR c = TCHAR((ull % n) / (n / base));\n        c += (c > 9) ? ((c > 35) ? ('A' - 36) : ('a' - 10)) : '0';\n        sStr += c;\n        ull -= ull % n;\n        if (dchar != 0 && ull != 0 && d == dspacing)\n        {\n            sStr += dchar;\n            d = 0;\n        }\n        ++d;\n        n *= base;\n    }\n    while (ull);\n\n    int padcount(0);\n\n    // Prefixes\n    char prefix[3] = { 0, 0, 0 };\n    if (!(flags & FMT_NOPREFIX))\n    {\n        if (base == 2)\n        {\n            prefix[0] = 'b';\n            padcount -= 1;\n        }\n        else if (base == 8)\n        {\n            prefix[0] = '0';\n            padcount -= 1;\n        }\n        else if (base == 16)\n        {\n            //backwards, the string will be reversed\n            prefix[0] = 'x';\n            prefix[1] = '0';\n            padcount -= 2;\n        }\n    }\n\n    // Prefix is included before non-zero padding\n    if (prefix[0] && !(flags & FMT_PADZERO))\n    {\n        sStr += prefix;\n        padcount = 0;\n    }\n\n    padcount += int(width) - int(sStr.length()) - ((sign == 0) ? 0 : 1);\n\n    // If padding is space, add sign before padding\n    if (!(flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    // Padding\n    char padchar(' ');\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = '0';\n    if (padcount < 0)\n        padcount = 0;\n    string padding(padcount, padchar);\n    // special case to delimit leading zeros\n    if (dchar != 0 && padchar == '0')\n    {\n        for (size_t z(0); z < padding.length(); ++z)\n        {\n            if (z == padding.length() - 1)\n                dchar = ' ';    // last delimiter always looks better as a blank\n\n            if (d == dspacing + 1)\n            {\n                padding[z] = dchar;\n                d = 0;\n            }\n            ++d;\n        }\n    }\n    if (!(flags & FMT_ALIGNLEFT))\n        sStr += padding;\n\n    // Add prefix after zero padding\n    if (prefix[0] && (flags & FMT_PADZERO))\n        sStr += prefix;\n\n    // If padding is 0, add sign after the padding\n    if ((flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    reverse(sStr.begin(), sStr.end());\n\n    // Left aligned padding\n    if ((flags & FMT_ALIGNLEFT) && padchar != '0')\n        sStr += padding;\n}\n\nvoid    FormatInt(ULONGLONG ull, int flags, size_t width, int base, wchar_t sign, wstring &sStr)\n{\n    // Determine sign character, unless it's\n    // already been determined negative\n    if (sign == 0)\n    {\n        if (flags & FMT_SIGN)\n            sign = L'+';\n        else if (flags & FMT_PADSIGN)\n            sign = L' ';\n    }\n\n    // Set up Delimeter\n    int dspacing(0);\n    wchar_t dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        switch (base)\n        {\n        case 2:\n            dchar = L' ';\n            dspacing = 8;\n            break;\n\n        case 10:\n            dchar = L',';\n            dspacing = 3;\n        }\n    }\n\n    // Build the string of digits\n    ULONGLONG n(base);\n    int d(1);\n    do\n    {\n        TCHAR c = TCHAR((ull % n) / (n / base));\n        c += (c > 9) ? ((c > 35) ? (L'A' - 36) : (L'a' - 10)) : L'0';\n        sStr += c;\n        ull -= ull % n;\n        if (dchar != 0 && ull != 0 && d == dspacing)\n        {\n            sStr += dchar;\n            d = 0;\n        }\n        ++d;\n        n *= base;\n    }\n    while (ull);\n\n    int padcount(0);\n\n    // Prefixes\n    wchar_t prefix[3] = { 0, 0, 0 };\n    if (!(flags & FMT_NOPREFIX))\n    {\n        if (base == 2)\n        {\n            prefix[0] = L'b';\n            padcount -= 1;\n        }\n        else if (base == 8)\n        {\n            prefix[0] = L'0';\n            padcount -= 1;\n        }\n        else if (base == 16)\n        {\n            //backwards, the string will be reversed\n            prefix[0] = L'x';\n            prefix[1] = L'0';\n            padcount -= 2;\n        }\n    }\n\n    // Prefix is included before non-zero padding\n    if (prefix[0] && !(flags & FMT_PADZERO))\n    {\n        sStr += prefix;\n        padcount = 0;\n    }\n\n    padcount += int(width) - int(sStr.length()) - ((sign == 0) ? 0 : 1);\n\n    // If padding is space, add sign before padding\n    if (!(flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    // Padding\n    wchar_t padchar(L' ');\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = L'0';\n    if (padcount < 0)\n        padcount = 0;\n    wstring padding(padcount, padchar);\n    // special case to delimit leading zeros\n    if (dchar != 0 && padchar == L'0')\n    {\n        for (size_t z(0); z < padding.length(); ++z)\n        {\n            if (z == padding.length() - 1)\n                dchar = L' ';   // last delimiter always looks better as a blank\n\n            if (d == dspacing + 1)\n            {\n                padding[z] = dchar;\n                d = 0;\n            }\n            ++d;\n        }\n    }\n    if (!(flags & FMT_ALIGNLEFT))\n        sStr += padding;\n\n    // Add prefix after zero padding\n    if (prefix[0] && (flags & FMT_PADZERO))\n        sStr += prefix;\n\n    // If padding is 0, add sign after the padding\n    if ((flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    reverse(sStr.begin(), sStr.end());\n\n    // Left aligned padding\n    if ((flags & FMT_ALIGNLEFT) && padchar != L'0')\n        sStr += padding;\n}\n\n\n/*====================\n  FormatFloat\n ====================*/\nvoid    FormatFloat(double d, int flags, size_t width, int precision, string &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!precision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? '-' : 0), sStr);\n        return;\n    }\n#endif\n    // Determine sign character\n    char sign(0);\n    if (d < 0)\n    {\n        sign = '-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = '+';\n        else if (flags & FMT_PADSIGN)\n            sign = ' ';\n    }\n\n    if (_isnan(d))\n    {\n        sStr += \"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += \"#INF\";\n        return;\n    }\n\n    char szBuffer[256];\n    int iDec;\n    int iSign;\n\n#if defined(_WIN32)\n    _fcvt_s(szBuffer, 256, d, precision, &iDec, &iSign);\n#else\n    strncpy(szBuffer, fcvt(d, precision, &iDec, &iSign), 256);\n#endif\n\n    // Set up Delimeter\n    int dspacing(0);\n    char dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = ',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -precision)\n            iDec = -precision;\n\n        sStr += '0';\n        if (precision > 0)\n            sStr += '.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += '0';\n        for (char *sz(szBuffer); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (char *sz(szBuffer); *sz; ++sz, ++i)\n        {\n            if (i == iDec && precision > 0)\n                sStr += '.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    char padchar(' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((precision > 0) ? 1 : 0) - precision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = '0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        string padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == '0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\nvoid    FormatFloat(double d, int flags, size_t width, int precision, wstring &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!precision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);\n        return;\n    }\n#endif\n    if (_isnan(d))\n    {\n        sStr += L\"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += L\"#INF\";\n        return;\n    }\n\n    // Determine sign character\n    wchar_t sign(0);\n    if (d < 0)\n    {\n        sign = L'-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = L'+';\n        else if (flags & FMT_PADSIGN)\n            sign = L' ';\n    }\n\n    char szBuffer[256];\n    wchar_t szBufferW[256];\n    int iDec;\n    int iSign;\n\n#ifdef _WIN32\n    _fcvt_s(szBuffer, 256, d, precision, &iDec, &iSign);\n#else\n    strncpy(szBuffer, fcvt(d, precision, &iDec, &iSign), 256);\n#endif\n    SingleToWide(szBufferW, szBuffer, 256);\n\n    // Set up Delimeter\n    int dspacing(0);\n    wchar_t dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = L',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -precision)\n            iDec = -precision;\n\n        sStr += L'0';\n        if (precision > 0)\n            sStr += L'.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += L'0';\n        for (wchar_t *sz(szBufferW); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)\n        {\n            if (i == iDec && precision > 0)\n                sStr += L'.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    wchar_t padchar(L' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((precision > 0) ? 1 : 0) - precision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = L'0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        wstring padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == L'0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\nvoid    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, string &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!iMaxPrecision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? '-' : 0), sStr);\n        return;\n    }\n#endif\n    // Determine sign character\n    char sign(0);\n    if (d < 0)\n    {\n        sign = '-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = '+';\n        else if (flags & FMT_PADSIGN)\n            sign = ' ';\n    }\n\n    if (_isnan(d))\n    {\n        sStr += \"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += \"#INF\";\n        return;\n    }\n\n    char szBuffer[256];\n    int iDec;\n    int iSign;\n\n#ifdef _WIN32\n    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);\n#else\n    strncpy(szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);\n#endif\n\n    int iLength(int(strlen(szBuffer)));\n\n    // Trim trailing zeros up to min precision\n    while (iLength > iDec && szBuffer[iLength - 1] == '0' && iMaxPrecision > iMinPrecision)\n    {\n        --iLength;\n        --iMaxPrecision;\n    }\n\n    szBuffer[iLength] = '\\0';\n\n    // Set up Delimeter\n    int dspacing(0);\n    char dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = ',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -iMaxPrecision)\n            iDec = -iMaxPrecision;\n\n        sStr += '0';\n        if (iMaxPrecision > 0)\n            sStr += '.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += '0';\n        for (char *sz(szBuffer); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (char *sz(szBuffer); *sz; ++sz, ++i)\n        {\n            if (i == iDec && iMaxPrecision > 0)\n                sStr += '.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    char padchar(' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = '0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        string padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == '0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\nvoid    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, wstring &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!iMaxPrecision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);\n        return;\n    }\n#endif\n    // Determine sign character\n    wchar_t sign(0);\n    if (d < 0)\n    {\n        sign = L'-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = L'+';\n        else if (flags & FMT_PADSIGN)\n            sign = L' ';\n    }\n\n    if (_isnan(d))\n    {\n        sStr += L\"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += L\"#INF\";\n        return;\n    }\n\n    char szBuffer[256];\n    wchar_t szBufferW[256];\n    int iDec;\n    int iSign;\n\n#ifdef _WIN32\n    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);\n#else\n    strncpy((char*)szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);\n#endif\n    SingleToWide(szBufferW, szBuffer, 256);\n\n    int iLength(int(wcslen(szBufferW)));\n\n    // Trim trailing zeros up to min precision\n    while (iLength > iDec && szBufferW[iLength - 1] == L'0' && iMaxPrecision > iMinPrecision)\n    {\n        --iLength;\n        --iMaxPrecision;\n    }\n\n    szBufferW[iLength] = L'\\0';\n\n    // Set up Delimeter\n    int dspacing(0);\n    wchar_t dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = L',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -iMaxPrecision)\n            iDec = -iMaxPrecision;\n\n        sStr += L'0';\n        if (iMaxPrecision > 0)\n            sStr += L'.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += L'0';\n        for (wchar_t *sz(szBufferW); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)\n        {\n            if (i == iDec && iMaxPrecision > 0)\n                sStr += L'.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    wchar_t padchar(L' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = L'0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        wstring padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == L'0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\n\n/*====================\n  XtoA\n ====================*/\nwstring XtoW(const CVec2f &vec, int flags, int width, int precision)\n{\n    wstring sX, sY;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n\n    wstring str(sX + L\" \" + sY);\n\n    return XtoW(str, flags, width);\n}\n\nwstring XtoW(const CVec3f &vec, int flags, int width, int precision)\n{\n    wstring sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    wstring str(sX + L\" \" + sY + L\" \" + sZ);\n\n    return XtoW(str, flags, width);\n}\n\nwstring XtoW(const CVec3<double> &vec, int flags, int width, int precision)\n{\n    wstring sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    wstring str(sX + L\" \" + sY + L\" \" + sZ);\n\n    return XtoW(str, flags, width);\n}\n\nwstring XtoW(const CVec4f &v4, int flags, int width, int precision)\n{\n    wstring sX, sY, sZ, sW;\n\n    FormatFloat(v4.x, flags, 0, precision, sX);\n    FormatFloat(v4.y, flags, 0, precision, sY);\n    FormatFloat(v4.z, flags, 0, precision, sZ);\n    FormatFloat(v4.w, flags, 0, precision, sW);\n\n    wstring str(sX + L\" \" + sY + L\" \" + sZ + L\" \" + sW);\n\n    return XtoW(str, flags, width);\n}\n\nstring  XtoS(const CVec2f &vec, int flags, int width, int precision)\n{\n    string sX, sY;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n\n    string str(sX + \" \" + sY);\n\n    return XtoS(str, flags, width);\n}\n\nstring  XtoS(const CVec3f &vec, int flags, int width, int precision)\n{\n    string sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    string str(sX + \" \" + sY + \" \" + sZ);\n\n    return XtoS(str, flags, width);\n}\n\nstring  XtoS(const CVec3<double> &vec, int flags, int width, int precision)\n{\n    string sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    string str(sX + \" \" + sY + \" \" + sZ);\n\n    return XtoS(str, flags, width);\n}\n\nstring  XtoS(const CVec4f &v4, int flags, int width, int precision)\n{\n    string sX, sY, sZ, sW;\n\n    FormatFloat(v4.x, flags, 0, precision, sX);\n    FormatFloat(v4.y, flags, 0, precision, sY);\n    FormatFloat(v4.z, flags, 0, precision, sZ);\n    FormatFloat(v4.w, flags, 0, precision, sW);\n\n    string str(sX + \" \" + sY + \" \" + sZ + \" \" + sW);\n\n    return XtoS(str, flags, width);\n}\n\nwstring XtoW(const wstring &s, int flags, size_t width)\n{\n    if (s.length() >= width)\n        return s;\n\n    if (flags & FMT_ALIGNLEFT)\n        return s + wstring(width - s.length(), L' ');\n    else\n        return wstring(width - s.length(), L' ') + s;\n}\n\nstring XtoS(const string &s, int flags, size_t width)\n{\n    if (s.length() >= width)\n        return s;\n\n    if (flags & FMT_ALIGNLEFT)\n        return s + string(width - s.length(), ' ');\n    else\n        return string(width - s.length(), ' ') + s;\n}\n\n\n/*====================\n  AtoX\n ====================*/\nCVec2f& AtoX(const tstring &s, CVec2f &v2)\n{\n    const tsvector &vComponents = TokenizeString(s, _T(' '));\n    float   x, y;\n    if (vComponents.size() < 2)\n    {\n        x = y = 0.0f;\n    }\n    else\n    {\n        AtoX(vComponents[0], x);\n        AtoX(vComponents[1], y);\n    }\n    v2.Set(x, y);\n    return v2;\n}\n\nCVec3f& AtoX(const tstring &s, CVec3f &v3)\n{\n    const tsvector &vComponents = TokenizeString(s, _T(' '));\n    float   x, y, z;\n    if (vComponents.size() < 3)\n    {\n        x = y = z = 0.0f;\n    }\n    else\n    {\n        AtoX(vComponents[0], x);\n        AtoX(vComponents[1], y);\n        AtoX(vComponents[2], z);\n    }\n    v3.Set(x, y, z);\n    return v3;\n}\n\nCVec4f& AtoX(const tstring &s, CVec4f &v4)\n{\n    const tsvector &vComponents = TokenizeString(s, _T(' '));\n    float   x, y, z, w;\n    if (vComponents.size() < 4)\n    {\n        x = y = z = w = 0.0f;\n    }\n    else\n    {\n        AtoX(vComponents[0], x);\n        AtoX(vComponents[1], y);\n        AtoX(vComponents[2], z);\n        AtoX(vComponents[3], w);\n    }\n    v4.Set(x, y, z, w);\n    return v4;\n}\n\n\n/*====================\n  AtoV2\n ====================*/\nK2_API CVec2f   AtoV2(const tstring &s)\n{\n    CVec2f vRet;\n\n    _STSCANF_S_BEGIN(s.c_str(), _T(\"%f %f\"))\n        &vRet.x, &vRet.y\n    _STSCANF_S_END;\n\n    return vRet;\n}\n\n\n/*====================\n  AtoV3\n ====================*/\nK2_API CVec3f   AtoV3(const tstring &s)\n{\n    CVec3f vRet;\n\n    int iFields(_STSCANF_S_BEGIN(s.c_str(), _T(\"%f %f %f\"))\n        &vRet.x, &vRet.y, &vRet.z\n    _STSCANF_S_END);\n\n    if (iFields == 1)\n        vRet.z = vRet.y = vRet.x;\n\n    return vRet;\n}\n\n\n/*====================\n  AtoV4\n ====================*/\nCVec4f  AtoV4(const tstring &s)\n{\n    CVec4f vRet;\n\n    _STSCANF_S_BEGIN(s.c_str(), _T(\"%f %f %f %f\"))\n        &vRet.x, &vRet.y, &vRet.z, &vRet.w\n    _STSCANF_S_END;\n\n    return vRet;\n}\n\n\n/*====================\n  PtoI\n  ====================*/\nint     PtoI(const tstring &s)\n{\n    if (s[s.length() - 1] != _T('%'))\n        return 0;\n\n    int iRet(AtoI(s.substr(0, s.length() - 1)));\n    CLAMP(iRet, 0, 100);\n    return iRet;\n}\n\n\n/*====================\n  PtoF\n  ====================*/\nfloat   PtoF(const tstring &s)\n{\n    if (s[s.length() - 1] != _T('%'))\n        return 0.0f;\n\n    float fRet(AtoF(s.substr(0, s.length() - 1)));\n    return fRet;\n}\n\n\n/*====================\n  P2toF\n  ====================*/\nfloat   P2toF(const tstring &s)\n{\n    if (s[s.length() - 1] != _T('@'))\n        return 0.0f;\n\n    float fRet(AtoF(s.substr(0, s.length() - 1)));\n    return fRet;\n}\n\n\n/*====================\n  BytesToHexString\n  ====================*/\ntstring         BytesToHexString(const byte* pData, size_t uiLen)\n{\n    // https://stackoverflow.com/questions/14050452/how-to-convert-byte-array-to-hex-string-in-visual-c\n    std::stringstream ss;\n    ss << std::hex;\n\n    for( size_t i(0) ; i < uiLen; ++i ) {\n        ss << std::setw(2) << std::setfill('0') << (int)pData[i];\n    }\n\n    return StringToTString(ss.str());\n}\n\n/*====================\n  HexStringToBytes\n  ====================*/\nvector<byte>    HexStringToBytes(const tstring& sData)\n{\n    // https://stackoverflow.com/questions/17261798/converting-a-hex-string-to-a-byte-array\n    std::stringstream ss;\n    ss << TStringToUTF8(sData);\n\n    std::vector<byte> resBytes;\n    size_t count = 0;\n    const auto len = sData.size();\n    while(ss.good() && count < len)\n    {\n        unsigned short num;\n        char hexNum[2];\n        ss.read(hexNum, 2);\n        sscanf(hexNum, \"%2hX\", &num);\n        assert(num >= 0 && num <= 255);\n        resBytes.push_back(static_cast<byte>(num));\n        count += 2;\n    }\n    return resBytes;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/xtoa.cpp b/src/k2/xtoa.cpp
--- a/src/k2/xtoa.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/xtoa.cpp	(date 1684984580811)
@@ -280,6 +280,144 @@
 }
 
 
+void    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, wstring &sStr)
+{
+#if defined(__APPLE__)
+    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way
+    if (iMaxPrecision <= 0)
+    {
+        FormatInt(ULONGLONG(d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
+        return;
+    }
+#endif
+    // Determine sign character
+    wchar_t sign(0);
+    if (d < 0)
+    {
+        sign = L'-';
+    }
+    else
+    {
+        if (flags & FMT_SIGN)
+            sign = L'+';
+        else if (flags & FMT_PADSIGN)
+            sign = L' ';
+    }
+
+    if (_isnan(d))
+    {
+        sStr += L"#NAN";
+        return;
+    }
+
+    if (!_finite(d))
+    {
+        sStr += L"#INF";
+        return;
+    }
+
+    char szBuffer[256];
+    wchar_t szBufferW[256];
+    int iDec;
+    int iSign;
+
+#ifdef _WIN32
+    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);
+#else
+    strncpy((char*)szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);
+#endif
+    SingleToWide(szBufferW, szBuffer, 256);
+
+    int iLength(int(wcslen(szBufferW)));
+
+    // Trim trailing zeros up to min precision
+    while (iLength > iDec && szBufferW[iLength - 1] == L'0' && iMaxPrecision > iMinPrecision)
+    {
+        --iLength;
+        --iMaxPrecision;
+    }
+
+    szBufferW[iLength] = L'\0';
+
+    // Set up Delimeter
+    int dspacing(0);
+    wchar_t dchar(0);
+    if (flags & FMT_DELIMIT)
+    {
+        dchar = L',';
+        dspacing = 3;
+    }
+
+    // Build the string of digits
+    if (iDec <= 0)
+    {
+        if (iDec < -iMaxPrecision)
+            iDec = -iMaxPrecision;
+
+        sStr += L'0';
+        if (iMaxPrecision > 0)
+            sStr += L'.';
+        for (int i(iDec); i < 0; ++i)
+            sStr += L'0';
+        for (wchar_t *sz(szBufferW); *sz; ++sz)
+            sStr += *sz;
+    }
+    else
+    {
+        int i(0);
+
+        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)
+        {
+            if (i == iDec && iMaxPrecision > 0)
+                sStr += L'.';
+            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)
+                sStr += dchar;
+            sStr += *sz;
+        }
+    }
+
+    // Create padding
+    wchar_t padchar(L' ');
+    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);
+    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))
+        padchar = L'0';
+    if (padcount < 0)
+        padcount = 0;
+
+    // Assemble the parts
+    if (padcount > 0)
+    {
+        wstring padding(padcount, padchar);
+
+        if (sign != 0)
+        {
+            if (flags & FMT_ALIGNLEFT)
+            {
+                sStr = sign + sStr + padding;
+            }
+            else
+            {
+                if (padchar == L'0')
+                    sStr = sign + padding + sStr;
+                else
+                    sStr = padding + sign + sStr;
+            }
+        }
+        else
+        {
+            if (flags & FMT_ALIGNLEFT)
+                sStr = sStr + padding;
+            else
+                sStr = padding + sStr;
+        }
+    }
+    else
+    {
+        if (sign != 0)
+            sStr = sign + sStr;
+    }
+}
+
 /*====================
   FormatFloat
  ====================*/
@@ -414,7 +552,7 @@
     // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way
     if (!precision)
     {
-        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
+        FormatInt(ULONGLONG(d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
         return;
     }
 #endif
@@ -670,144 +808,6 @@
             sStr = sign + sStr;
     }
 }
-
-void    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, wstring &sStr)
-{
-#if defined(__APPLE__)
-    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way
-    if (!iMaxPrecision)
-    {
-        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
-        return;
-    }
-#endif
-    // Determine sign character
-    wchar_t sign(0);
-    if (d < 0)
-    {
-        sign = L'-';
-    }
-    else
-    {
-        if (flags & FMT_SIGN)
-            sign = L'+';
-        else if (flags & FMT_PADSIGN)
-            sign = L' ';
-    }
-
-    if (_isnan(d))
-    {
-        sStr += L"#NAN";
-        return;
-    }
-
-    if (!_finite(d))
-    {
-        sStr += L"#INF";
-        return;
-    }
-
-    char szBuffer[256];
-    wchar_t szBufferW[256];
-    int iDec;
-    int iSign;
-
-#ifdef _WIN32
-    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);
-#else
-    strncpy((char*)szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);
-#endif
-    SingleToWide(szBufferW, szBuffer, 256);
-
-    int iLength(int(wcslen(szBufferW)));
-
-    // Trim trailing zeros up to min precision
-    while (iLength > iDec && szBufferW[iLength - 1] == L'0' && iMaxPrecision > iMinPrecision)
-    {
-        --iLength;
-        --iMaxPrecision;
-    }
-
-    szBufferW[iLength] = L'\0';
-
-    // Set up Delimeter
-    int dspacing(0);
-    wchar_t dchar(0);
-    if (flags & FMT_DELIMIT)
-    {
-        dchar = L',';
-        dspacing = 3;
-    }
-
-    // Build the string of digits
-    if (iDec <= 0)
-    {
-        if (iDec < -iMaxPrecision)
-            iDec = -iMaxPrecision;
-
-        sStr += L'0';
-        if (iMaxPrecision > 0)
-            sStr += L'.';
-        for (int i(iDec); i < 0; ++i)
-            sStr += L'0';
-        for (wchar_t *sz(szBufferW); *sz; ++sz)
-            sStr += *sz;
-    }
-    else
-    {
-        int i(0);
-
-        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)
-        {
-            if (i == iDec && iMaxPrecision > 0)
-                sStr += L'.';
-            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)
-                sStr += dchar;
-            sStr += *sz;
-        }
-    }
-
-    // Create padding
-    wchar_t padchar(L' ');
-    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);
-    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))
-        padchar = L'0';
-    if (padcount < 0)
-        padcount = 0;
-
-    // Assemble the parts
-    if (padcount > 0)
-    {
-        wstring padding(padcount, padchar);
-
-        if (sign != 0)
-        {
-            if (flags & FMT_ALIGNLEFT)
-            {
-                sStr = sign + sStr + padding;
-            }
-            else
-            {
-                if (padchar == L'0')
-                    sStr = sign + padding + sStr;
-                else
-                    sStr = padding + sign + sStr;
-            }
-        }
-        else
-        {
-            if (flags & FMT_ALIGNLEFT)
-                sStr = sStr + padding;
-            else
-                sStr = padding + sStr;
-        }
-    }
-    else
-    {
-        if (sign != 0)
-            sStr = sign + sStr;
-    }
-}
 
 
 /*====================
Index: src/k2/c_anim.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_anim.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_anim.h\"\n#include \"c_skeleton.h\"\n#include \"c_k2model.h\"\n#include \"c_clip.h\"\n#include \"c_model.h\"\n#include \"c_resourcemanager.h\"\n//=============================================================================\n\n/*====================\n  CAnim::~CAnim\n  ====================*/\nCAnim::~CAnim()\n{\n    K2_DELETE_ARRAY(m_ppMotions);\n\n    g_ResourceManager.RemoveResourceWatcher(this, m_hClip);\n}\n\n\n/*====================\n  CAnim::CAnim\n  ====================*/\nCAnim::CAnim\n(\n    CK2Model *pModel,\n    uint uiIndex,\n    const tstring &sName,\n    const tstring &sClip,\n    int iStartFrame,\n    int iNumFrames,\n    int iLoopbackFrame,\n    bool bLoop,\n    float fFps,\n    int iNumLoopFrames,\n    int iBlendTime,\n    bool bLock,\n    int iMinStartFrame,\n    int iMaxStartFrame,\n    uint uiIgnoreFlags\n) :\nIResourceWatcher(),\nm_uiIndex(uiIndex),\nm_sName(sName),\nm_ppMotions(nullptr),\nm_iStartFrame(iStartFrame),\nm_iNumFrames(iNumFrames),\nm_iLoopbackFrame(iLoopbackFrame),\nm_bLoop(bLoop),\nm_fFps(fFps),\nm_iMSperFrame(MAX(INT_FLOOR(1000.0f / fFps), 1)),\nm_iNumLoopFrames(iNumLoopFrames),\nm_uiBlendTime(iBlendTime),\nm_bLock(bLock),\nm_iMinStartFrame(iMinStartFrame),\nm_iMaxStartFrame(iMaxStartFrame),\nm_pModel(pModel),\nm_iStartFrameDef(iStartFrame),\nm_iNumFramesDef(iNumFrames),\nm_iLoopbackFrameDef(iLoopbackFrame),\nm_iMinStartFrameDef(iMinStartFrame),\nm_iMaxStartFrameDef(iMaxStartFrame)\n{\n    m_hClip = g_ResourceManager.Register(sClip, RES_CLIP, uiIgnoreFlags);\n\n    g_ResourceManager.AddResourceWatcher(this, m_hClip);\n\n    Rebuild(m_hClip);\n}\n\n\n/*====================\n  CAnim::CheckEvents\n\n  Check for events in the range [time0, time1)\n  ====================*/\nvoid    CAnim::CheckEvents(CSkeleton *pSkeleton, int iTime0, int iTime1, int iChannel)\n{\n    if (m_vFrameEvents.empty() || iTime0 >= iTime1)\n        return;\n\n    if (m_bLoop)\n    {\n        int iLoopTime(m_iNumFrames * m_iMSperFrame);\n        int iLoopLength(m_iNumLoopFrames * m_iMSperFrame);\n\n        int iStartLoop(MAX((iTime0 - iLoopTime < 0) ? 0 : (iTime0 - iLoopTime) / iLoopLength + 1, 0));\n        int iEndLoop(MAX((iTime1 - iLoopTime < 0) ? 1 : (iTime1 - iLoopTime) / iLoopLength + 2, 0));\n\n        if (iEndLoop - iStartLoop > 2)\n        {\n            iStartLoop = iEndLoop - 2;\n            //Console.Warn << \"Large number of loops in CAnim::CheckEvents\" << newl;\n        }\n\n        for (int iLoop(iStartLoop); iLoop < iEndLoop; ++iLoop)\n        {\n            if (iLoop == 0)\n            {\n                for (vector<SAnimEvent>::iterator it(m_vFrameEvents.begin()); it != m_vFrameEvents.end(); ++it)\n                {\n                    int iFrameTime(it->iFrame * m_iMSperFrame);\n\n                    if (iFrameTime >= iTime0 && iFrameTime < iTime1)\n                        pSkeleton->AddEvent(it->sCommand, iFrameTime - iTime1);\n                }\n            }\n            else\n            {\n                // Calculate time0 and time1 relative to the current loop\n                int iLocalTime0((iTime0 - iLoopTime) - iLoopLength * (iLoop - 1));\n                int iLocalTime1((iTime1 - iLoopTime) - iLoopLength * (iLoop - 1));\n\n                for (vector<SAnimEvent>::iterator it(m_vFrameEvents.begin()); it != m_vFrameEvents.end(); ++it)\n                {\n                    if (it->iFrame < (m_iLoopbackFrame - m_iStartFrame))\n                        continue;\n\n                    int iFrameTime((it->iFrame - (m_iLoopbackFrame - m_iStartFrame)) * m_iMSperFrame);\n\n                    if (iFrameTime >= iLocalTime0 && iFrameTime < iLocalTime1)\n                        pSkeleton->AddEvent(it->sCommand, iFrameTime - iLocalTime1);\n                }\n            }\n        }\n    }\n    else\n    {\n        for (vector<SAnimEvent>::iterator it(m_vFrameEvents.begin()); it != m_vFrameEvents.end(); ++it)\n        {\n            int iFrameTime(it->iFrame * m_iMSperFrame);\n\n            if (iFrameTime >= iTime0 && iFrameTime < iTime1)\n                pSkeleton->AddEvent(it->sCommand, iFrameTime - iTime1);\n        }\n    }\n}\n\n\n/*====================\n  CAnim::AddFrameEvent\n  ====================*/\nvoid    CAnim::AddFrameEvent(int iFrame, const tstring &sCommand)\n{\n    m_vFrameEvents.push_back(SAnimEvent(iFrame, sCommand));\n}\n\n\n/*====================\n  CAnim::AddStartEvent\n  ====================*/\nvoid    CAnim::AddStartEvent(const tstring &sCommand)\n{\n    m_vStartEvents.push_back(sCommand);\n}\n\n\n/*====================\n  CAnim::AddEndEvent\n  ====================*/\nvoid    CAnim::AddEndEvent(const tstring &sCommand)\n{\n    m_vEndEvents.push_back(sCommand);\n}\n\n\n/*====================\n  CAnim::Rebuild\n  ====================*/\nvoid    CAnim::Rebuild(ResHandle hResource)\n{\n    PROFILE(\"CAnim::Rebuild\");\n\n    if (m_ppMotions)\n    {\n        K2_DELETE_ARRAY(m_ppMotions);\n        m_ppMotions = nullptr;\n    }\n\n    m_iStartFrame = m_iStartFrameDef;\n    m_iNumFrames = m_iNumFramesDef;\n    m_iLoopbackFrame = m_iLoopbackFrameDef;\n    m_iMinStartFrame = m_iMinStartFrameDef;\n    m_iMaxStartFrame = m_iMaxStartFrameDef;\n\n    // Set up pointers to bone motions\n    if (m_pModel->GetNumBones() > 0)\n        m_ppMotions = K2_NEW_ARRAY(ctx_Models,  SBoneMotion*, m_pModel->GetNumBones());\n\n    CClip *pClip(g_ResourceManager.GetClip(m_hClip));\n    if (pClip == nullptr)\n    {\n        for (uint n(0); n < m_pModel->GetNumBones(); ++n)\n            m_ppMotions[n] = nullptr;\n\n        // Fix up the frames\n        m_iStartFrame = 0;\n        m_iNumFrames = 1;\n        return;\n    }\n\n    for (uint n(0); n < m_pModel->GetNumBones(); ++n)\n        m_ppMotions[n] = nullptr;\n\n    for (int i = 0; i < pClip->GetNumMotions(); ++i)\n    {\n        // Assign the bone to this motion\n        uint uiBone(m_pModel->GetBoneIndex(pClip->GetBoneMotion(i)->sBoneName));\n\n        if (uiBone != INVALID_BONE)\n            m_ppMotions[uiBone] = pClip->GetBoneMotion(i);\n    }\n\n    // Fix up the frames\n    if (m_iStartFrame == 0 && m_iNumFrames == 0)\n        m_iNumFrames = pClip->GetNumFrames();\n    else if (m_iNumFrames == -1)\n        m_iNumFrames = pClip->GetNumFrames() - m_iStartFrame;\n    else if (m_iStartFrame + m_iNumFrames > pClip->GetNumFrames())\n        m_iNumFrames = pClip->GetNumFrames() - m_iStartFrame;\n    \n    if (m_iNumFrames <= 0)\n        m_iNumFrames = 1;\n\n    if (m_bLoop)\n    {\n        if (m_iLoopbackFrame == -1)\n            m_iLoopbackFrame = m_iStartFrame + m_iNumFrames - 1;\n\n        m_iLoopbackFrame = CLAMP(m_iLoopbackFrame, m_iStartFrame, m_iStartFrame + m_iNumFrames - 1);\n        m_iNumLoopFrames = m_iStartFrame + m_iNumFrames - m_iLoopbackFrame;\n    }\n\n    if (m_iMinStartFrame == -1)\n        m_iMinStartFrame = m_iStartFrame + m_iNumFrames - 1;\n\n    m_iMinStartFrame = CLAMP(m_iMinStartFrame, m_iStartFrame, m_iStartFrame + m_iNumFrames - 1);\n\n    if (m_iMaxStartFrame == -1)\n        m_iMaxStartFrame = m_iStartFrame + m_iNumFrames - 1;\n\n    m_iMaxStartFrame = CLAMP(m_iMaxStartFrame, m_iMinStartFrame, m_iStartFrame + m_iNumFrames - 1);\n}\n\n\n/*====================\n  CAnim::ComputeAnimFrame\n\n  computes loframe, hiframe, and lerp amounts based on a CAnim structure and a given time\n  non looping animations will freeze on their last frame\n  looping animations will loop back to the loopbackframe specified in the anim struct\n  time is specified in milliseconds\n  ====================*/\nbool    CAnim::ComputeAnimFrame(int iTime, int &iLoFrame, int &iHiFrame, float &fLerpAmt, uint uiForceLength)\n{\n    int iMsPerFrame(m_iMSperFrame);\n    if (uiForceLength != 0)\n        iMsPerFrame = uiForceLength / m_iNumFrames;\n    if (iMsPerFrame == 0)\n        iMsPerFrame = 1;\n\n    if (iTime < 0)\n    {\n        iLoFrame = 0;\n        iHiFrame = 1;\n        fLerpAmt = 0.0f;\n\n        return true;\n    }\n\n    int iFrame(iTime / iMsPerFrame);\n\n    if (iFrame >= m_iNumFrames - 1)\n    {\n        if (!m_bLoop)\n        {\n            iLoFrame = m_iStartFrame + m_iNumFrames - 1;\n            iHiFrame = m_iStartFrame + m_iNumFrames - 1;\n            fLerpAmt = 0.0f;\n            return false;\n        }\n        else\n        {\n            iLoFrame = ((iFrame - (m_iLoopbackFrame - m_iStartFrame)) % m_iNumLoopFrames) + m_iLoopbackFrame;\n            iHiFrame = ((iFrame - (m_iLoopbackFrame - m_iStartFrame) + 1) % m_iNumLoopFrames) + m_iLoopbackFrame;\n\n            int iTimeLo(iFrame * iMsPerFrame);\n            fLerpAmt = (iTime - iTimeLo) / float(iMsPerFrame);\n\n            return true;\n        }\n    }\n\n    iLoFrame = (iFrame % m_iNumFrames) + m_iStartFrame;\n    iHiFrame = ((iFrame + 1) % m_iNumFrames) + m_iStartFrame;\n\n    int iTimeLo(iFrame * iMsPerFrame);\n    fLerpAmt = (iTime - iTimeLo) / float(iMsPerFrame);\n\n    return true;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_anim.cpp b/src/k2/c_anim.cpp
--- a/src/k2/c_anim.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_anim.cpp	(date 1684975201827)
@@ -9,6 +9,8 @@
 #include "k2_common.h"
 
 #include "c_anim.h"
+
+#include <utility>
 #include "c_skeleton.h"
 #include "c_k2model.h"
 #include "c_clip.h"
@@ -22,8 +24,6 @@
 CAnim::~CAnim()
 {
     K2_DELETE_ARRAY(m_ppMotions);
-
-    g_ResourceManager.RemoveResourceWatcher(this, m_hClip);
 }
 
 
@@ -34,7 +34,7 @@
 (
     CK2Model *pModel,
     uint uiIndex,
-    const tstring &sName,
+    tstring sName,
     const tstring &sClip,
     int iStartFrame,
     int iNumFrames,
@@ -50,7 +50,7 @@
 ) :
 IResourceWatcher(),
 m_uiIndex(uiIndex),
-m_sName(sName),
+m_sName(std::move(sName)),
 m_ppMotions(nullptr),
 m_iStartFrame(iStartFrame),
 m_iNumFrames(iNumFrames),
@@ -74,7 +74,7 @@
 
     g_ResourceManager.AddResourceWatcher(this, m_hClip);
 
-    Rebuild(m_hClip);
+    CAnim::Rebuild(m_hClip);
 }
 
 
Index: src/k2/c_effectthread.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2006 S2 Games\n// c_effectthread.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_effectthread.h\"\n#include \"i_effectcmd.h\"\n#include \"c_particlesystem.h\"\n#include \"c_effect.h\"\n#include \"c_skeleton.h\"\n#include \"c_model.h\"\n#include \"c_k2model.h\"\n#include \"c_mesh.h\"\n#include \"c_camera.h\"\n#include \"c_resourcemanager.h\"\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nCVAR_INTF   (efx_activeThreads,     0,      CVAR_READONLY | CVAR_DONTSAVE);\n//=============================================================================\n\n\n/*====================\n  CEffectThread::~CEffectThread\n  ====================*/\nCEffectThread::~CEffectThread()\n{\n    for (InstanceMap::iterator itInstance(m_mapInstances.begin()); itInstance != m_mapInstances.end(); ++itInstance)\n        K2_DELETE(itInstance->second);\n\n    // m_vCmdBuffer is only populated in the effect thread definition instance\n    for (EffectCmdBuffer::iterator itCmd(m_vCmdBuffer.begin()); itCmd != m_vCmdBuffer.end(); ++itCmd)\n        K2_DELETE(*itCmd);\n\n    g_ResourceManager.RemoveResourceWatcher(this, m_hEffect);\n\n    if (m_uiStartTime != 0xffffffff)\n        --efx_activeThreads;\n}\n\n\n/*====================\n  CEffectThread::CEffectThread\n\n  Allocated effect thread definition\n  ====================*/\nCEffectThread::CEffectThread(CEffect *pEffect) :\nm_pEffect(pEffect),\nm_hEffect(INVALID_RESOURCE),\nm_uiStartTime(0xffffffff),\nm_pvCmdBuffer(&m_vCmdBuffer),\nm_pSourceSkeleton(nullptr),\nm_pTargetSkeleton(nullptr)\n{\n    /*      DO NOT DO THIS -- the pEffect OWNS us, we are not dependent on it! \n    m_pEffect->AddResourceWatcher(this);\n    */\n\n    m_itCurrentCmd = m_vCmdBuffer.end();\n}\n\n\n/*====================\n  CEffectThread::CEffectThread\n  ====================*/\nCEffectThread::CEffectThread(uint uiStartTime, const CEffectThread &etSettings) :\nm_pEffect(etSettings.m_pEffect),\nm_hEffect(etSettings.m_pEffect->GetHandle()),\nm_uiStartTime(uiStartTime),\nm_uiLastUpdateTime(INVALID_TIME),\nm_uiWaitTime(0),\nm_pvCmdBuffer(&etSettings.m_vCmdBuffer),\nm_itStartCmd(etSettings.m_itCurrentCmd),\nm_itCurrentCmd(etSettings.m_itCurrentCmd),\n\nm_bActive(false),\nm_bExpire(false),\n\nm_pCamera(nullptr),\nm_v3CameraOffset(V3_ZERO),\nm_v3CameraAngleOffset(V3_ZERO),\n\nm_uiCameraShakeTime(0),\nm_uiCameraShakeDuration(0),\nm_fCameraShakeFrequency(0.0f),\nm_v3CameraShake(V3_ZERO),\n\nm_uiCameraKickTime(INVALID_TIME),\nm_fCameraKickHalfLife(0.0f),\nm_v3CameraKickAngles(V3_ZERO),\nm_v3CameraKickPosition(V3_ZERO),\n\nm_bActiveOverlay(false),\nm_uiOverlayStartTime(0),\nm_uiOverlayDuration(0),\nm_v4OverlayColor(V4_ZERO),\nm_hOverlayMaterial(INVALID_RESOURCE),\n\nm_pSourceSkeleton(nullptr),\nm_pSourceModel(nullptr),\nm_v3SourcePos(CVec3f(0.0f, 0.0f, 0.0f)),\nm_aSourceAxis(),\nm_fSourceScale(1.0f),\nm_fSourceEffectScale(1.0f),\nm_bSourceVisibility(true),\n\nm_pTargetSkeleton(nullptr),\nm_pTargetModel(nullptr),\nm_v3TargetPos(CVec3f(0.0f, 0.0f, 0.0f)),\nm_aTargetAxis(),\nm_fTargetScale(1.0f),\nm_fTargetEffectScale(1.0f),\nm_bTargetVisibility(true),\nm_bCustomVisibility(true),\n\nm_v3Color(1.0f, 1.0f, 1.0f)\n{\n    g_ResourceManager.AddResourceWatcher(this, m_hEffect);\n\n    ++efx_activeThreads;\n}\n\n\n/*====================\n  CEffectThread::Rebuild\n  ====================*/\nvoid    CEffectThread::Rebuild(ResHandle hResource)\n{\n    for (InstanceMap::iterator it(m_mapInstances.begin()); it != m_mapInstances.end(); ++it)\n        K2_DELETE(it->second);\n\n    m_mapInstances.clear();\n\n    assert(m_hEffect != INVALID_RESOURCE);\n    if (m_hEffect != INVALID_RESOURCE)\n        m_hEffect = hResource;\n\n    m_pEffect = g_ResourceManager.GetEffect(hResource);\n\n    if (!m_pEffect || !m_pEffect->GetEffectThread())\n    {\n        m_pvCmdBuffer = nullptr;\n        return;\n    }\n\n    const CEffectThread &etSettings(*m_pEffect->GetEffectThread());\n\n    m_pvCmdBuffer = &etSettings.m_vCmdBuffer;\n    m_itCurrentCmd = etSettings.m_itCurrentCmd;\n}\n\n\n/*====================\n  CEffectThread::AddCmd\n  ====================*/\nvoid    CEffectThread::AddCmd(IEffectCmd *pCmd)\n{\n    m_vCmdBuffer.push_back(pCmd);\n    m_itCurrentCmd = m_vCmdBuffer.begin();\n}\n\n\n/*====================\n  CEffectThread::Execute\n\n  true is returned if the thread finishes, otherwise false (on a pause or such)\n  ====================*/\nbool    CEffectThread::Execute(uint uiMilliseconds)\n{\n    if (!m_pvCmdBuffer)\n    {\n        // if the effect has been unregistered, then pause until it's been reloaded.\n        if (m_hEffect != INVALID_RESOURCE && g_ResourceManager.Get(m_hEffect) == nullptr)\n            return false;\n\n        return true;\n    }\n\n    if (m_uiLastUpdateTime == INVALID_TIME)\n    {\n        if (uiMilliseconds < m_uiStartTime)\n            return false;\n        else\n            m_uiLastUpdateTime = uiMilliseconds;\n    }\n\n    if (uiMilliseconds < m_uiLastUpdateTime)\n    {\n        if (GetEffect() != nullptr)\n            Console.Dev << _T(\"Rewinding effect \") << GetEffect()->GetPath() << _T(\" to \") << uiMilliseconds << _T(\" milliseconds\") << newl;\n        else\n            Console.Dev << _T(\"Rewinding unknown effect to \") << uiMilliseconds << _T(\" milliseconds\") << newl;\n\n        if (Rewind(uiMilliseconds))\n            return true;\n    }\n\n    uint uiDeltaTime(uiMilliseconds > m_uiLastUpdateTime ? uiMilliseconds - m_uiLastUpdateTime : 0);\n\n    if (m_uiWaitTime > 0)\n    {\n        if (uiDeltaTime > m_uiWaitTime)\n        {\n            uiDeltaTime -= m_uiWaitTime;\n            m_uiWaitTime = 0;\n        }\n        else if (uiDeltaTime > 0)\n        {\n            m_uiWaitTime -= uiDeltaTime;\n        }\n    }\n\n    if (m_uiWaitTime == 0)\n    {\n        if (m_itCurrentCmd == m_pvCmdBuffer->end())\n            return true;\n\n        while (m_itCurrentCmd != m_pvCmdBuffer->end() && (*m_itCurrentCmd)->Execute(this, uiMilliseconds))\n        {\n            ++m_itCurrentCmd;\n\n            if (m_uiWaitTime > 0)\n                break;\n        }\n    }\n\n    // Update camera effects\n    m_v3CameraOffset.Clear();\n    m_v3CameraAngleOffset.Clear();\n\n    UpdateCameraShake(uiMilliseconds);\n    UpdateCameraKick(uiMilliseconds);\n    UpdateOverlay(uiMilliseconds);\n\n    if (uiMilliseconds > m_uiLastUpdateTime)\n        m_uiLastUpdateTime = uiMilliseconds;\n\n    return (m_itCurrentCmd == m_pvCmdBuffer->end() && m_uiWaitTime == 0);\n}\n\n\n/*====================\n  CEffectThread::Cleanup\n\n  delete dead particle system instances\n  ====================*/\nvoid    CEffectThread::Cleanup()\n{\n    InstanceMap::iterator it(m_mapInstances.begin());\n    while (it != m_mapInstances.end())\n    {\n        if (it->second->IsDead())\n        {\n            K2_DELETE(it->second);\n            STL_ERASE(m_mapInstances, it);\n        }\n        else\n        {\n            ++it;\n        }\n    }\n}\n\n\n/*====================\n  CEffectThread::AddInstance\n  ====================*/\nvoid    CEffectThread::AddInstance(const tstring &sName, IEffectInstance *pParticleSystem)\n{\n    if (m_bExpire)\n    {\n        K2_DELETE(pParticleSystem);\n        return;\n    }\n\n    InstanceMap::iterator findit(m_mapInstances.find(sName));\n\n    if (findit != m_mapInstances.end())\n    {\n        K2_DELETE(findit->second);\n        m_mapInstances.erase(findit);\n    }\n\n    m_mapInstances[sName] = pParticleSystem;\n}\n\n\n/*====================\n  CEffectThread::GetInstance\n  ====================*/\nIEffectInstance*    CEffectThread::GetInstance(const tstring &sName)\n{\n    InstanceMap::iterator findit(m_mapInstances.find(sName));\n\n    if (findit != m_mapInstances.end())\n        return findit->second;\n    else\n        return nullptr;\n}\n\n\n/*====================\n  CEffectThread::GetBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetBonePosition(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime)\n{\n    if (pSkeleton)\n    {\n        uint uiBone(pSkeleton->GetBone(sBone));\n\n        if (uiBone != INVALID_BONE)\n            return pSkeleton->GetBonePose(uiBone, uiTime);\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetBoneAxisPos(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    try\n    {\n        if (pSkeleton)\n        {\n            uint uiBone(pSkeleton->GetBone(sBone));\n\n            if (uiBone != INVALID_BONE)\n            {\n                pSkeleton->GetBonePoseAxisPos(uiBone, uiTime, aOutAxis, v3OutPos);\n                return;\n            }\n        }\n\n        aOutAxis = CAxis(0.0f, 0.0f, 0.0f);\n        v3OutPos = CVec3f(0.0f, 0.0f, 0.0f);\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_T(\"CEffectThread::GetBoneAxisPos() - \"), NO_THROW);\n        return;\n    }\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionOnMesh(CModel *pModel, const tstring &sMesh)\n{\n    if (!pModel)\n        return CVec3f(0.0f, 0.0f, 0.0f);\n\n    IModel *pModelFile(pModel->GetModelFile());\n\n    if (pModelFile && pModelFile->GetType() == MODEL_K2)\n    {\n        CK2Model *pK2Model(static_cast<CK2Model *>(pModelFile));\n\n        CMesh *pMesh(pK2Model->GetMesh(sMesh));\n\n        if (!pMesh || pMesh->numFaces == 0)\n            return CVec3f(0.0f, 0.0f, 0.0f);\n\n        if (pMesh->numFaces == 1)\n        {\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n        else\n        {\n            // Determine cumulative area of the entire mesh\n            // and distribute in vFaceAreas for weighted random\n            // face picking\n            vector<float> &vFaceAreas(pMesh->GetFaceAreas());\n            float fCumArea(pMesh->GetCumArea());\n            if (fCumArea == 0.0f)\n            {\n                vFaceAreas.resize(pMesh->numFaces);\n\n                for (uint uiFace(0); uiFace != pMesh->numFaces; ++uiFace)\n                {\n                    vFaceAreas[uiFace] = fCumArea;\n                    fCumArea += M_AreaOfTriangle(\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][0]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][1]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][2]]));\n                }\n\n                pMesh->SetCumArea(fCumArea);\n            }\n\n            float   fRand(M_Randnum(0.0f, fCumArea));\n\n            // Binary search for the face we just picked\n            uint    ui0(0);\n            uint    ui1(pMesh->numFaces);\n            uint    ui((ui1 - ui0) >> 1);\n\n            while (ui != 0 && ui + 1 != ui1 && (vFaceAreas[ui] > fRand || vFaceAreas[ui + 1] < fRand))\n            {\n                if (vFaceAreas[ui] < fRand)\n                    ui0 = ui;\n                else\n                    ui1 = ui;\n\n                ui = (ui1 + ui0) >> 1;\n            }\n\n            if (ui == pMesh->numFaces)\n                return CVec3f(0.0f, 0.0f, 0.0f);\n\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionOnMesh(CModel *pModel, const tstring &sMesh, const CVec3f &v3Dir)\n{\n    if (!pModel)\n        return CVec3f(0.0f, 0.0f, 0.0f);\n\n    IModel *pModelFile(pModel->GetModelFile());\n\n    if (pModelFile && pModelFile->GetType() == MODEL_K2)\n    {\n        CK2Model *pK2Model(static_cast<CK2Model *>(pModelFile));\n\n        CMesh *pMesh(pK2Model->GetMesh(sMesh));\n\n        if (!pMesh || pMesh->numFaces == 0)\n            return CVec3f(0.0f, 0.0f, 0.0f);\n\n        if (pMesh->numFaces == 1)\n        {\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n        else\n        {\n            // Determine cumulative area of the entire mesh\n            // and distribute in vFaceAreas for weighted random\n            // face picking\n            vector<float> &vFaceAreas(pMesh->GetFaceAreas());\n            float fCumArea(pMesh->GetCumArea());\n            if (fCumArea == 0.0f)\n            {\n                vFaceAreas.resize(pMesh->numFaces);\n\n                for (uint uiFace(0); uiFace != pMesh->numFaces; ++uiFace)\n                {\n                    vFaceAreas[uiFace] = fCumArea;\n                    fCumArea += M_AreaOfTriangle(\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][0]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][1]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][2]]));\n                }\n\n                pMesh->SetCumArea(fCumArea);\n            }\n\n            float   fRand(M_Randnum(0.0f, fCumArea));\n\n            // Binary search for the face we just picked\n            uint    ui0(0);\n            uint    ui1(pMesh->numFaces);\n            uint    ui((ui1 - ui0) >> 1);\n\n            while (ui != 0 && ui + 1 != ui1 && (vFaceAreas[ui] > fRand || vFaceAreas[ui + 1] < fRand))\n            {\n                if (vFaceAreas[ui] < fRand)\n                    ui0 = ui;\n                else\n                    ui1 = ui;\n\n                ui = (ui1 + ui0) >> 1;\n            }\n\n            if (ui == pMesh->numFaces)\n                return CVec3f(numeric_limits<float>::infinity(), numeric_limits<float>::infinity(), numeric_limits<float>::infinity());\n\n            CPlane  plane\n            (\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]),\n                true\n            );\n\n            if (M_Randnum(0.0f, 1.0f) > DotProduct(plane.v3Normal, v3Dir))\n                return CVec3f(numeric_limits<float>::infinity(), numeric_limits<float>::infinity(), numeric_limits<float>::infinity());\n\n\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionWithNormalOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionWithNormalOnMesh(CModel *pModel, const tstring &sMesh, CVec3f &v3Normal)\n{\n    if (!pModel)\n    {\n        v3Normal = CVec3f(0.0f, 0.0f, 1.0f);\n        return CVec3f(0.0f, 0.0f, 0.0f);\n    }\n\n    IModel *pModelFile(pModel->GetModelFile());\n\n    if (pModelFile && pModelFile->GetType() == MODEL_K2)\n    {\n        CK2Model *pK2Model(static_cast<CK2Model *>(pModelFile));\n\n        CMesh *pMesh(pK2Model->GetMesh(sMesh));\n\n        if (!pMesh || pMesh->numFaces == 0)\n        {\n            v3Normal = CVec3f(0.0f, 0.0f, 1.0f);\n            return CVec3f(0.0f, 0.0f, 0.0f);\n        }\n\n        if (pMesh->numFaces == 1)\n        {\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]) - v30);\n\n            CPlane  plane\n            (\n                CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]),\n                true\n            );\n            v3Normal = plane.v3Normal;\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n        else\n        {\n            // Determine cumulative area of the entire mesh\n            // and distribute in vFaceAreas for weighted random\n            // face picking\n            vector<float> &vFaceAreas(pMesh->GetFaceAreas());\n            float fCumArea(pMesh->GetCumArea());\n            if (fCumArea == 0.0f)\n            {\n                vFaceAreas.resize(pMesh->numFaces);\n\n                for (uint uiFace(0); uiFace != pMesh->numFaces; ++uiFace)\n                {\n                    vFaceAreas[uiFace] = fCumArea;\n                    fCumArea += M_AreaOfTriangle(\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][0]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][1]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][2]]));\n                }\n\n                pMesh->SetCumArea(fCumArea);\n            }\n\n            float   fRand(M_Randnum(0.0f, fCumArea));\n\n            // Binary search for the face we just picked\n            uint    ui0(0);\n            uint    ui1(pMesh->numFaces);\n            uint    ui((ui1 - ui0) >> 1);\n\n            while (ui != 0 && ui + 1 != ui1 && (vFaceAreas[ui] > fRand || vFaceAreas[ui + 1] < fRand))\n            {\n                if (vFaceAreas[ui] < fRand)\n                    ui0 = ui;\n                else\n                    ui1 = ui;\n\n                ui = (ui1 + ui0) >> 1;\n            }\n\n            if (ui == pMesh->numFaces)\n            {\n                v3Normal = CVec3f(0.0f, 0.0f, 1.0f);\n                return CVec3f(0.0f, 0.0f, 0.0f);\n            }\n\n            CPlane  plane\n            (\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]),\n                true\n            );\n            v3Normal = plane.v3Normal;\n\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionOnSkeleton\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionOnSkeleton(CSkeleton *pSkeleton)\n{\n    if (!pSkeleton || !pSkeleton->IsValid() || pSkeleton->GetModel() == INVALID_RESOURCE)\n        return CVec3f(numeric_limits<float>::infinity(), numeric_limits<float>::infinity(), numeric_limits<float>::infinity());\n\n    CModel *pModel(g_ResourceManager.GetModel(pSkeleton->GetModel()));\n    CK2Model *pK2Model(static_cast<CK2Model *>(pModel->GetModelFile()));\n\n    // Determine cumulative volume of the entire skeleton\n    // and distribute in vFaceAreas for weighted random\n    // face picking\n    float fCumVolume(0.0f);\n    vector<float>   vBoneVolumes(pSkeleton->GetNumBones());\n\n    for (uint uiBone(0); uiBone != pSkeleton->GetNumBones(); ++uiBone)\n    {\n        vBoneVolumes[uiBone] = fCumVolume;\n\n        CBone *pBone(pK2Model->GetBone(uiBone));\n        if (pBone == nullptr)\n        {\n            Console.Warn << _T(\"CEffectThread::GetRandomPositionOnSkeleton() - Invalid bone\") << newl;\n            continue;\n        }\n\n        if (pBone->GetName() == _T(\"Scene Root\") ||\n            pBone->GetName() == _T(\"Bip01\") ||\n            pBone->GetName()[0] == _T('_'))\n            continue;\n\n        uint uiParent(pBone->GetParentIndex());\n\n        if (uiParent != INVALID_BONE)\n        {\n            CVec3f  v3Start(pSkeleton->GetBoneState(uiBone)->tm_local.pos);\n            CVec3f  v3End(pSkeleton->GetBoneState(uiParent)->tm_local.pos);\n\n            float fLength(Length(v3End - v3Start));\n\n            fCumVolume += fLength * M_PI * (fLength/8) * (fLength/8);\n        }\n    }\n\n    float   fRand(M_Randnum(0.0f, fCumVolume));\n\n    // Binary search for the bone we just picked\n    uint    ui0(0);\n    uint    ui1(pSkeleton->GetNumBones());\n    uint    ui((ui1 - ui0) / 2);\n\n    while (ui != 0 && ui + 1 != ui1 && (vBoneVolumes[ui] > fRand || vBoneVolumes[ui + 1] < fRand))\n    {\n        if (vBoneVolumes[ui] < fRand)\n            ui0 = ui;\n        else\n            ui1 = ui;\n\n        ui = (ui1 + ui0) / 2;\n    }\n\n    if (ui == pSkeleton->GetNumBones())\n        return CVec3f(0.0f, 0.0f, 0.0f);\n\n    CBone *pBone(pK2Model->GetBone(ui));\n    uint uiParent(pBone->GetParentIndex());\n\n    SBoneState *pStart(pSkeleton->GetBoneState(ui));\n    SBoneState *pEnd(pSkeleton->GetBoneState(uiParent));\n\n    if (pStart == nullptr)\n    {\n        Console.Warn << _T(\"CEffectThread::GetRandomPositionOnSkeleton() - Accessing invalid start bone on model \") << pK2Model->GetName() << _T(\", accessing bone: \") << ui << _T(\", model bones: \") << pK2Model->GetNumBones() << _T(\", skeleton bones: \") << pSkeleton->GetNumBones() << newl;\n        return CVec3f(0.0f, 0.0f, 0.0f);\n    }\n\n    if (pEnd == nullptr)\n    {\n        Console.Warn << _T(\"CEffectThread::GetRandomPositionOnSkeleton() - Accessing invalid end bone on model \") << pK2Model->GetName() << _T(\", accessing bone: \") << uiParent << _T(\", model bones: \") << pK2Model->GetNumBones() << _T(\", skeleton bones: \") << pSkeleton->GetNumBones() << newl;\n        return CVec3f(0.0f, 0.0f, 0.0f);\n    }\n\n    CVec3f  v3Start(pSkeleton->GetBoneState(ui)->tm_local.pos);\n    CVec3f  v3End(pSkeleton->GetBoneState(uiParent)->tm_local.pos);\n\n    return CVec3f(LERP(M_Randnum(0.0f, 1.0f), v3Start, v3End));\n}\n\n\n/*====================\n  CEffectThread::GetBoneTransform\n  ====================*/\nmatrix43_t* CEffectThread::GetBoneTransform(CSkeleton *pSkeleton, const tstring &sBone)\n{\n    if (pSkeleton)\n    {\n        uint uiBone(pSkeleton->GetBone(sBone));\n\n        if (uiBone != INVALID_BONE)\n            return &pSkeleton->GetBoneState(pSkeleton->GetBone(sBone))->tm_local;\n    }\n\n    return nullptr;\n}\n\n\n/*====================\n  CEffectThread::GetVisibility\n  ====================*/\nbool    CEffectThread::GetVisibility(CSkeleton *pSkeleton, const tstring &sBone)\n{\n    if (pSkeleton)\n    {\n        uint uiBone(pSkeleton->GetBone(sBone));\n\n        if (uiBone != INVALID_BONE)\n            return pSkeleton->GetBoneState(pSkeleton->GetBone(sBone))->visibility != 0;\n    }\n\n    return false;\n}\n\n\n/*====================\n  CEffectThread::GetSourceBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetSourceBonePosition(const tstring &sBone, uint uiTime)\n{\n    return GetBonePosition(m_pSourceSkeleton, sBone, uiTime);\n}\n\n\n/*====================\n  CEffectThread::GetSourceBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetSourceBoneAxisPos(const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    GetBoneAxisPos(m_pSourceSkeleton, sBone, uiTime, aOutAxis, v3OutPos);\n}\n\n\n/*====================\n  CEffectThread::GetSourceMeshPosition\n  ====================*/\nCVec3f  CEffectThread::GetSourceMeshPosition(const tstring &sMesh)\n{\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionOnMesh(const tstring &sMesh)\n{\n    return GetRandomPositionOnMesh(m_pSourceModel, sMesh);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionOnMesh(const tstring &sMesh, const CVec3f &v3Dir)\n{\n    return GetRandomPositionOnMesh(m_pSourceModel, sMesh, v3Dir);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionWithNormalOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionWithNormalOnMesh(const tstring &sMesh, CVec3f &v3Normal)\n{\n    return GetRandomPositionWithNormalOnMesh(m_pSourceModel, sMesh, v3Normal);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionOnSkeleton\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionOnSkeleton()\n{\n    return GetRandomPositionOnSkeleton(m_pSourceSkeleton);\n}\n\n\n/*====================\n  CEffectThread::GetSourceBoneTransform\n  ====================*/\nmatrix43_t* CEffectThread::GetSourceBoneTransform(const tstring &sBone)\n{\n    return GetBoneTransform(m_pSourceSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::GetSourceVisibility\n  ====================*/\nbool    CEffectThread::GetSourceVisibility(const tstring &sBone)\n{\n    return GetVisibility(m_pSourceSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::SourceTransformPosition\n  ====================*/\nCVec3f  CEffectThread::SourceTransformPosition(const CVec3f &v3Pos)\n{\n    return TransformPoint(v3Pos, m_aSourceAxis, m_v3SourcePos);\n}\n\n\n/*====================\n  CEffectThread::SourceTransformAxis\n  ====================*/\nCAxis   CEffectThread::SourceTransformAxis(const CAxis &aAxis)\n{\n    return CAxis(aAxis * m_aSourceAxis);\n}\n\n\n/*====================\n  CEffectThread::GetTargetBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetTargetBonePosition(const tstring &sBone, uint uiTime)\n{\n    return GetBonePosition(m_pTargetSkeleton, sBone, uiTime);\n}\n\n\n/*====================\n  CEffectThread::GetTargetBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetTargetBoneAxisPos(const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    GetBoneAxisPos(m_pTargetSkeleton, sBone, uiTime, aOutAxis, v3OutPos);\n}\n\n\n/*====================\n  CEffectThread::GetTargetMeshPosition\n  ====================*/\nCVec3f  CEffectThread::GetTargetMeshPosition(const tstring &sMesh)\n{\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionOnMesh(const tstring &sMesh)\n{\n    return GetRandomPositionOnMesh(m_pTargetModel, sMesh);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionOnMesh(const tstring &sMesh, const CVec3f &v3Dir)\n{\n    return GetRandomPositionOnMesh(m_pTargetModel, sMesh, v3Dir);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionWithNormalOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionWithNormalOnMesh(const tstring &sMesh, CVec3f &v3Normal)\n{\n    return GetRandomPositionWithNormalOnMesh(m_pTargetModel, sMesh, v3Normal);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionOnSkeleton\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionOnSkeleton()\n{\n    return GetRandomPositionOnSkeleton(m_pTargetSkeleton);\n}\n\n\n/*====================\n  CEffectThread::GetTargetBoneTransform\n  ====================*/\nmatrix43_t* CEffectThread::GetTargetBoneTransform(const tstring &sBone)\n{\n    return GetBoneTransform(m_pTargetSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::GetTargetVisibility\n  ====================*/\nbool    CEffectThread::GetTargetVisibility(const tstring &sBone)\n{\n    return GetVisibility(m_pTargetSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::TargetTransformPosition\n  ====================*/\nCVec3f  CEffectThread::TargetTransformPosition(const CVec3f &v3Pos)\n{\n    return TransformPoint(v3Pos, m_aTargetAxis, m_v3TargetPos);\n}\n\n\n/*====================\n  CEffectThread::TargetTransformAxis\n  ====================*/\nCAxis   CEffectThread::TargetTransformAxis(const CAxis &aAxis)\n{\n    return CAxis(aAxis * m_aTargetAxis);\n}\n\n\n/*====================\n  CEffectThread::GetCustomBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetCustomBonePosition(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime)\n{\n    return GetBonePosition(pSkeleton, sBone, uiTime);\n}\n\n\n/*====================\n  CEffectThread::GetCustomVisibility\n  ====================*/\nbool    CEffectThread::GetCustomVisibility(CSkeleton *pSkeleton, const tstring &sBone)\n{\n    return GetVisibility(pSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::GetCustomBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetCustomBoneAxisPos(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    GetBoneAxisPos(pSkeleton, sBone, uiTime, aOutAxis, v3OutPos);\n}\n\n\n/*====================\n  CEffectThread::IsDeferred\n  ====================*/\nbool    CEffectThread::IsDeferred()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetDeferred();\n}\n\n\n/*====================\n  CEffectThread::IsPersistent\n  ====================*/\nbool    CEffectThread::IsPersistent()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetPersistent();\n}\n\n\n/*====================\n  CEffectThread::IsPausable\n  ====================*/\nbool    CEffectThread::IsPausable()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetPausable();\n}\n\n\n/*====================\n  CEffectThread::GetUseEntityEffectScale\n  ====================*/\nbool    CEffectThread::GetUseEntityEffectScale()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetUseEntityEffectScale();\n}\n\n/*====================\n  CEffectThread::StartCameraShake\n  ====================*/\nvoid    CEffectThread::StartCameraShake(uint uiMilliseconds, float fFalloffStart, float fFalloffEnd, float fFrequency, float fScale, uint uiDuration)\n{\n    if (m_bExpire)\n        return;\n\n    float fDistance(Distance(m_v3SourcePos, m_pCamera->GetOrigin()));\n\n    fScale *= CLAMP(ILERP(fDistance, fFalloffEnd, fFalloffStart), 0.0f, 1.0f);\n\n    // Only override an older shake if this one is stronger\n    if (m_uiCameraShakeTime + m_uiCameraShakeDuration > uiMilliseconds)\n    {\n        if (fScale == 0.0f ||\n            (fScale < m_v3CameraShake.x &&\n            fScale < m_v3CameraShake.y &&\n            fScale < m_v3CameraShake.z))\n            return;\n    }\n\n    m_uiCameraShakeTime = uiMilliseconds;\n    m_uiCameraShakeDuration = uiDuration;\n    m_fCameraShakeFrequency = fFrequency;\n    m_v3CameraShake = CVec3f(fScale, fScale, fScale);\n}\n\n\n/*====================\n  CEffectThread::UpdateCameraShake\n  ====================*/\nvoid    CEffectThread::UpdateCameraShake(uint uiMilliseconds)\n{\n    if (m_uiCameraShakeTime + m_uiCameraShakeDuration <= uiMilliseconds || m_uiCameraShakeTime > uiMilliseconds)\n        return;\n\n    float t(float(uiMilliseconds - m_uiCameraShakeTime) / m_uiCameraShakeDuration);\n\n    CVec3f v3Offset\n    (\n        M_Randnum(-m_v3CameraShake.x, m_v3CameraShake.x) * t,\n        M_Randnum(-m_v3CameraShake.y, m_v3CameraShake.y) * t,\n        M_Randnum(-m_v3CameraShake.z, m_v3CameraShake.z) * t\n    );\n    \n    v3Offset.SetLength(MAX(MAX(m_v3CameraShake.x, m_v3CameraShake.y), m_v3CameraShake.z) * t);\n\n    m_v3CameraOffset += v3Offset;\n}\n\n\n/*====================\n  CEffectThread::StartCameraKick\n  ====================*/\nvoid    CEffectThread::StartCameraKick(uint uiMilliseconds, const CRangef &rfPitch, float fTurn, const CRangef &rfBack, const CRangef &rfUp, const CRangef &rfRight, float fHalfLife)\n{\n    if (m_bExpire)\n        return;\n\n    m_uiCameraKickTime = uiMilliseconds;\n    m_fCameraKickHalfLife = fHalfLife;\n\n    float fRandTurn(M_Randnum(-fTurn, fTurn));\n    m_v3CameraKickAngles = CVec3f(rfPitch, -fRandTurn, fRandTurn);\n    m_v3CameraKickPosition = CVec3f(rfRight, rfUp, -rfBack);\n}\n\n\n/*====================\n  CEffectThread::UpdateCameraKick\n  ====================*/\nvoid    CEffectThread::UpdateCameraKick(uint uiMilliseconds)\n{\n    if (m_uiCameraKickTime == INVALID_TIME || m_uiCameraKickTime > uiMilliseconds)\n        return;\n\n    if (fabs(m_v3CameraKickAngles.x) < 0.01f && fabs(m_v3CameraKickAngles.y) < 0.01f && fabs(m_v3CameraKickAngles.z) < 0.01f &&\n        fabs(m_v3CameraKickPosition.x) < 0.01f && fabs(m_v3CameraKickPosition.y) < 0.01f && fabs(m_v3CameraKickPosition.z) < 0.01f)\n    {\n        m_uiCameraKickTime = INVALID_TIME;\n        return;\n    }\n\n    float fDeltaTime(MsToSec(uiMilliseconds - m_uiCameraKickTime));\n\n    if (fDeltaTime > 0.0f)\n    {\n        m_v3CameraKickAngles = DECAY(m_v3CameraKickAngles, V3_ZERO, m_fCameraKickHalfLife, fDeltaTime);\n        m_v3CameraKickPosition = DECAY(m_v3CameraKickPosition, V3_ZERO, m_fCameraKickHalfLife, fDeltaTime);\n    }\n\n    if (m_pCamera)\n    {\n        m_v3CameraAngleOffset += m_v3CameraKickAngles;\n        m_v3CameraOffset += m_v3CameraKickPosition;\n    }\n    else\n    {\n        m_v3CameraAngleOffset += m_v3CameraKickAngles;\n        m_v3CameraOffset += m_v3CameraKickPosition;\n    }\n\n    m_uiCameraKickTime = uiMilliseconds;\n}\n\n\n/*====================\n  CEffectThread::StartOverlay\n  ====================*/\nvoid    CEffectThread::StartOverlay(uint uiMilliseconds, const CTemporalPropertyv3 &tv3Color,\n                                  const CTemporalPropertyf &tfAlpha, ResHandle hMaterial, uint uiDuration)\n{\n    if (m_bExpire)\n        return;\n\n    m_bActiveOverlay = true;\n    m_uiOverlayStartTime = uiMilliseconds;\n    m_uiOverlayDuration = uiDuration;\n    m_tv3OverlayColor = tv3Color;\n    m_tfOverlayAlpha = tfAlpha;\n    m_hOverlayMaterial = hMaterial;\n}\n\n\n/*====================\n  CEffectThread::UpdateOverlay\n  ====================*/\nvoid    CEffectThread::UpdateOverlay(uint uiMilliseconds)\n{\n    if (m_uiOverlayStartTime + m_uiOverlayDuration <= uiMilliseconds)\n    {\n        m_bActiveOverlay = false;\n        return;\n    }\n\n    if (m_uiOverlayStartTime > uiMilliseconds)\n        return;\n\n    float fLerp(float(uiMilliseconds - m_uiOverlayStartTime) / m_uiOverlayDuration);\n    float fTime(MsToSec(uiMilliseconds - m_uiOverlayStartTime));\n    m_v4OverlayColor = CVec4f(m_tv3OverlayColor.Evaluate(fLerp, fTime), m_tfOverlayAlpha.Evaluate(fLerp, fTime));\n}\n\n\n/*====================\n  CEffectThread::StartCameraShake2\n  ====================*/\nvoid    CEffectThread::StartCameraShake2(uint uiMilliseconds, float fFalloffStart, float fFalloffEnd, float fFrequency, float fScale, uint uiDuration)\n{\n    if (m_bExpire)\n        return;\n\n    float fDistance(Distance(m_v3SourcePos, m_pCamera->GetCenter()));\n\n    fScale *= CLAMP(ILERP(fDistance, fFalloffEnd, fFalloffStart), 0.0f, 1.0f);\n\n    // Only override an older shake if this one is stronger\n    if (m_uiCameraShakeTime + m_uiCameraShakeDuration > uiMilliseconds)\n    {\n        if (fScale == 0.0f ||\n            (fScale < m_v3CameraShake.x &&\n            fScale < m_v3CameraShake.y &&\n            fScale < m_v3CameraShake.z))\n            return;\n    }\n\n    m_uiCameraShakeTime = uiMilliseconds;\n    m_uiCameraShakeDuration = uiDuration;\n    m_fCameraShakeFrequency = fFrequency;\n    m_v3CameraShake = CVec3f(fScale, fScale, fScale);\n}\n\n\n/*====================\n  CEffectThread::Rewind\n\n  Rewind the effect thread to a specific time.\n  Rewinding to before start time will kill the effect,\n  any other time will rebuild the effect and resimulate\n  to the specified time\n  ====================*/\nbool    CEffectThread::Rewind(uint uiMilliseconds)\n{\n    if (uiMilliseconds < m_uiStartTime)\n    {\n        m_itCurrentCmd = m_pvCmdBuffer->end();\n        return true;\n    }\n\n    // Delete all particle system instances\n    InstanceMap::iterator itEnd(m_mapInstances.end());\n    for (InstanceMap::iterator it(m_mapInstances.begin()); it != itEnd; ++it)\n        K2_DELETE(it->second);\n    m_mapInstances.clear();\n\n    m_uiLastUpdateTime = m_uiStartTime;\n    m_itCurrentCmd = m_itStartCmd;\n\n    return false;\n}\n\n\n/*====================\n  CEffectThread::Expire\n  ====================*/\nvoid    CEffectThread::Expire(uint uiMilliseconds)\n{\n    m_bExpire = true;\n\n    InstanceMap::iterator itEnd(m_mapInstances.end());\n    for (InstanceMap::iterator it(m_mapInstances.begin()); it != itEnd; ++it)\n        it->second->Expire(uiMilliseconds);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_effectthread.cpp b/src/k2/c_effectthread.cpp
--- a/src/k2/c_effectthread.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_effectthread.cpp	(date 1684975201825)
@@ -39,8 +39,6 @@
     for (EffectCmdBuffer::iterator itCmd(m_vCmdBuffer.begin()); itCmd != m_vCmdBuffer.end(); ++itCmd)
         K2_DELETE(*itCmd);
 
-    g_ResourceManager.RemoveResourceWatcher(this, m_hEffect);
-
     if (m_uiStartTime != 0xffffffff)
         --efx_activeThreads;
 }
Index: src/k2/c_anim.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_anim.h\n//\n//=============================================================================\n#ifndef __C_ANIM_H__\n#define __C_ANIM_H__\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"i_resourcewatcher2.h\"\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\nstruct SAnimEvent\n{\n    int             iFrame;\n    tstring         sCommand;\n\n    SAnimEvent() {}\n    SAnimEvent(int _iFrame, const tstring& _sCommand) : iFrame(_iFrame), sCommand(_sCommand) {}\n};\n\n\nclass CK2Model;\nclass CSkeleton;\nstruct SBoneMotion;\n//=============================================================================\n\n//=============================================================================\n// CAnim\n//=============================================================================\nclass CAnim : public IResourceWatcher\n{\nprivate:\n    uint                m_uiIndex;\n    tstring             m_sName;\n\n    // Frame triggered events, like footstep sounds and particles\n    vector<SAnimEvent>  m_vFrameEvents;\n    tsvector            m_vStartEvents;\n    tsvector            m_vEndEvents;\n\n    ResHandle           m_hClip;            // clip this animation references\n\n    SBoneMotion**       m_ppMotions;        // maps model bones to clip animation data\n\n    int                 m_iStartFrame;      // start frame\n    int                 m_iNumFrames;\n    int                 m_iLoopbackFrame;\n    bool                m_bLoop;\n    float               m_fFps;\n    int                 m_iMSperFrame;\n    int                 m_iNumLoopFrames;\n    int                 m_uiBlendTime;\n    bool                m_bLock;\n    int                 m_iMinStartFrame;\n    int                 m_iMaxStartFrame;\n    CK2Model*           m_pModel;\n\n    // Defaults for proper rebuilding during a clip reload\n    int                 m_iStartFrameDef;\n    int                 m_iNumFramesDef;\n    int                 m_iLoopbackFrameDef;\n    int                 m_iMinStartFrameDef;\n    int                 m_iMaxStartFrameDef;\n\npublic:\n    K2_API ~CAnim();\n    K2_API CAnim\n    (\n        CK2Model *pModel,\n        uint uiIndex,\n        const tstring &sName,\n        const tstring &sClip,\n        int iStartFrame,\n        int iNumFrames,\n        int iLoopbackFrame,\n        bool bLoop,\n        float fFps,\n        int iNumLoopFrames,\n        int iBlendTime,\n        bool bLock,\n        int iMinStartFrame,\n        int iMaxStartFrame,\n        uint uiIgnoreFlags\n    );\n\n    ResHandle                   GetClip() const                 { return m_hClip; }\n    SBoneMotion**               GetMotions() const              { return m_ppMotions; }\n    float                       GetFps() const                  { return m_fFps; }\n    int                         GetStartFrame() const           { return m_iStartFrame; }\n    int                         GetLoopbackFrame() const        { return m_iLoopbackFrame; }\n    int                         GetNumFrames() const            { return m_iNumFrames; }\n    bool                        IsLooping() const               { return m_bLoop; }\n    int                         GetNumLoopFrames() const        { return m_iNumLoopFrames; }\n    int                         GetBlendTime() const            { return m_uiBlendTime; }\n    bool                        GetLock() const                 { return m_bLock; }\n    int                         GetMSperFrame() const           { return m_iMSperFrame; }\n    int                         GetMinStartFrame() const        { return m_iMinStartFrame; }\n    int                         GetMaxStartFrame() const        { return m_iMaxStartFrame; }\n\n    bool                        ComputeAnimFrame(int iAnimTime, int &iLoFrame, int &iHiFrame, float &fLerpAmt, uint uiForceLength);\n\n    void                        Rebuild(ResHandle hResource);\n\n    void                        SetName(const tstring &sName)   { m_sName = sName; }\n    const tstring&              GetName() const                 { return m_sName; }\n\n    int                         GetLength() const               { return m_iNumFrames * m_iMSperFrame; }\n    uint                        GetIndex() const                { return m_uiIndex; }\n\n    K2_API void                 AddFrameEvent(int iFrame, const tstring &sCommand);\n    K2_API void                 AddStartEvent(const tstring &sCommand);\n    K2_API void                 AddEndEvent(const tstring &sCommand);\n\n    const tsvector&             GetStartEvents()                { return m_vStartEvents; }\n    const tsvector&             GetEndEvents()                  { return m_vEndEvents; }\n\n    void                        CheckEvents(CSkeleton *pSkeleton, int iTime0, int iTime1, int iChannel);\n};\n//=============================================================================\n#endif //__C_ANIM_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_anim.h b/src/k2/c_anim.h
--- a/src/k2/c_anim.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_anim.h	(date 1684972322086)
@@ -73,7 +73,7 @@
     (
         CK2Model *pModel,
         uint uiIndex,
-        const tstring &sName,
+        tstring sName,
         const tstring &sClip,
         int iStartFrame,
         int iNumFrames,
Index: src/k2/i_resourcewatcher2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resourcewatcher2.h\n//\n//=============================================================================\n#ifndef __I_RESOURCEWATCHER_H__\n#define __I_RESOURCEWATCHER_H__\n\n//=============================================================================\n// Definitions\n//=============================================================================\nclass IResource;\n//=============================================================================\n\n//=============================================================================\n// IResourceWatcher\n//      ***NOTE***:  BE SURE you call g_ResourceManager.RemoveResourceWatcher(this, m_hResource)\n//      in the destructor of your derived class!\n//=============================================================================\nclass IResourceWatcher\n{\n    friend class IResourceLibrary;\n\n    // internal for IResourceLibrary\nprivate:\n    bool            m_bHasAddedWatcher;\n\n    void            MarkHasAddedWatcher()       { m_bHasAddedWatcher = true; }\n    void            ClearHasAddedWatcher()      { m_bHasAddedWatcher = false; }\n    bool            HasAddedWatcher()           { return m_bHasAddedWatcher; }\n\npublic:\n    IResourceWatcher()\n        : m_bHasAddedWatcher(false)\n    { }\n\n    virtual ~IResourceWatcher()\n    { }\n\n    virtual void    Rebuild(ResHandle hResource) = 0;\n};\n//=============================================================================\n\n#endif //__I_RESOURCEWATCHER_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resourcewatcher2.h b/src/k2/i_resourcewatcher2.h
--- a/src/k2/i_resourcewatcher2.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/i_resourcewatcher2.h	(date 1684975201823)
@@ -13,28 +13,22 @@
 
 //=============================================================================
 // IResourceWatcher
-//      ***NOTE***:  BE SURE you call g_ResourceManager.RemoveResourceWatcher(this, m_hResource)
-//      in the destructor of your derived class!
 //=============================================================================
 class IResourceWatcher
 {
     friend class IResourceLibrary;
+    friend class CResourceManager;
 
     // internal for IResourceLibrary
 private:
-    bool            m_bHasAddedWatcher;
+    set<ResHandle>  m_setWatchingResources;
 
-    void            MarkHasAddedWatcher()       { m_bHasAddedWatcher = true; }
-    void            ClearHasAddedWatcher()      { m_bHasAddedWatcher = false; }
-    bool            HasAddedWatcher()           { return m_bHasAddedWatcher; }
+    bool            HasAddedWatcher(ResHandle hResource) const;
+    void            MarkHasAddedWatcher(ResHandle hResource);
+    void            ClearHasAddedWatcher(ResHandle hResource);
 
 public:
-    IResourceWatcher()
-        : m_bHasAddedWatcher(false)
-    { }
-
-    virtual ~IResourceWatcher()
-    { }
+    virtual ~IResourceWatcher();
 
     virtual void    Rebuild(ResHandle hResource) = 0;
 };
Index: src/k2/c_buttoncatcher.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2007 S2 Games\n// c_buttoncatcher.h\n//\n//=============================================================================\n#ifndef __C_BUTTONCATCHER_H__\n#define __C_BUTTONCATCHER_H__\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"i_widget.h\"\n//=============================================================================\n\n//=============================================================================\n// CButtonCatcher\n//=============================================================================\nclass CButtonCatcher : public IWidget\n{\n    EButton     m_eLastButton;\n    int         m_iLastModifier;\n    tstring     m_sLastButtonName;\n\n    bool        m_bImpulse;\n\n    void    UpdateButtonName(EButton button);\n\npublic:\n    ~CButtonCatcher()   {}\n    K2_API CButtonCatcher(CInterface *pInterface, IWidget *pParent, const CWidgetStyle& style);\n\n    tstring GetValue() const            { return m_sLastButtonName; }\n\n    virtual void    MouseDown(EButton button, const CVec2f &v2CursorPos);\n    virtual bool    ButtonDown(EButton button);\n    virtual bool    ButtonUp(EButton button);\n\n    virtual void    DoEvent(EWidgetEvent eEvent, const tstring &sParam = TSNULL);\n    virtual void    DoEvent(EWidgetEvent eEvent, const tsvector &vParam);\n};\n//=============================================================================\n#endif // __C_BUTTONCATCHER_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_buttoncatcher.h b/src/k2/c_buttoncatcher.h
--- a/src/k2/c_buttoncatcher.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_buttoncatcher.h	(date 1684983393308)
@@ -16,8 +16,7 @@
 //=============================================================================
 class CButtonCatcher : public IWidget
 {
-    EButton     m_eLastButton;
-    int         m_iLastModifier;
+    EButton     m_eLastButton = BUTTON_INVALID;
     tstring     m_sLastButtonName;
 
     bool        m_bImpulse;
Index: src/k2/i_resource.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resource.h\n//\n//=============================================================================\n#ifndef __I_RESOURCE_H__\n#define __I_RESOURCE_H__\n\n//=============================================================================\n// Declarations\n//=============================================================================\nclass IResourceWatcher;\n//=============================================================================\n\n//=============================================================================\n// IResource\n//=============================================================================\n#if defined(linux) || defined(__APPLE__)\nclass __attribute__ ((visibility(\"default\"))) IResource\n#else\nclass IResource\n#endif\n{\nprotected:\n    tstring         m_sPath;\n    tstring         m_sLocalizedPath;\n    tstring         m_sName;\n    int             m_iFlags;\n    const char*     m_pData;\n    uint            m_uiSize;\n    ResHandle       m_hHandle;\n    uint            m_uiNetIndex;\n    uint            m_uiIgnoreFlags;\n\n    set<ResHandle>              m_setDependents;\n\n    IResource();\n    IResource(const IResource&);\n\npublic:\n    K2_API virtual ~IResource();\n    K2_API IResource(const tstring &sPath, const tstring &sName);\n\n    K2_API virtual uint             GetResType() const=0;\n    K2_API virtual const tstring&   GetResTypeName() const=0;\n\n    const tstring&      GetPath() const             { return m_sPath; }\n    const tstring&      GetLocalizedPath() const    { if (m_sLocalizedPath.empty()) return m_sPath; return m_sLocalizedPath; }\n    const tstring&      GetName() const             { return m_sName; }\n    const char*         GetData() const             { return m_pData; }\n    uint                GetSize() const             { return m_uiSize; }\n    ResHandle           GetHandle() const           { return m_hHandle; }\n    uint                GetNetIndex() const         { return m_uiNetIndex; }\n    uint                GetIgnoreFlags() const      { return m_uiIgnoreFlags; }\n\n    void        SetLocalizedPath(const tstring &sPath)      { m_sLocalizedPath = sPath; }\n    void        SetName(const tstring &sName)               { m_sName = sName; }\n    void        SetHandle(ResHandle hHandle)                { m_hHandle = hHandle; }\n    void        SetNetIndex(uint uiNetIndex)                { m_uiNetIndex = uiNetIndex; }\n    void        SetIgnoreFlags(uint uiIgnoreFlags)          { m_uiIgnoreFlags = uiIgnoreFlags; }\n\n    void        SetFlags(int iFlags)            { m_iFlags = iFlags; }\n    void        AddFlags(int iFlags)            { m_iFlags |= iFlags; }\n    void        ClearFlags(int iFlags)          { m_iFlags &= ~iFlags; }\n    void        ClearAllFlags()                 { m_iFlags = 0; }\n    bool        HasFlags(int iFlags) const      { return (m_iFlags & iFlags) != 0; }\n\n    void                    AddDependent(ResHandle hRes)    { m_setDependents.insert(hRes); }\n    void                    ClearDependents()               { m_setDependents.clear(); }\n    const set<ResHandle>&   GetDependents() const           { return m_setDependents; }\n\n    K2_API bool     IsVirtualResource() const;\n    K2_API bool     MatchesWildcard(const tstring &sWild,\n        bool bMatchAgainstPath = true,\n        bool bMatchAgainstName = true,\n        bool bMatchAgainstType = true) const;\n\n    virtual int     Load(uint uiIgnoreFlags, const char *pData, uint uiSize) = 0;\n    virtual void    PostLoad()  {}\n    virtual bool    LoadNull()  { return false; }\n    virtual void    Free() = 0;\n    virtual void    Reloaded()  {}\n};\n//=============================================================================\n#endif //__I_RESOURCE_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resource.h b/src/k2/i_resource.h
--- a/src/k2/i_resource.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/i_resource.h	(date 1684977499792)
@@ -24,21 +24,21 @@
     tstring         m_sPath;
     tstring         m_sLocalizedPath;
     tstring         m_sName;
-    int             m_iFlags;
-    const char*     m_pData;
-    uint            m_uiSize;
-    ResHandle       m_hHandle;
-    uint            m_uiNetIndex;
-    uint            m_uiIgnoreFlags;
+    int             m_iFlags = 0;
+    const char*     m_pData = nullptr;
+    uint            m_uiSize = 0;
+    ResHandle       m_hHandle = INVALID_RESOURCE;
+    uint            m_uiNetIndex = INVALID_INDEX;
+    uint            m_uiIgnoreFlags = 0;
 
-    set<ResHandle>              m_setDependents;
+    set<ResHandle>  m_setDependents;
 
-    IResource();
     IResource(const IResource&);
 
 public:
+    IResource() = delete;
     K2_API virtual ~IResource();
-    K2_API IResource(const tstring &sPath, const tstring &sName);
+    K2_API IResource(const tstring &sPath, tstring sName);
 
     K2_API virtual uint             GetResType() const=0;
     K2_API virtual const tstring&   GetResTypeName() const=0;
Index: src/k2/i_resource.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resource.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"i_resource.h\"\n#include \"i_resourcewatcher2.h\"\n\n//=============================================================================\n\n/*====================\n  IResource::~IResource\n  ====================*/\nIResource::~IResource()\n{\n    SAFE_DELETE_ARRAY(m_pData);\n}\n\n\n/*====================\n  IResource::IResource\n  ====================*/\nIResource::IResource(const tstring &sPath, const tstring &sName) :\nm_sPath(FileManager.SanitizePath(sPath)),\nm_sName(sName),\nm_iFlags(0),\nm_pData(nullptr),\nm_uiSize(0),\nm_hHandle(INVALID_RESOURCE),\nm_uiNetIndex(INVALID_INDEX),\nm_uiIgnoreFlags(0)\n{\n}\n\n\n/*====================\n  IResource::IResource\n  ====================*/\nIResource::IResource(const IResource &c) :\nm_sPath(c.m_sPath),\nm_sName(c.m_sName),\nm_iFlags(c.m_iFlags),\nm_uiSize(c.m_uiSize),\nm_hHandle(c.m_hHandle),\nm_uiNetIndex(c.m_uiNetIndex),\nm_uiIgnoreFlags(c.m_uiIgnoreFlags)\n{\n    if (c.m_pData != nullptr)\n    {\n        m_pData = K2_NEW_ARRAY(ctx_Resources, char, m_uiSize);\n        MemManager.Copy((char *)m_pData, c.m_pData, m_uiSize);\n    }\n    else\n        m_pData = nullptr;\n}\n\n\n/*====================\n  IResource::IsVirtualResource\n  ====================*/\nbool    IResource::IsVirtualResource() const\n{\n    const tstring &sPath(GetPath());\n\n    if (sPath.empty())\n        return false;\n\n    if (sPath[0] == _T('$') || sPath[0] == _T('!') || sPath[0] == _T('*') || sPath.find(_CTS(\"%\"), 0) != tstring::npos)\n        return true;\n\n    return false;\n}\n\n\n/*====================\n  IResource::MatchesWildcard\n  ====================*/\nbool    IResource::MatchesWildcard(const tstring &sWild,\n                                   bool bMatchAgainstPath,\n                                   bool bMatchAgainstName,\n                                   bool bMatchAgainstType) const\n{\n    if (bMatchAgainstPath)\n    {\n        if (EqualsWildcards(sWild, m_sPath))\n            return true;\n    }\n\n    if (bMatchAgainstName)\n    {\n        if (EqualsWildcards(sWild, m_sName))\n            return true;\n    }\n\n    if (bMatchAgainstType)\n    {\n        if (EqualsWildcards(sWild, GetResTypeName()))\n            return true;\n    }\n\n    return false;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resource.cpp b/src/k2/i_resource.cpp
--- a/src/k2/i_resource.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/i_resource.cpp	(date 1684977499787)
@@ -9,6 +9,8 @@
 #include "k2_common.h"
 
 #include "i_resource.h"
+
+#include <utility>
 #include "i_resourcewatcher2.h"
 
 //=============================================================================
@@ -25,15 +27,9 @@
 /*====================
   IResource::IResource
   ====================*/
-IResource::IResource(const tstring &sPath, const tstring &sName) :
-m_sPath(FileManager.SanitizePath(sPath)),
-m_sName(sName),
-m_iFlags(0),
-m_pData(nullptr),
-m_uiSize(0),
-m_hHandle(INVALID_RESOURCE),
-m_uiNetIndex(INVALID_INDEX),
-m_uiIgnoreFlags(0)
+IResource::IResource(const tstring &sPath, tstring sName)
+: m_sPath(FileManager.SanitizePath(sPath))
+, m_sName(std::move(sName))
 {
 }
 
@@ -41,14 +37,14 @@
 /*====================
   IResource::IResource
   ====================*/
-IResource::IResource(const IResource &c) :
-m_sPath(c.m_sPath),
-m_sName(c.m_sName),
-m_iFlags(c.m_iFlags),
-m_uiSize(c.m_uiSize),
-m_hHandle(c.m_hHandle),
-m_uiNetIndex(c.m_uiNetIndex),
-m_uiIgnoreFlags(c.m_uiIgnoreFlags)
+IResource::IResource(const IResource &c)
+: m_sPath(c.m_sPath)
+, m_sName(c.m_sName)
+, m_iFlags(c.m_iFlags)
+, m_uiSize(c.m_uiSize)
+, m_hHandle(c.m_hHandle)
+, m_uiNetIndex(c.m_uiNetIndex)
+, m_uiIgnoreFlags(c.m_uiIgnoreFlags)
 {
     if (c.m_pData != nullptr)
     {
Index: src/k2/c_freetype.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_freetype.h\n//\n//=============================================================================\n#ifndef __C_FREETYPE_H__\n#define __C_FREETYPE_H__\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"i_resource.h\"\n//=============================================================================\n\n//=============================================================================\n// IFreeTypeResource\n//=============================================================================\nclass IFreeTypeResource : public IResource\n{\nprotected:\n    static FT_Library   s_FTLibrary;\n    static bool         s_bInitialized;\n\n    IFreeTypeResource();\n\npublic:\n    virtual ~IFreeTypeResource();\n    IFreeTypeResource(const tstring &sPath, const tstring &sName);\n\n    static FT_Library   GetFreetypeLib();\n};\n//=============================================================================\n\n#endif //__C_FREETYPE_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_freetype.h b/src/k2/c_freetype.h
--- a/src/k2/c_freetype.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_freetype.h	(date 1684977072950)
@@ -20,8 +20,6 @@
     static FT_Library   s_FTLibrary;
     static bool         s_bInitialized;
 
-    IFreeTypeResource();
-
 public:
     virtual ~IFreeTypeResource();
     IFreeTypeResource(const tstring &sPath, const tstring &sName);
Index: src/k2/c_fontface.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_fontface.h\n//\n//=============================================================================\n#ifndef __C_FONTFACE_H__\n#define __C_FONTFACE_H__\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"c_freetype.h\"\n//=============================================================================\n\n//=============================================================================\n// Declarations\n//=============================================================================\nIResource*  AllocFontFace(const tstring &sPath);\n//=============================================================================\n\n//=============================================================================\n// CFontFace\n//=============================================================================\nclass CFontFace : public IFreeTypeResource\n{\nprivate:\n    FT_Face     m_FTFace;\n\n    CFontFace();\n\npublic:\n    ~CFontFace()    {}\n    CFontFace(const tstring &sPath);\n\n    K2_API  virtual uint            GetResType() const          { return RES_FONTFACE; }\n    K2_API  virtual const tstring&  GetResTypeName() const      { return ResTypeName(); }\n    K2_API  static const tstring&   ResTypeName()               { static tstring sTypeName(_T(\"{fontface}\")); return sTypeName; }\n\n    FT_Face GetFace() const { return m_FTFace; }\n\n    int     Load(uint uiIgnoreFlags, const char *pData, uint uiSize);\n    void    Free();\n};\n//=============================================================================\n\n#endif //__C_FONTFACE_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_fontface.h b/src/k2/c_fontface.h
--- a/src/k2/c_fontface.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_fontface.h	(date 1684977072948)
@@ -25,10 +25,7 @@
 private:
     FT_Face     m_FTFace;
 
-    CFontFace();
-
 public:
-    ~CFontFace()    {}
     CFontFace(const tstring &sPath);
 
     K2_API  virtual uint            GetResType() const          { return RES_FONTFACE; }
Index: src/k2/c_buttoncatcher.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2007 S2 Games\n// c_buttoncatcher.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_buttoncatcher.h\"\n#include \"c_interface.h\"\n#include \"c_widgetstyle.h\"\n#include \"c_uitextureregistry.h\"\n#include \"c_draw2d.h\"\n#include \"c_uicmd.h\"\n#include \"c_input.h\"\n//=============================================================================\n\n//=============================================================================\n// Declarations\n//=============================================================================\n//=============================================================================\n\n/*====================\n  CButtonCatcher::CButtonCatcher\n  ====================*/\nCButtonCatcher::CButtonCatcher(CInterface *pInterface, IWidget *pParent, const CWidgetStyle& style) :\nIWidget(pInterface, pParent, WIDGET_BUTTONCATCHER, style),\nm_eLastButton(BUTTON_INVALID),\nm_iLastModifier(0),\nm_bImpulse(style.GetPropertyBool(_T(\"impulse\"), false))\n{\n    if (IsAbsoluteVisible())\n        DO_EVENT(WEVENT_SHOW)\n\n    SetEventCommand(WEVENT_BUTTON, style.GetProperty(_T(\"onbutton\")));\n}\n\n\n/*====================\n  CButtonCatcher::MouseDown\n  ====================*/\nvoid    CButtonCatcher::MouseDown(EButton button, const CVec2f &v2CursorPos)\n{\n    if (m_bImpulse)\n    {\n        UpdateButtonName(button);\n        DO_EVENT_PARAM(WEVENT_BUTTON, m_sLastButtonName)\n    }\n    else\n    {\n        m_sLastButtonName = Input.GetBindString(button, 0);\n        DO_EVENT_PARAM(WEVENT_BUTTON, m_sLastButtonName)\n    }\n}\n\n\n/*====================\n  CButtonCatcher::UpdateButtonName\n  ====================*/\nvoid    CButtonCatcher::UpdateButtonName(EButton button)\n{\n    int iModifier(0);\n    if (Input.IsAltDown())\n        iModifier |= BIND_MOD_ALT;\n    if (Input.IsCtrlDown())\n        iModifier |= BIND_MOD_CTRL;\n    if (Input.IsShiftDown())\n        iModifier |= BIND_MOD_SHIFT;\n#ifdef __APPLE__\n    if (Input.IsCommandDown())\n        iModifier |= BIND_MOD_CMD;\n#endif\n\n    m_eLastButton = button;\n    m_iLastModifier = iModifier;\n    m_sLastButtonName = Input.GetBindString(button, iModifier);\n}\n\n\n/*====================\n  CButtonCatcher::ButtonDown\n  ====================*/\nbool    CButtonCatcher::ButtonDown(EButton button)\n{\n    if (m_bImpulse)\n    {\n        if (button == BUTTON_ALT || button == BUTTON_CTRL || button == BUTTON_SHIFT\n#ifdef __APPLE__\n            || button == BUTTON_CMD\n#endif\n            )\n        {\n            UpdateButtonName(BUTTON_UNSET);\n            DO_EVENT_PARAM_RETURN(WEVENT_CHANGE, m_sLastButtonName, true)\n            return true;\n        }\n        else\n        {\n            UpdateButtonName(button);\n            DO_EVENT_PARAM_RETURN(WEVENT_BUTTON, m_sLastButtonName, true)\n            return true;\n        }\n    }\n    else\n    {\n        m_sLastButtonName = Input.GetBindString(button, 0);\n        DO_EVENT_PARAM_RETURN(WEVENT_BUTTON, m_sLastButtonName, true)\n        return true;\n    }\n}\n\n\n/*====================\n  CButtonCatcher::ButtonUp\n  ====================*/\nbool    CButtonCatcher::ButtonUp(EButton button)\n{\n    UpdateButtonName(m_eLastButton);\n    DO_EVENT_PARAM_RETURN(WEVENT_CHANGE, m_sLastButtonName, true)\n    return true;\n}\n\n\n/*====================\n  CButtonCatcher::DoEvent\n  ====================*/\nvoid    CButtonCatcher::DoEvent(EWidgetEvent eEvent, const tstring &sParam)\n{\n    IWidget::DoEvent(eEvent, sParam);\n\n    if (HasFlags(WFLAG_RELEASED | WFLAG_DEAD))\n        return;\n    \n    // Don't execute show events if we're still hidden\n    // Don't execute hide events if we were already hidden\n    if ((eEvent == WEVENT_SHOW || eEvent == WEVENT_HIDE) && !IsAbsoluteVisible())\n        return;\n\n    if (eEvent == WEVENT_SHOW)\n        m_pInterface->SetActiveWidget(this);\n    else if (eEvent == WEVENT_HIDE)\n    {\n        if (m_pInterface->GetActiveWidget() == this)\n            m_pInterface->SetActiveWidget(nullptr);\n    }\n}\n\n\n/*====================\n  CButtonCatcher::DoEvent\n  ====================*/\nvoid    CButtonCatcher::DoEvent(EWidgetEvent eEvent, const tsvector &vParam)\n{\n    IWidget::DoEvent(eEvent, vParam);\n\n    if (HasFlags(WFLAG_RELEASED | WFLAG_DEAD))\n        return;\n    \n    // Don't execute show events if we're still hidden\n    // Don't execute hide events if we were already hidden\n    if ((eEvent == WEVENT_SHOW || eEvent == WEVENT_HIDE) && !IsAbsoluteVisible())\n        return;\n\n    if (eEvent == WEVENT_SHOW)\n        m_pInterface->SetActiveWidget(this);\n    else if (eEvent == WEVENT_HIDE)\n    {\n        if (m_pInterface->GetActiveWidget() == this)\n            m_pInterface->SetActiveWidget(nullptr);\n    }\n}\n\n    \n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_buttoncatcher.cpp b/src/k2/c_buttoncatcher.cpp
--- a/src/k2/c_buttoncatcher.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_buttoncatcher.cpp	(date 1684983393311)
@@ -28,7 +28,6 @@
 CButtonCatcher::CButtonCatcher(CInterface *pInterface, IWidget *pParent, const CWidgetStyle& style) :
 IWidget(pInterface, pParent, WIDGET_BUTTONCATCHER, style),
 m_eLastButton(BUTTON_INVALID),
-m_iLastModifier(0),
 m_bImpulse(style.GetPropertyBool(_T("impulse"), false))
 {
     if (IsAbsoluteVisible())
@@ -74,7 +73,6 @@
 #endif
 
     m_eLastButton = button;
-    m_iLastModifier = iModifier;
     m_sLastButtonName = Input.GetBindString(button, iModifier);
 }
 
Index: src/k2/i_resourcewatcher2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resourcewatcher2.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"i_resourcewatcher2.h\"\n//=============================================================================\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resourcewatcher2.cpp b/src/k2/i_resourcewatcher2.cpp
--- a/src/k2/i_resourcewatcher2.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/i_resourcewatcher2.cpp	(date 1684975053244)
@@ -8,5 +8,47 @@
 //=============================================================================
 #include "k2_common.h"
 
+#include "c_resourcemanager.h"
+
 #include "i_resourcewatcher2.h"
 //=============================================================================
+
+
+/*====================
+  IResourceWatcher::~IResourceWatcher
+  ====================*/
+IResourceWatcher::~IResourceWatcher()
+{
+    auto setResources(m_setWatchingResources); // copy, since RemoveResourceWatcher mutates m_setWatchingResources
+    for (ResHandle hResource : setResources)
+        g_ResourceManager.RemoveResourceWatcher(this, hResource);
+}
+
+
+/*====================
+  IResourceWatcher::HasAddedWatcher
+  ====================*/
+bool IResourceWatcher::HasAddedWatcher(ResHandle hResource) const
+{
+    return m_setWatchingResources.contains(hResource);
+}
+
+
+/*====================
+  IResourceWatcher::MarkHasAddedWatcher
+  ====================*/
+void IResourceWatcher::MarkHasAddedWatcher(ResHandle hResource)
+{
+    if (hResource != INVALID_RESOURCE)
+        m_setWatchingResources.insert(hResource);
+}
+
+
+/*====================
+  IResourceWatcher::ClearHasAddedWatcher
+  ====================*/
+void IResourceWatcher::ClearHasAddedWatcher(ResHandle hResource)
+{
+    if (auto it = m_setWatchingResources.find(hResource); it != m_setWatchingResources.end())
+        m_setWatchingResources.erase(it);
+}
Index: src/k2/i_resourcelibrary.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resourcelibrary.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"i_resourcelibrary.h\"\n#include \"i_resource.h\"\n#include \"i_resourcewatcher2.h\"\n#include \"c_statestring.h\"\n#include \"c_networkresourcemanager.h\"\n#include \"c_eventmanager.h\"\n#include \"c_resourcemanager.h\"\n#include \"c_restorevalue.h\"\n#include \"c_resourceinfo.h\"\n//=============================================================================\n\n//=============================================================================\n// Declarations\n//=============================================================================\nEXTERN_CVAR_STRING(host_vidDriver);\nEXTERN_CVAR_STRING(host_language);\n//=============================================================================\n\n\n/*====================\n  IResourceLibrary::~IResourceLibrary\n  ====================*/\nIResourceLibrary::~IResourceLibrary()\n{\n    for (ResPtrVec::iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n    {\n        if (*it)\n        {\n            // TODO:\n            //(*it)->Free();\n            //delete *it;\n        }\n    }\n\n    CResourceManager::GetInstance()->UnregisterLibrary(m_uiType);\n}\n\n\n/*====================\n  IResourceLibrary::IResourceLibrary\n  ====================*/\nIResourceLibrary::IResourceLibrary(uint uiType, const tstring &sName, const tstring &sTypeName, bool bLoadRaw, ResRegAllocFn fnAlloc) :\nm_sName(sName),\nm_sTypeName(sTypeName),\nm_uiType(uiType),\nm_fnAlloc(fnAlloc),\nm_bLoadRaw(bLoadRaw),\nm_bReplaceResources(false),\nm_llLoadTime(0),\nm_llLoadMemory(0),\nm_llLoadCount(0),\nm_bReloading(false)\n{\n    CResourceManager::GetInstance()->RegisterLibrary(uiType, this);\n}\n\n\n/*====================\n  IResourceLibrary::Register\n  ====================*/\nResHandle   IResourceLibrary::Register(const tstring &sDirtyPath, uint uiIgnoreFlags)\n{\n    IResource *pNewResource(nullptr);\n    ResHandle hReservedHandle(INVALID_RESOURCE);\n\n    tstring sPath(FileManager.SanitizePath(sDirtyPath));\n    tstring sOldDir(FileManager.GetWorkingDirectory());\n\n    // Check for an already registered resource\n    ResHandle hFind(LookUpPath(sPath));\n    if (hFind != INVALID_RESOURCE)\n    {\n        IResource *pOldResource(Get(hFind));\n\n        bool bShouldReload(false);\n        if ((pOldResource->GetIgnoreFlags() ^ uiIgnoreFlags) & ~uiIgnoreFlags)\n            bShouldReload = true;\n\n        if (bShouldReload)\n        {\n            if (!Reload(hFind, uiIgnoreFlags))\n                return INVALID_RESOURCE;\n        }\n\n        CGraphResource::LinkExistingChild(hFind);\n        return hFind;\n    }\n\n    g_ResourceManager.StartResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    CGraphResource cGraphResource;\n    cGraphResource.SetDebugPath(sPath);\n\n    const char *pData(nullptr);\n    uint uiSize(0);\n    CFileHandle hFile;\n\n    tstring sLocalizedPath(sPath);\n    bool bLocalized(true);\n    if (m_bLoadRaw && !sPath.empty() && sPath[0] != _T('$') && sPath[0] != _T('!') && sPath[0] != _T('*') && sPath.find(_CTS(\"%\"), 0) == tstring::npos) // check for virtual resources (like procedural textures)\n    {\n        if (!host_language.empty())\n        {\n            sLocalizedPath = Filename_StripExtension(sLocalizedPath) + _CTS(\"_\") + host_language + _CTS(\".\") + Filename_GetExtension(sLocalizedPath);\n            if (!FileManager.Exists(sLocalizedPath, FILE_READ))\n            {\n                bLocalized = false;\n                sLocalizedPath = sPath;\n            }\n        }\n#if 0\n        if (!hFile.Open(sPath, FILE_READ | FILE_BINARY))\n            EX_WARN(_T(\"Failed to open file\"));\n#else\n        hFile.Open(sLocalizedPath, FILE_READ | FILE_BINARY);\n#endif\n        pData = hFile.GetBuffer(uiSize);\n    }\n\n    try\n    {\n        // Allocate a new resource object\n        if (m_fnAlloc == nullptr)\n            EX_ERROR(_CTS(\"No allocator provided for this resource type\"));\n\n        pNewResource = m_fnAlloc(sPath);\n        if (pNewResource == nullptr)\n            EX_WARN(_CTS(\"Failed to allocate resource\"));\n\n        if (!sPath.empty() && sPath[0] != _T('$') && sPath[0] != _T('!') && sPath[0] != _T('*'))\n            FileManager.SetWorkingDirectory(Filename_GetPath(FileManager.SanitizePath(sPath)));\n\n        if (bLocalized)\n        {\n            pNewResource->AddFlags(RES_FLAG_LOCALIZED);\n            pNewResource->SetLocalizedPath(sLocalizedPath);\n        }\n\n        // Load the resource\n        pNewResource->AddFlags(pNewResource->Load(uiIgnoreFlags, pData, uiSize));\n        const tstring &sName(pNewResource->GetName());\n\n        // Check for a name conflict\n        if (!sName.empty())\n        {\n            if (LookUpName(sName) != INVALID_RESOURCE)\n                EX_ERROR(_CTS(\"Name collision for \") + QuoteStr(sName));\n        }\n    }\n    catch (CException &ex)\n    {\n        cGraphResource.Reset();\n\n        assert(pNewResource);\n        if (pNewResource)\n        {\n            pNewResource->AddFlags(RES_LOAD_FAILED);\n            pNewResource->LoadNull();\n        }\n\n        ex.Process(_CTS(\"IResourceLibrary::Register(\") + sPath + _CTS(\") - \"), NO_THROW);\n    }\n\n    CResourceManager::GetInstance()->EndResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    FileManager.SetWorkingDirectory(sOldDir);\n\n    assert(pNewResource);\n    if (!pNewResource)\n        return INVALID_RESOURCE;\n\n    // assign a handle to the resource.\n    if (hReservedHandle == INVALID_RESOURCE)\n    {\n        // if the path is reserved for a specific handle, use it.\n        PathHandleMap::iterator itFind(m_mapReservedHandles.find(sPath));\n        if (itFind != m_mapReservedHandles.end())\n        {\n            hReservedHandle = itFind->second;\n\n            // this is optional, but since memory is so tight, we should probably do this.\n            m_mapReservedHandles.erase(itFind);\n        }\n        else if (!m_stkAvailableHandles.empty())\n        {\n            // otherwise, try to use any available handle.\n            hReservedHandle = m_stkAvailableHandles.top();\n            m_stkAvailableHandles.pop();\n        }\n        else\n        {\n            // if no handles are available, then allocate a new one.\n            hReservedHandle = (ResHandle)m_vEntries.size();\n            m_vEntries.push_back(nullptr);\n        }\n    }\n    assert(hReservedHandle != INVALID_RESOURCE);\n\n    // Assign this entry a handle and add it to the map\n    ResHandle hIdx(hReservedHandle);\n    m_vEntries[hIdx] = pNewResource;\n    EmbedType(hReservedHandle);\n    if (!pNewResource->GetName().empty())\n        m_mapResNames[pNewResource->GetName()] = hReservedHandle;\n    if (!pNewResource->GetPath().empty())\n        m_mapResPaths[pNewResource->GetPath()] = hReservedHandle;\n    pNewResource->SetHandle(hReservedHandle);\n    pNewResource->PostLoad();\n\n    cGraphResource.SetHandle(hReservedHandle);\n    cGraphResource.Done();\n\n    // notify any watchers that this resource has been registered again.\n    NotifyWatchers(hReservedHandle);\n\n    return hReservedHandle;\n}\n\nResHandle   IResourceLibrary::Register(IResource *pResource, uint uiIgnoreFlags)\n{\n    tstring sOldDir(FileManager.GetWorkingDirectory());\n    ResHandle hReservedHandle(INVALID_RESOURCE);\n\n    ResHandle   hFind(INVALID_RESOURCE);\n\n    assert(!(pResource->GetPath().empty() && pResource->GetName().empty()));\n\n    // Check for an already registered resource\n    // External resources must have a unique name\n    const tstring &sName(pResource->GetName());\n    if (!sName.empty())\n        hFind = LookUpName(sName);\n\n    // Check for an already registered resource\n    // For paths, there can be only one...\n    const tstring &sPath(pResource->GetPath());\n    if (!sPath.empty() && hFind == INVALID_RESOURCE)\n    {\n        hFind = LookUpPath(sPath);\n\n        // Link the new name to the existing resource\n        if (!sName.empty() && hFind != INVALID_RESOURCE)\n            m_mapResNames[sName] = hFind;\n    }\n\n    // Delete the input resource if we already have a resource with this name registered\n    if (hFind != INVALID_RESOURCE)\n    {\n        if (m_bReplaceResources)\n        {\n            Unregister(hFind, UNREG_RESERVE_HANDLE);\n        }\n        else\n        {\n            IResource *pOldResource(Get(hFind));\n            bool bShouldReload(false);\n            if ((pOldResource->GetIgnoreFlags() ^ uiIgnoreFlags) & ~uiIgnoreFlags)\n                bShouldReload = true;\n\n            if (bShouldReload)\n            {\n                if (!Reload(hFind, uiIgnoreFlags))\n                {\n                    SAFE_DELETE(pResource);\n                    return INVALID_RESOURCE;\n                }\n            }\n\n            SAFE_DELETE(pResource);\n            CGraphResource::LinkExistingChild(hFind);\n            return hFind;\n        }\n    }\n\n    if (!sPath.empty() && sPath[0] != _T('$') && sPath[0] != _T('!') && sPath[0] != _T('*'))\n        FileManager.SetWorkingDirectory(Filename_GetPath(FileManager.SanitizePath(sPath)));\n\n    CResourceManager::GetInstance()->StartResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    CGraphResource cGraphResource;\n    cGraphResource.SetDebugPath(sPath);\n\n    try\n    {\n        uint uiResFlags(RES_EXTERNAL);\n\n        // prevent procedural textures from being reloaded.\n        if (!sPath.empty() && sPath[0] == '$')\n            uiResFlags = 0;\n\n        // Load the resource\n        pResource->AddFlags(pResource->Load(uiIgnoreFlags, pResource->GetData(), pResource->GetSize()) | uiResFlags);\n    }\n    catch (CException &ex)\n    {\n        cGraphResource.Reset();\n\n        tstring sPath(pResource->GetPath());\n\n        pResource->AddFlags(RES_LOAD_FAILED | RES_EXTERNAL);\n        pResource->LoadNull();\n\n        ex.Process(_TS(\"IResourceLibrary::Register(\") + sPath + _TS(\") - \"), NO_THROW);\n    }\n\n    CResourceManager::GetInstance()->EndResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    FileManager.SetWorkingDirectory(sOldDir);\n\n    // assign a handle to the resource.\n    if (hReservedHandle == INVALID_RESOURCE)\n    {\n        PathHandleMap::iterator itFind(m_mapReservedHandles.find(sPath));\n        if (itFind != m_mapReservedHandles.end())\n        {\n            // if the path is reserved for a specific handle, use it.\n            hReservedHandle = itFind->second;\n\n            // this is optional, but since memory is so tight, we should probably do this.\n            m_mapReservedHandles.erase(itFind);\n        }\n        else if (!m_stkAvailableHandles.empty()) \n        {\n            // otherwise, try to use any available handle.\n            hReservedHandle = m_stkAvailableHandles.top();\n            m_stkAvailableHandles.pop();\n        }\n        else\n        {\n            // if no handles are available, then allocate a new one.\n            hReservedHandle = (ResHandle)m_vEntries.size();\n            m_vEntries.push_back(nullptr);\n        }\n    }\n    assert(hReservedHandle != INVALID_RESOURCE);\n\n    // Assign this entry a handle and add it to the map\n    ResHandle hIdx(hReservedHandle);\n    m_vEntries[hIdx] = pResource;\n    EmbedType(hReservedHandle);\n    if (!pResource->GetName().empty())\n        m_mapResNames[pResource->GetName()] = hReservedHandle;\n    if (!pResource->GetPath().empty())\n        m_mapResPaths[pResource->GetPath()] = hReservedHandle;\n    pResource->SetHandle(hReservedHandle);\n    pResource->PostLoad();\n    cGraphResource.SetHandle(hReservedHandle);\n    cGraphResource.Done();\n\n    // notify any watchers that this resource has been registered again.\n    NotifyWatchers(hReservedHandle);\n\n    return hReservedHandle;\n}\n\n\n/*====================\n  IResourceLibrary::Unregister\n  ====================*/\nvoid    IResourceLibrary::Unregister(ResHandle hResource, EUnregisterResource eUnregisterOp)\n{\n    if (GetType(hResource) != m_uiType)\n    {\n        Console.Warn << _T(\"IResourceLibrary::Unregister(\") << hResource << _T(\") - Handle is of wrong type\") << newl;\n        return;\n    }\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n\n    if (hIdx >= m_vEntries.size())\n    {\n        Console.Warn << _T(\"IResourceLibrary::Unregister(\") << hResource << _T(\") - Handle out of range\") << newl;\n        return;\n    }\n\n    g_ResourceInfo.OnResourceUnregistered(hResource);\n\n    IResource* pResource(m_vEntries[hIdx]);\n    assert(pResource != nullptr);\n    if (pResource == nullptr)\n        return;\n\n    ResNameMap::iterator findit;\n\n    if (eUnregisterOp == UNREG_DELETE_HANDLE)\n    {\n        // free the handle for use by any other resource of the same type.\n        m_stkAvailableHandles.push(hIdx);\n\n        // if something was watching this resource, which we just deleted, then this is a very bad thing!\n        bool bHasResourceWatcher(HasResourceWatcher(hResource));\n        assert(!bHasResourceWatcher);\n        if (bHasResourceWatcher)\n            Console.Warn << _T(\"IResourceLibrary::Unregister(\") << hResource << _T(\") - Deleted a resource handle which was being watched!\") << newl;\n    }\n    else\n    {\n        assert(eUnregisterOp == UNREG_RESERVE_HANDLE);\n\n        // reserve the handle for resources with this path only.\n        const tstring &sPath(pResource->GetPath());\n        m_mapReservedHandles[sPath] = hIdx;\n    }\n\n    findit = m_mapResNames.find(pResource->GetName());\n    if (findit != m_mapResNames.end())\n        m_mapResNames.erase(findit);\n\n    findit = m_mapResPaths.find(pResource->GetPath());\n    if (findit != m_mapResPaths.end())\n        m_mapResPaths.erase(findit);\n\n    pResource->Free();\n    SAFE_DELETE(m_vEntries[hIdx]);\n\n    if (!m_bReloading)\n    {\n        // notify the resource watchers that this resource has been unregistered.\n        NotifyWatchers(hResource);\n    }\n}\n\n\n/*====================\n  IResourceLibrary::ReloadByFlag\n  ====================*/\nvoid    IResourceLibrary::ReloadByFlag(int iFlag)\n{\n    for (ResPtrVec::iterator it(m_vEntries.begin()); it != m_vEntries.end(); it++)\n    {\n        if (!*it)\n            continue;\n\n        if ((*it)->HasFlags(iFlag))\n            Reload((*it)->GetHandle(), 0xffffffff);\n    }\n}\n\n\n/*====================\n  IResourceLibrary::Reload\n  ====================*/\nbool    IResourceLibrary::Reload(ResHandle hResource, uint uiIgnoreFlags)\n{\n    IResource *pResource(Get(hResource));\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n\n    // Validate handle\n    if (pResource == nullptr)\n    {\n        Console.Warn << _T(\"Invalid resource handle\") << newl;\n        return false;\n    }\n\n    Console << _T(\"Reloading \");\n    g_ResourceManager.PrintResource(Console.DefaultStream(), pResource);\n    Console << newl;\n            \n    // Save pertinent data\n    tstring sSavedPath(pResource->GetPath());\n    uint uiSavedIgnoreFlags(pResource->GetIgnoreFlags());\n    set<ResHandle>  setDependents(pResource->GetDependents());\n\n    try\n    {\n        CRestoreValue<bool> cSetReloading(m_bReloading, true);\n\n        if (pResource->HasFlags(RES_EXTERNAL))\n        {\n            const tstring &sPath(pResource->GetPath());\n\n            if (!sPath.empty() && sPath[0] == _T('*'))\n                return true;\n\n            // External resources with valid paths set should just Free+Load\n            pResource->Free();\n            g_ResourceInfo.OnResourceUnregistered(hResource);\n            CGraphResource cGraphResource;\n            cGraphResource.SetHandle(hResource);\n            pResource->Load(pResource->GetIgnoreFlags() & uiIgnoreFlags, pResource->GetData(), pResource->GetSize());\n        }\n        else\n        {\n            // Reload\n            if (sSavedPath[0] != '$')\n            {\n                g_ResourceManager.Unregister(hResource, UNREG_RESERVE_HANDLE);\n                if (g_ResourceManager.Register(sSavedPath, m_uiType, uiSavedIgnoreFlags & uiIgnoreFlags) != hResource)\n                    EX_ERROR(_T(\"Resource handle changed\"));\n            }\n            pResource = Get(hResource);\n        }\n    }\n    catch (CException &ex)\n    {\n        g_ResourceInfo.OnResourceUnregistered(hResource);\n        CGraphResource cGraphResource;\n        cGraphResource.SetHandle(hResource);\n\n        pResource->AddFlags(RES_LOAD_FAILED);\n        pResource->LoadNull();\n\n        ex.Process(_TS(\"IResourceLibrary::Reload(\") + sSavedPath + _TS(\") - \"), NO_THROW);\n    }\n\n    // Handle the dependents\n    for (set<ResHandle>::iterator it(setDependents.begin()); it != setDependents.end(); ++it)\n    {\n        IResource *pChildResource(g_ResourceManager.Get(*it));\n        if (pChildResource == nullptr)\n        {\n            Console.Warn << _T(\"Couldn't retrieve a dependant resource\") << newl;\n            continue;\n        }\n\n        // If there is no path, a Free()/Load() should handle everything,\n        // otherwise just do a standard Reload\n        if (pChildResource->GetPath().empty())\n        {\n            pChildResource->Free();\n            g_ResourceInfo.OnResourceUnregistered(hResource);\n            CGraphResource cGraphResource;\n            cGraphResource.SetHandle(hResource);\n            pChildResource->Load(pChildResource->GetIgnoreFlags(), pChildResource->GetData(), pChildResource->GetSize());\n        }\n        else\n        {\n            g_ResourceManager.Reload(*it);\n        }\n\n        pResource->AddDependent(*it);\n    }\n\n    // notify the resource watchers that this resource has been reloaded.\n    NotifyWatchers(hResource);\n\n    pResource->Reloaded();\n    return true;\n}\n\n\n/*====================\n  IResourceLibrary::LookUpName\n  ====================*/\nResHandle   IResourceLibrary::LookUpName(const tstring &sName)\n{\n    ResNameMap::iterator findit(m_mapResNames.find(sName));\n    if (findit == m_mapResNames.end())\n        return INVALID_RESOURCE;\n\n    return findit->second;\n}\n\n\n/*====================\n  IResourceLibrary::LookUpPath\n  ====================*/\nResHandle   IResourceLibrary::LookUpPath(const tstring &sPath)\n{\n    if (sPath.empty())\n        return INVALID_RESOURCE;\n\n    ResNameMap::iterator findit(m_mapResPaths.find(FileManager.SanitizePath(sPath)));\n    if (findit == m_mapResPaths.end())\n        return INVALID_RESOURCE;\n\n    return findit->second;\n}\n\n\n/*====================\n  IResourceLibrary::LookUpHandle\n  ====================*/\nIResource*  IResourceLibrary::LookUpHandle(ResHandle hResource)\n{\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            throw CException(_T(\"Handle is of wrong type\"), E_ERROR);\n\n        MaskType(hResource);\n\n        assert(hResource < m_vEntries.size());\n        if (hResource >= m_vEntries.size())\n            return nullptr;\n\n        // resource has been unregistered.\n        if (!m_vEntries[hResource])\n            return nullptr;\n\n        return m_vEntries[hResource];\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary(\") + XtoA(m_uiType) + _T(\")::LookUpHandle(\") + XtoA(hResource, 0, 0, 16) + _T(\") - \"), NO_THROW);\n        return nullptr;\n    }\n}\n\n\n/*====================\n  IResourceLibrary::Get\n  ====================*/\nIResource*  IResourceLibrary::Get(ResHandle hResource)\n{\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            throw CException(_T(\"Handle is of wrong type\"), E_ERROR);\n\n        MaskType(hResource);\n\n        if (hResource >= m_vEntries.size())\n            throw CException(_T(\"Handle out of range\"), E_ERROR);\n\n        if (!m_vEntries[hResource])\n            throw CException(_T(\"Handle has been unregistered\"), E_ERROR);\n\n        return m_vEntries[hResource];\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary(\") + XtoA(m_uiType) + _T(\")::Get(\") + XtoA(hResource, 0, 0, 16) + _T(\") - \"), NO_THROW);\n        return nullptr;\n    }\n}\n\n\n/*====================\n  IResourceLibrary::ReloadAll\n  ====================*/\nvoid    IResourceLibrary::ReloadAll()\n{\n    if (m_uiType == RES_FONTMAP)\n    {\n        for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n            (*it)->Free();\n    }\n\n    if (host_vidDriver.IsModified())\n    {\n        for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n            Reload((*it)->GetHandle(), 0xffffffff);\n    }\n    else if (m_uiType == RES_MODEL)\n    {\n        class CReloadFunctions : public CLoadJob<ResPtrVec>::IFunctions\n        {\n        private:\n            IResourceLibrary*   m_pLib;\n    \n        public:\n            CReloadFunctions(IResourceLibrary *pLib) : m_pLib(pLib) {}\n            virtual ~CReloadFunctions() {}\n            \n            float   Frame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib == nullptr)\n                    return 0.0f;\n                SetTitle(_T(\"Reloading \") + m_pLib->GetName());\n                SetProgress(f);\n                return 0.0f;\n            }\n            \n            float   PostFrame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib != nullptr && *it != nullptr)\n                {\n                    m_pLib->Reload((*it)->GetHandle(), 0xffffffff);\n\n                    g_ResourceManager.PrecacheSkin((*it)->GetHandle(), uint(-1));\n                }\n                ++it;\n                return 1.0f;\n            }\n        };\n        class CReloadFunctions fnReload(this);\n        CLoadJob<ResPtrVec> jobReload(m_vEntries, &fnReload, LOADING_DISPLAY_LOGO);\n        jobReload.Execute(m_vEntries.size());\n    }\n    else\n    {\n        class CReloadFunctions : public CLoadJob<ResPtrVec>::IFunctions\n        {\n        private:\n            IResourceLibrary*   m_pLib;\n    \n        public:\n            CReloadFunctions(IResourceLibrary *pLib) : m_pLib(pLib) {}\n            virtual ~CReloadFunctions() {}\n            \n            float   Frame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib == nullptr)\n                    return 0.0f;\n                SetTitle(_T(\"Reloading \") + m_pLib->GetName());\n                SetProgress(f);\n                return 0.0f;\n            }\n            \n            float   PostFrame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib != nullptr && *it != nullptr)\n                    m_pLib->Reload((*it)->GetHandle(), 0xffffffff);\n                ++it;\n                return 1.0f;\n            }\n        };\n        class CReloadFunctions fnReload(this);\n        CLoadJob<ResPtrVec> jobReload(m_vEntries, &fnReload, LOADING_DISPLAY_LOGO);\n        jobReload.Execute(m_vEntries.size());\n    }\n}\n\n\n/*====================\n  IResourceLibrary::FreeAll\n  ====================*/\nvoid    IResourceLibrary::FreeAll()\n{\n    // TODO: Make sure this plays nicely with the resource graphing.\n    assert(m_uiType == RES_SAMPLE);\n    for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n        (*it)->Free();\n}\n\n\n/*====================\n  IResourceLibrary::FindResources\n  ====================*/\nuint    IResourceLibrary::FindResources(ResPtrVec &vResults, const tstring &sWildcard)\n{\n    uint uiTotal(0);\n\n    for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n    {\n        IResource* pResource(*it);\n        if (pResource == nullptr)\n            continue;\n\n        // skip invalid resources.\n        ResHandle hRes(pResource->GetHandle());\n        if (hRes == INVALID_RESOURCE)\n            continue;\n\n        const tstring &sPath(pResource->GetPath());\n        const tstring &sName(pResource->GetName());\n\n        // match the wildcard against the resource path or name.\n        if (!EqualsWildcards(sWildcard, sPath) &&\n            !EqualsWildcards(sWildcard, sName))\n        {\n            continue;\n        }\n\n        vResults.push_back(pResource);\n        ++uiTotal;\n    }\n\n    return uiTotal;\n}\n\n\n/*====================\n  IResourceLibrary::RemoveResourceWatcher\n  ====================*/\nvoid    IResourceLibrary::RemoveResourceWatcher(IResourceWatcher* pWatcher, ResHandle hUnregisterFrom)\n{\n    if (pWatcher == nullptr || hUnregisterFrom == INVALID_RESOURCE)\n        return;\n\n    ResHandle hIdx(hUnregisterFrom);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hUnregisterFrom) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::RemoveResourceWatcher(IResourceWatcher*, \") + XtoA(hUnregisterFrom) + _TS(\") - \"), NO_THROW);\n        return;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    assert(itFind != m_mapWatchers.end());\n    if (itFind == m_mapWatchers.end())\n        return;\n\n    ResourceWatcherSet& setWatchers(itFind->second);\n\n    // if the watcher was already removed, we're done.\n    if (setWatchers.find(pWatcher) == setWatchers.end())\n        return;\n\n    setWatchers.erase(pWatcher);\n\n    assert(pWatcher->HasAddedWatcher());\n    pWatcher->ClearHasAddedWatcher();\n\n    if (setWatchers.empty())\n        m_mapWatchers.erase(itFind);\n}\n\n\n/*====================\n  IResourceLibrary::AddResourceWatcher\n  ====================*/\nvoid    IResourceLibrary::AddResourceWatcher(IResourceWatcher* pWatcher, ResHandle hRegisterWith)\n{\n    if (pWatcher == nullptr || hRegisterWith == INVALID_RESOURCE)\n        return;\n\n    ResHandle hIdx(hRegisterWith);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hRegisterWith) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::AddResourceWatcher(IResourceWatcher*, \") + XtoA(hRegisterWith) + _TS(\") - \"), NO_THROW);\n        return;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    if (itFind == m_mapWatchers.end())\n        itFind = m_mapWatchers.insert(std::make_pair(hIdx, ResourceWatcherSet())).first;\n\n    ResourceWatcherSet& setWatchers(itFind->second);\n\n    // if the watcher was already added, we're done.\n    if (setWatchers.find(pWatcher) != setWatchers.end())\n        return;\n\n    // verify that the dependent hasn't already added a watcher.\n    assert(!pWatcher->HasAddedWatcher());\n    if (pWatcher->HasAddedWatcher())\n        Console.Err << _T(\"PROGRAMMER ERROR: IResourceWatcher has added multiple watchers!\") << newl;\n\n    // register the watcher.\n    pWatcher->MarkHasAddedWatcher();\n    setWatchers.insert(pWatcher);\n}\n\n\n/*====================\n  IResourceLibrary::HasResourceWatcher\n  ====================*/\nbool    IResourceLibrary::HasResourceWatcher(ResHandle hResource)\n{\n    if (hResource == INVALID_RESOURCE)\n        return false;\n\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::HasResourceWatcher(IResourceWatcher*, \") + XtoA(hResource) + _TS(\") - \"), NO_THROW);\n        return false;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    if (itFind == m_mapWatchers.end())\n        return false;\n\n    return true;\n}\n\n\n/*====================\n  IResourceLibrary::NotifyWatchers\n  ====================*/\nuint    IResourceLibrary::NotifyWatchers(ResHandle hResource)\n{\n    if (hResource == INVALID_RESOURCE)\n        return 0;\n\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::HasResourceWatcher(IResourceWatcher*, \") + XtoA(hResource) + _TS(\") - \"), NO_THROW);\n        return 0;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    if (itFind == m_mapWatchers.end())\n        return 0;\n\n    uint uiNotifiedCount(0);\n\n    // since the set of watchers could change as they get rebuilt, copy them.\n    ResourceWatcherSet setWatchers(itFind->second);\n    for (ResourceWatcherSet::const_iterator it(setWatchers.begin()); it != setWatchers.end(); ++it)\n    {\n        IResourceWatcher* pWatcher(*it);\n        pWatcher->Rebuild(hResource);\n    }\n\n    return uiNotifiedCount;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resourcelibrary.cpp b/src/k2/i_resourcelibrary.cpp
--- a/src/k2/i_resourcelibrary.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/i_resourcelibrary.cpp	(date 1684978300601)
@@ -486,8 +486,7 @@
             // External resources with valid paths set should just Free+Load
             pResource->Free();
             g_ResourceInfo.OnResourceUnregistered(hResource);
-            CGraphResource cGraphResource;
-            cGraphResource.SetHandle(hResource);
+            CGraphResource cGraphResource(hResource);
             pResource->Load(pResource->GetIgnoreFlags() & uiIgnoreFlags, pResource->GetData(), pResource->GetSize());
         }
         else
@@ -505,8 +504,7 @@
     catch (CException &ex)
     {
         g_ResourceInfo.OnResourceUnregistered(hResource);
-        CGraphResource cGraphResource;
-        cGraphResource.SetHandle(hResource);
+        CGraphResource cGraphResource(hResource);
 
         pResource->AddFlags(RES_LOAD_FAILED);
         pResource->LoadNull();
@@ -515,9 +513,9 @@
     }
 
     // Handle the dependents
-    for (set<ResHandle>::iterator it(setDependents.begin()); it != setDependents.end(); ++it)
+    for (ResHandle hDependent : setDependents)
     {
-        IResource *pChildResource(g_ResourceManager.Get(*it));
+        IResource *pChildResource(g_ResourceManager.Get(hDependent));
         if (pChildResource == nullptr)
         {
             Console.Warn << _T("Couldn't retrieve a dependant resource") << newl;
@@ -530,16 +528,15 @@
         {
             pChildResource->Free();
             g_ResourceInfo.OnResourceUnregistered(hResource);
-            CGraphResource cGraphResource;
-            cGraphResource.SetHandle(hResource);
+            CGraphResource cGraphResource(hResource);
             pChildResource->Load(pChildResource->GetIgnoreFlags(), pChildResource->GetData(), pChildResource->GetSize());
         }
         else
         {
-            g_ResourceManager.Reload(*it);
+            g_ResourceManager.Reload(hDependent);
         }
 
-        pResource->AddDependent(*it);
+        pResource->AddDependent(hDependent);
     }
 
     // notify the resource watchers that this resource has been reloaded.
@@ -809,8 +806,8 @@
 
     setWatchers.erase(pWatcher);
 
-    assert(pWatcher->HasAddedWatcher());
-    pWatcher->ClearHasAddedWatcher();
+    assert(pWatcher->HasAddedWatcher(hUnregisterFrom));
+    pWatcher->ClearHasAddedWatcher(hUnregisterFrom);
 
     if (setWatchers.empty())
         m_mapWatchers.erase(itFind);
@@ -852,12 +849,12 @@
         return;
 
     // verify that the dependent hasn't already added a watcher.
-    assert(!pWatcher->HasAddedWatcher());
-    if (pWatcher->HasAddedWatcher())
+    assert(!pWatcher->HasAddedWatcher(hRegisterWith));
+    if (pWatcher->HasAddedWatcher(hRegisterWith))
         Console.Err << _T("PROGRAMMER ERROR: IResourceWatcher has added multiple watchers!") << newl;
 
     // register the watcher.
-    pWatcher->MarkHasAddedWatcher();
+    pWatcher->MarkHasAddedWatcher(hRegisterWith);
     setWatchers.insert(pWatcher);
 }
 
Index: src/k2/c_resourceinfo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2010 S2 Games\n// c_resourceinfo.h\n//\n//=============================================================================\n#ifndef __C_RESOURCEINFO_H__\n#define __C_RESOURCEINFO_H__\n\n//=============================================================================\n// Headers\n//=============================================================================\n//=============================================================================\n\n//=============================================================================\n// Resource Context Macros\n//=============================================================================\n\n// activate a resource context for the remainder of the current scope.\n#define K2_RESOURCE_CONTEXT(sResourceContextName)                                                   \\\n    CResourceScope  K2_PP_CAT(cActivateResContext_, __LINE__)(sResourceContextName)\n\n// creates a new scope, then activates a resource context for the duration of that scope.\n#define K2_WITH_RESOURCE_SCOPE(sResourceContextName)                                                \\\n    if (const CResourceScope& K2_PP_CAT(cActivateResContext_, __LINE__) = CResourceScope(sResourceContextName))\n\n// game scope.\n#define K2_GAME_RESOURCE_CONTEXT()                  K2_RESOURCE_CONTEXT(g_ResourceInfo.GetGameContext())\n#define K2_WITH_GAME_RESOURCE_SCOPE()               K2_WITH_RESOURCE_SCOPE(g_ResourceInfo.GetGameContext())\n\n// global scope.\n#define K2_GLOBAL_RESOURCE_CONTEXT()                K2_RESOURCE_CONTEXT(_T(\"global\"))\n#define K2_WITH_GLOBAL_RESOURCE_SCOPE()             K2_WITH_RESOURCE_SCOPE(_T(\"global\"))\n//=============================================================================\n\n//=============================================================================\n// Declarations\n//=============================================================================\nextern K2_API class CResourceInfo& g_ResourceInfo;\n\nclass CGraphResource;\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\ntypedef hash_set<ResHandle>     ResourceSet;\ntypedef uint                    ResCtx;\n//=============================================================================\n\n//=============================================================================\n// CGraphResource\n//=============================================================================\nclass CGraphResource\n{\nprivate:\n    static CGraphResource*  s_pCurrentParent;\n\n    // for debugging purposes only.\n#ifdef _DEBUG\n    tstring             m_sPath;\n#endif\n\n    CGraphResource*     m_pPrevParent;\n    ResourceSet         m_setChildren;\n    ResHandle           m_hResource;\n    bool                m_bValid;\n    bool                m_bDone;\n    bool                m_bLinking;\n\npublic:\n    ~CGraphResource();\n    CGraphResource();\n\n    // for debugging purposes only.\n    void            SetDebugPath(const tstring &sPath);\n\n    void            SetHandle(ResHandle hResource);\n    void            LinkChildren(ResHandle hResource);\n\n    void            Reset();\n    void            Cancel();\n    void            Done();\n\n    static void     LinkExistingChild(ResHandle hResource);\n};\n//=============================================================================\n\n//=============================================================================\n// CResourceInfo\n//=============================================================================\nclass CResourceInfo\n{\nprivate:\n    SINGLETON_DEF(CResourceInfo)\n\n    //*********************\n    // Friend Classes\n    //*********************\n\n    friend class CResourceScope;\n\n    //*********************\n    // Private Declarations\n    //*********************\n\n    struct SResInfo;\n    struct SResContext;\n    class IResourceGraphIterator;\n\n    //*********************\n    // Private Definitions\n    //*********************\n\n    static const uint RI_TOPLEVEL   = BIT(0);\n    static const uint RI_ORPAHNED   = BIT(1);\n    static const uint RI_TOUCHED    = BIT(2);\n    static const uint RI_MATCHED    = BIT(3);\n    static const uint RI_RELEVANT   = BIT(4);\n\n    typedef pair<IResource*, SResInfo*>     ResInfoPair;\n    typedef vector<ResInfoPair>             ResInfoStack;\n    typedef hash_map<tstring, bool>         ResCategoryLoadMap;\n\n    //*********************\n    // Internal Interfaces\n    //*********************\n\n    // CGraphResource\n    friend class CGraphResource;\n    SResInfo*           InfoAlloc(ResHandle hRes);\n    void                InfoFree(ResHandle hRes);\n    void                InfoClearChildren(ResHandle hRes);\n    void                InfoAddChildren(ResHandle hRes, const ResourceSet& setChildren);\n    void                InfoAddToActiveContext(ResHandle hRes);\n\n    // CResourceManager\n    friend class CResourceManager;\n    void                OnResourceUnregistered(ResHandle hRes);\n\n    //*********************\n    // Private Definitions\n    //*********************\n\n    // SResInfo\n    struct SResInfo\n    {\n        ResourceSet     setChildren;\n        uint            uiFlags;\n\n        SResInfo()\n            : uiFlags(0)\n        {}\n\n        bool            HasFlags(uint uiInfoFlags) const    { return (this->uiFlags & uiInfoFlags) != 0; }\n        void            ClearFlags(uint uiInfoFlags)        { this->uiFlags &= ~uiInfoFlags; }\n        void            SetFlags(uint uiInfoFlags)          { this->uiFlags |= uiInfoFlags; }\n    };\n    typedef hash_map<ResHandle, SResInfo>       ResInfoMap;\n\n    // SResContext\n    struct SResContext\n    {\n        ResourceSet     setToplevelResources;\n        int             iActivationCount;\n        bool            bDelete;\n\n        SResContext()\n            : iActivationCount(0)\n            , bDelete(false)\n        {}\n    };\n    typedef hash_map<tstring, SResContext>      ResContextMap;\n    typedef vector<ResContextMap::iterator>     ResContextStack;\n\n    // IResourceGraphIterator\n    class IResourceGraphIterator\n    {\n        friend class CResourceInfo;\n        void DoResource(ResInfoStack& stkParents, uint uiDepth, IResource* pRes, SResInfo* pInfo);\n\n    public:\n        virtual void IterateResource(const ResInfoStack& stkParents, uint uiDepth, IResource* pRes, SResInfo* pInfo)=0;\n    };\n    void                IterateToplevel(const IResourceGraphIterator& pIterator);\n    void                IterateContext(const IResourceGraphIterator& pIterator, const tstring &sCtxName, SResContext* pCtx);\n\n    //*********************\n    // Member Variables\n    //*********************\n\n    ResInfoMap          m_mapResInfo;\n    ResContextMap       m_mapResContexts;\n    ResContextStack     m_stkPushedContexts;\n    ResCategoryLoadMap  m_mapResCategoriesLoaded;\n\n    // the current game resource division: 'client' or 'server'\n    tstring             m_sGameContextDivision;\n    \n    // the current game resource category: 'world' or 'hero'\n    tstring             m_sGameContextCategory;\n\n    // the current game resource context.\n    mutable tstring     m_sGameContext;\n    mutable bool        m_bGameContextDirty;\n\n    // whether the game context is enabled.\n    bool                m_bGameContextEnabled;\n\n    //*********************\n    // Private Methods\n    //*********************\n\n    SResInfo*           LookupInfo(ResHandle hRes, bool bAllocate = false);\n    SResContext*        LookupContext(const tstring &sCtxName, bool bAllocate = false);\n    uint                DeleteContext(const ResContextMap::iterator& itContext);\n\n    //*********************\n    // Public Interface\n    //*********************\npublic:\n    ~CResourceInfo();\n\n    // resource context methods.\n    void                ActivateContextPushTop(const tstring &sCtxName);\n    bool                DeactivateContextPopTop(const tstring &sVerifyCtxName);\n\n    K2_API uint         DeleteContext(const tstring &sCtxName);\n    // DeleteContext returns one of the following:\n    static const uint   RESCTX_DELETED                  = 1; // the specified context was deleted.\n    static const uint   RESCTX_SCHEDULED_FOR_DELETION   = 2; // the specified context is currently active, and will be deleted when it goes inactive.\n    static const uint   RESCTX_ALREADY_DELETING         = 3; // the specified context is currently active, and was already scheduled for deletion when it goes inactive.\n    // (a return value of 0 means \"failed to delete the specified context\")\n\n    // resource graph methods.\n    void                CalcOrphanedResources();\n\n    // printing.\n    K2_API void         PrintContext(CConsoleStream& cStream, const tstring &sCtxName, const tstring &sWildcardChildren = _T(\"*\"), SResContext* pCtx = nullptr);\n\n    // various console commands.\n    K2_API bool         ExecCommand(const tstring &sCommand, const tsvector& vArgs = tsvector());\n    K2_API bool         ExecCommandLine(const tstring &sCommandLine);\n\n    // game resource context methods.\n    K2_API bool             GetGameContextEnabled() const                       { return m_bGameContextEnabled; }\n    K2_API void             SetGameContextEnabled(bool bEnabled)                { if (bEnabled != m_bGameContextEnabled) { m_bGameContextEnabled = bEnabled; m_bGameContextDirty = true; } }\n    //      the current game resource division: 'client' or 'server'\n    K2_API const tstring&   GetGameContextDivision() const                      { return m_sGameContextDivision; }\n    K2_API void             SetGameContextDivision(const tstring &sCur)         { if (m_sGameContextDivision != sCur) { m_sGameContextDivision = sCur; m_bGameContextDirty = true; } }\n    //      the current game resource category: 'world' or 'hero'\n    K2_API const tstring&   GetGameContextCategory() const                      { return m_sGameContextCategory; }\n    K2_API void             SetGameContextCategory(const tstring &sCur)         { if (m_sGameContextCategory != sCur) { m_sGameContextCategory = sCur; m_bGameContextDirty = true; } }\n    K2_API void             SetGameContextCategoryLoaded(const tstring &sCur, bool bSet)    { m_mapResCategoriesLoaded[sCur] = bSet; }\n    K2_API bool             WasGameContextCategoryLoaded(const tstring &sCur)   { if (m_mapResCategoriesLoaded.find(sCur) == m_mapResCategoriesLoaded.end()) { return false; } return m_mapResCategoriesLoaded[sCur]; }\n    //      the current game resource context.\n    K2_API const tstring&   GetGameContext() const;\n};\n//=============================================================================\n\n\n/*====================\n  CResourceInfo::GetGameContext\n  ====================*/\ninline\nconst tstring&  CResourceInfo::GetGameContext() const\n{\n    if (m_bGameContextDirty)\n    {\n        if (m_bGameContextEnabled)\n            m_sGameContext = m_sGameContextDivision + _T(\":curgame_\") + m_sGameContextCategory;\n        else\n            m_sGameContext = _T(\"global\");\n        m_bGameContextDirty = false;\n    }\n    return m_sGameContext;\n}\n\n\n//=============================================================================\n// CResourceScope\n//\n//  a helper object.  Its constructor activates the specified context (creating\n//  it if necessary), and its destructor deactivates that context.\n//=============================================================================\nclass CResourceScope\n{\nprivate:\n    CResourceInfo::ResContextMap::iterator      m_itContext;\n\npublic:\n    CResourceScope(const tstring &sResourceContextName)\n    {\n        assert(!sResourceContextName.empty());\n        assert(sResourceContextName.find(_T(\" \")) == tstring::npos);\n\n        g_ResourceInfo.ExecCommandLine(_TS(\"context push \") + sResourceContextName);\n        m_itContext = g_ResourceInfo.m_mapResContexts.find(sResourceContextName);\n        assert(m_itContext != g_ResourceInfo.m_mapResContexts.end());\n    }\n\n    ~CResourceScope()\n    {\n        if (m_itContext == g_ResourceInfo.m_mapResContexts.end())\n            return;\n\n        const tstring &sCtxName(m_itContext->first);\n        g_ResourceInfo.ExecCommandLine(_TS(\"context pop \") + sCtxName);\n    }\n\n    // this is necessary for the following usage:\n    //\n    //      if (CResourceScope cScope)\n    //\n    // in other words, this allows if-statement-scoping, which is common\n    // for certain macros.\n    operator bool() const       { return true; }\n};\n//=============================================================================\n\n#endif //__C_RESOURCEINFO_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_resourceinfo.h b/src/k2/c_resourceinfo.h
--- a/src/k2/c_resourceinfo.h	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_resourceinfo.h	(date 1684979187922)
@@ -59,16 +59,17 @@
     tstring             m_sPath;
 #endif
 
-    CGraphResource*     m_pPrevParent;
+    CGraphResource*     m_pPrevParent = nullptr;
     ResourceSet         m_setChildren;
-    ResHandle           m_hResource;
-    bool                m_bValid;
-    bool                m_bDone;
-    bool                m_bLinking;
+    ResHandle           m_hResource = INVALID_RESOURCE;
+    bool                m_bValid = true;
+    bool                m_bDone = false;
+    bool                m_bLinking = false;
 
 public:
     ~CGraphResource();
     CGraphResource();
+    explicit CGraphResource(ResHandle hResource);
 
     // for debugging purposes only.
     void            SetDebugPath(const tstring &sPath);
@@ -112,9 +113,8 @@
 
     static const uint RI_TOPLEVEL   = BIT(0);
     static const uint RI_ORPAHNED   = BIT(1);
-    static const uint RI_TOUCHED    = BIT(2);
-    static const uint RI_MATCHED    = BIT(3);
-    static const uint RI_RELEVANT   = BIT(4);
+    static const uint RI_MATCHED    = BIT(2);
+    static const uint RI_RELEVANT   = BIT(3);
 
     typedef pair<IResource*, SResInfo*>     ResInfoPair;
     typedef vector<ResInfoPair>             ResInfoStack;
@@ -287,10 +287,12 @@
     CResourceInfo::ResContextMap::iterator      m_itContext;
 
 public:
-    CResourceScope(const tstring &sResourceContextName)
+    CResourceScope() = delete;
+
+    explicit CResourceScope(const tstring &sResourceContextName)
     {
         assert(!sResourceContextName.empty());
-        assert(sResourceContextName.find(_T(" ")) == tstring::npos);
+        assert(sResourceContextName.find(_T(' ')) == tstring::npos);
 
         g_ResourceInfo.ExecCommandLine(_TS("context push ") + sResourceContextName);
         m_itContext = g_ResourceInfo.m_mapResContexts.find(sResourceContextName);
Index: src/k2/c_resourceinfo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2010 S2 Games\n// c_resourceinfo.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_resourceinfo.h\"\n#include \"c_resourcemanager.h\"\n#include \"i_resourcelibrary.h\"\n#include \"i_resource.h\"\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nCResourceInfo&  g_ResourceInfo(*CResourceInfo::GetInstance());\n\nSINGLETON_INIT(CResourceInfo)\n\nCVAR_BOOL(res_debugContext, false);\n//=============================================================================\n\n//=============================================================================\n// Private Macros\n//=============================================================================\n\n/*====================\n  ForEachResInfo\n  ====================*/\n#define ForEachResInfo(resPtrDecl, infoPtrDecl)                                                     \\\n    for (auto &&[FOREACH_hResource, FOREACH_sResInfo] : m_mapResInfo)                               \\\n        if (resPtrDecl = g_ResourceManager.LookUpHandle(FOREACH_hResource))                         \\\n            if (infoPtrDecl = &FOREACH_sResInfo)\n\n\n/*====================\n  ForEachResChain\n  ====================*/\n#define ForEachResChain(stkParentsDecl, depthDecl, resPtrDecl, infoPtrDecl)                         \\\n    do                                                                                              \\\n    {                                                                                               \\\n        class FOREACH_Iterator : public IResourceGraphIterator                                      \\\n        {                                                                                           \\\n            void    IterateResource(stkParentsDecl, depthDecl, resPtrDecl, infoPtrDecl)             \\\n\n#define ForEachResChainEnd_DoAllToplevel()                                                          \\\n        };                                                                                          \\\n        IterateToplevel(FOREACH_Iterator());                                                        \\\n    } while (0)\n#define ForEachResChainEnd_DoContext(sCtxName, pCurCtx)                                             \\\n        };                                                                                          \\\n        IterateContext(FOREACH_Iterator(), sCtxName, pCurCtx);                                      \\\n    } while (0)\n\n#define ForEachResChain_ForEachParent(stkParents, resPtrDecl, infoPtrDecl)                          \\\n    for (ResInfoStack::const_reverse_iterator                                                       \\\n        FORPARENT_it((stkParents).rbegin()),                                                        \\\n        FORPARENT_itEnd((stkParents).rend());                                                       \\\n        FORPARENT_it != FORPARENT_itEnd;                                                            \\\n        ++FORPARENT_it)                                                                             \\\n        if (resPtrDecl = (*FORPARENT_it).first)                                                     \\\n            if (infoPtrDecl = (*FORPARENT_it).second)\n\n\n/*====================\n  ForEachResInfo\n  ====================*/\n#define ForEachResHandle(resContainerType, resContainer, resPtrDecl, infoPtrDecl)                   \\\n    for (const auto& FOREACH_res : resContainer)                                                    \\\n        if (resPtrDecl = g_ResourceManager.LookUpHandle(FOREACH_res))                               \\\n            if (infoPtrDecl = g_ResourceInfo.LookupInfo(FOREACH_res))\n\n\n/*====================\n  ForEachResContext\n  ====================*/\n#define ForEachResContext(resCtxNamePtrDecl, resCtxPtrDecl)                                         \\\n    for (ResContextMap::iterator                                                                    \\\n        FOREACH_it(g_ResourceInfo.m_mapResContexts.begin()),                                        \\\n        FOREACH_itEnd(g_ResourceInfo.m_mapResContexts.end());                                       \\\n        FOREACH_it != FOREACH_itEnd;                                                                \\\n        ++FOREACH_it)                                                                               \\\n        if (resCtxNamePtrDecl = &(*FOREACH_it).first)                                               \\\n            if (resCtxPtrDecl = &(*FOREACH_it).second)\n\n//=============================================================================\n\n//=============================================================================\n// CGraphResource\n//=============================================================================\nCGraphResource*     CGraphResource::s_pCurrentParent;\n\n/*====================\n  CGraphResource::~CGraphResource\n  ====================*/\nCGraphResource::~CGraphResource()\n{\n    Done();\n}\n\n/*====================\n  CGraphResource::CGraphResource\n  ====================*/\nCGraphResource::CGraphResource()\n: m_pPrevParent(nullptr)\n, m_hResource(INVALID_RESOURCE)\n, m_bValid(true)\n, m_bDone(false)\n, m_bLinking(false)\n{\n    // store the current parent.\n    m_pPrevParent = s_pCurrentParent;\n    \n    // make ourselves the current parent.\n    s_pCurrentParent = this;\n}\n\n\n/*====================\n  CGraphResource::SetDebugPath\n  ====================*/\nvoid    CGraphResource::SetDebugPath(const tstring &sPath)\n{\n#ifdef _DEBUG\n    m_sPath = sPath;\n#endif\n}\n\n\n/*====================\n CGraphResource::SetHandle\n ====================*/\nvoid    CGraphResource::SetHandle(ResHandle hResource)\n{\n    m_hResource = hResource;\n}\n\n\n/*====================\n  CGraphResource::LinkChildren\n  ====================*/\nvoid    CGraphResource::LinkChildren(ResHandle hResource)\n{\n    if (hResource == INVALID_RESOURCE)\n        return;\n\n    SetHandle(hResource);\n    m_bLinking = true;\n}\n\n\n/*====================\n  CGraphResource::Reset\n  ====================*/\nvoid    CGraphResource::Reset()\n{\n    m_setChildren.clear();\n}\n\n\n/*====================\n CGraphResource::Cancel\n ====================*/\nvoid    CGraphResource::Cancel()\n{\n    m_bValid = false;\n    m_setChildren.clear();\n}\n\n\n/*====================\n  CGraphResource::Done\n  ====================*/\nvoid    CGraphResource::Done()\n{\n    if (m_bDone)\n        return;\n    m_bDone = true;\n\n    // restore the previous parent.\n    s_pCurrentParent = m_pPrevParent;\n\n    // if we were canceled or our handle is invalid, then do nothing.\n    if (!m_bValid || m_hResource == INVALID_RESOURCE)\n        return;\n\n    bool bIsToplevel(false);\n    if (s_pCurrentParent == nullptr)\n        bIsToplevel = true;\n    if (m_bLinking)\n        bIsToplevel = false;\n\n    // verify that our own handle was not somehow added to our list of children.\n    for (ResourceSet::iterator it(m_setChildren.begin()), itEnd(m_setChildren.end()); it != itEnd;)\n    {\n        ResHandle hChild(*it);\n        assert(hChild != INVALID_RESOURCE);\n\n        assert(hChild != m_hResource);\n        if (hChild == m_hResource)\n            m_setChildren.erase(it++);\n        else\n            ++it;\n    }\n\n    CResourceInfo::SResInfo* pInfo(g_ResourceInfo.InfoAlloc(m_hResource));\n\n    // update our stored list of child resources.\n    //g_ResourceInfo.InfoClearChildren(m_hResource, m_setChildren);\n    g_ResourceInfo.InfoAddChildren(m_hResource, m_setChildren);\n\n    // don't add ourselves to the parent if we were just linking children to a handle.\n    if (!m_bLinking)\n    {\n        // add our handle as a child of the parent resource.\n        if (s_pCurrentParent != nullptr)\n            s_pCurrentParent->m_setChildren.insert(m_hResource);\n\n        // add to the active context.\n        if (bIsToplevel)\n        {\n            pInfo->SetFlags(CResourceInfo::RI_TOPLEVEL);\n            g_ResourceInfo.InfoAddToActiveContext(m_hResource);\n        }\n    }\n}\n\n\n/*====================\n  CGraphResource::LinkExistingChild\n  ====================*/\nvoid    CGraphResource::LinkExistingChild(ResHandle hResource)\n{\n    assert(hResource != INVALID_RESOURCE);\n    if (hResource == INVALID_RESOURCE)\n        return;\n\n    if (s_pCurrentParent == nullptr)\n    {\n        g_ResourceInfo.InfoAddToActiveContext(hResource);\n        return;\n    }\n\n    s_pCurrentParent->m_setChildren.insert(hResource);\n}\n//=============================================================================\n\n\n//=============================================================================\n// CResourceInfo\n//=============================================================================\n\n/*====================\n  CResourceInfo::InfoAlloc\n  ====================*/\nCResourceInfo::SResInfo*    CResourceInfo::InfoAlloc(ResHandle hRes)\n{\n    assert(hRes != INVALID_RESOURCE);\n    if (hRes == INVALID_RESOURCE)\n        return nullptr;\n\n    return &m_mapResInfo[hRes];\n}\n\n\n/*====================\n  CResourceInfo::InfoFree\n  ====================*/\nvoid    CResourceInfo::InfoFree(ResHandle hRes)\n{\n    ResInfoMap::iterator itFind(m_mapResInfo.find(hRes));\n    assert(itFind != m_mapResInfo.end());\n    if (itFind == m_mapResInfo.end())\n        return;\n\n    m_mapResInfo.erase(itFind);\n}\n\n\n/*====================\n  CResourceInfo::InfoClearChildren\n  ====================*/\nvoid    CResourceInfo::InfoClearChildren(ResHandle hRes)\n{\n    SResInfo* pInfo(LookupInfo(hRes));\n    assert(pInfo != nullptr);\n    if (pInfo == nullptr)\n        return;\n\n    pInfo->setChildren.clear();\n}\n\n\n/*====================\n  CResourceInfo::InfoAddChildren\n  ====================*/\nvoid    CResourceInfo::InfoAddChildren(ResHandle hRes, const ResourceSet& setChildren)\n{\n    PROFILE(\"CResourceInfo::InfoAddChildren\");\n\n    SResInfo* pInfo(LookupInfo(hRes));\n    assert(pInfo != nullptr);\n    if (pInfo == nullptr)\n        return;\n\n    // merge.\n    for (ResHandle hChild : setChildren)\n    {\n        pInfo->setChildren.insert(hChild);\n    }\n}\n\n\n/*====================\n  CResourceInfo::InfoAddToActiveContext\n  ====================*/\nvoid    CResourceInfo::InfoAddToActiveContext(ResHandle hRes)\n{\n    PROFILE(\"CResourceInfo::InfoAddToActiveContext\");\n\n    SResInfo* pInfo(LookupInfo(hRes));\n    assert(pInfo != nullptr);\n    if (pInfo == nullptr)\n        return;\n\n    assert(!m_stkPushedContexts.empty());\n    if (m_stkPushedContexts.empty())\n        return;\n\n    ResContextMap::iterator itActiveCtx     (m_stkPushedContexts.back());\n    const tstring&          sActiveCtxName  (itActiveCtx->first);\n    SResContext*            pActiveCtx      (&itActiveCtx->second);\n\n    if (pActiveCtx->setToplevelResources.insert(hRes).second && res_debugContext)\n    {\n        Console << _T(\"Protected by context '\") << sActiveCtxName << _T(\"': \");\n        g_ResourceManager.PrintResource(Console.DefaultStream(), hRes);\n        Console << newl;\n    }\n}\n\n\n/*====================\n  CResourceInfo::OnResourceUnregistered\n  ====================*/\nvoid    CResourceInfo::OnResourceUnregistered(ResHandle hRes)\n{\n    InfoFree(hRes);\n}\n\n\n/*====================\n  CResourceInfo::~CResourceInfo\n  ====================*/\nCResourceInfo::~CResourceInfo()\n{\n}\n\n\n/*====================\n  CResourceInfo::CResourceInfo\n  ====================*/\nCResourceInfo::CResourceInfo()\n: m_sGameContextDivision(_T(\"client\"))\n, m_sGameContextCategory(_T(\"world\"))\n, m_bGameContextDirty(true)\n, m_bGameContextEnabled(false)\n{\n}\n\n\n/*====================\n  CResourceInfo::IResourceGraphIterator::DoResource\n  ====================*/\nvoid    CResourceInfo::IResourceGraphIterator::DoResource(CResourceInfo::ResInfoStack& stkParents, uint uiDepth, IResource* pRes, SResInfo* pInfo)\n{\n    IterateResource(stkParents, uiDepth, pRes, pInfo);\n\n    if (!pInfo->setChildren.empty())\n    {\n        stkParents.emplace_back(std::make_pair(pRes, pInfo));\n        ++uiDepth;\n        ForEachResHandle(ResourceSet, pInfo->setChildren, IResource* pChildRes, SResInfo* pChildInfo)\n        {\n            DoResource(stkParents, uiDepth, pChildRes, pChildInfo);\n        }\n        --uiDepth;\n        stkParents.pop_back();\n    }\n}\n\n\n/*====================\n  CResourceInfo::IterateToplevel\n  ====================*/\nvoid    CResourceInfo::IterateToplevel(const IResourceGraphIterator& vIterator)\n{\n    IResourceGraphIterator* pIterator = const_cast<IResourceGraphIterator*>(&vIterator);\n    ResInfoStack stkParents;\n    ForEachResInfo(IResource* pRes, SResInfo* pInfo)\n    {\n        if (pInfo->HasFlags(RI_TOPLEVEL))\n        {\n            assert(stkParents.empty());\n            pIterator->DoResource(stkParents, 0, pRes, pInfo);\n            assert(stkParents.empty());\n        }\n    }\n}\n\n\n/*====================\n  CResourceInfo::IterateContext\n  ====================*/\nvoid    CResourceInfo::IterateContext(const IResourceGraphIterator& vIterator, const tstring &sCtxName, SResContext* pCtx)\n{\n    IResourceGraphIterator* pIterator = const_cast<IResourceGraphIterator*>(&vIterator);\n    if (pCtx == nullptr)\n        pCtx = LookupContext(sCtxName);\n\n    assert(pCtx != nullptr);\n    if (pCtx == nullptr)\n        return;\n\n    ResInfoStack stkParents;\n    ForEachResHandle(ResourceSet, pCtx->setToplevelResources,\n        IResource* pRes, SResInfo* pInfo)\n    {\n        assert(stkParents.empty());\n        pIterator->DoResource(stkParents, 0, pRes, pInfo);\n        assert(stkParents.empty());\n    }\n}\n\n\n/*====================\n  CResourceInfo::LookupInfo\n  ====================*/\nCResourceInfo::SResInfo*    CResourceInfo::LookupInfo(ResHandle hRes, bool bAllocate)\n{\n    if (hRes == INVALID_RESOURCE)\n        return nullptr;\n\n    ResInfoMap::iterator itFind(m_mapResInfo.find(hRes));\n    if (itFind == m_mapResInfo.end())\n    {\n        if (!bAllocate)\n            return nullptr;\n\n        itFind = m_mapResInfo.insert(std::make_pair(hRes, SResInfo())).first;\n    }\n\n    SResInfo& sResInfo(itFind->second);\n    return &sResInfo;\n}\n\n\n/*====================\n  CResourceInfo::LookupContext\n  ====================*/\nCResourceInfo::SResContext* CResourceInfo::LookupContext(const tstring &sCtxName, bool bAllocate)\n{\n    assert(!sCtxName.empty());\n    if (sCtxName.empty())\n        return nullptr;\n\n    ResContextMap::iterator itFind(m_mapResContexts.find(sCtxName));\n    if (itFind == m_mapResContexts.end())\n    {\n        if (!bAllocate)\n            return nullptr;\n\n        itFind = m_mapResContexts.insert(std::make_pair(sCtxName, SResContext())).first;\n    }\n\n    SResContext& sResCtx(itFind->second);\n    return &sResCtx;\n}\n\n\n/*====================\n  CResourceInfo::DeleteContext\n  ====================*/\nuint    CResourceInfo::DeleteContext(const ResContextMap::iterator& itContext)\n{\n    if (itContext == m_mapResContexts.end())\n        return false;\n\n    SResContext* pCtx(&itContext->second);\n\n    // if the context is active, then schedule the context for deletion next time it becomes inactive.\n    if (pCtx->iActivationCount > 0)\n    {\n        // already scheduled for deletion?\n        if (pCtx->bDelete)\n            return RESCTX_ALREADY_DELETING;\n\n        pCtx->bDelete = true;\n        return RESCTX_SCHEDULED_FOR_DELETION;\n    }\n\n    // delete the context.\n    m_mapResContexts.erase(itContext);\n    CalcOrphanedResources();\n    return RESCTX_DELETED;\n}\n\n\n/*====================\n  CResourceInfo::ActivateContextPushTop\n  ====================*/\nvoid    CResourceInfo::ActivateContextPushTop(const tstring &sCtxName)\n{\n    // the context name should be set!\n    assert(!sCtxName.empty());\n    if (sCtxName.empty())\n        return;\n\n    // allocate the context if necessary.\n    SResContext* pContext(LookupContext(sCtxName, true));\n    assert(pContext != nullptr);\n    if (pContext == nullptr)\n        return;\n\n    ResContextMap::iterator itFind(m_mapResContexts.find(sCtxName));\n    assert(itFind != m_mapResContexts.end());\n    if (itFind == m_mapResContexts.end())\n        return;\n\n    SResContext* pCtx(&itFind->second);\n    pCtx->iActivationCount++;\n\n    m_stkPushedContexts.push_back(itFind);\n}\n\n\n/*====================\n  CResourceInfo::DeactivateContextPopTop\n  ====================*/\nbool    CResourceInfo::DeactivateContextPopTop(const tstring &sCtxName)\n{\n    SResContext* pContext(LookupContext(sCtxName));\n    assert(pContext != nullptr);\n    if (pContext == nullptr)\n        return false;\n\n    assert(!m_stkPushedContexts.empty());\n    if (m_stkPushedContexts.empty())\n    {\n        Console.Warn << _T(\"Tried to deactivate resource context, but none were active!\") << newl;\n        return false;\n    }\n\n    ResContextMap::iterator& itActiveCtx(m_stkPushedContexts.back());\n    SResContext* pActiveCtx(&itActiveCtx->second);\n    assert(sCtxName == m_stkPushedContexts.back()->first);\n    if (sCtxName != m_stkPushedContexts.back()->first)\n    {\n        Console.Warn << _T(\"Tried to deactivate resource context '\") << sCtxName << _T(\"', but it wasn't the toplevel active context!\") << newl;\n        return false;\n    }\n\n    assert(pActiveCtx->iActivationCount > 0);\n    if (pActiveCtx->iActivationCount <= 0)\n        return false;\n\n    // deactivate the context.\n    m_stkPushedContexts.pop_back();\n    pActiveCtx->iActivationCount--;\n\n    // if the context was scheduled for deletion, and it just became inactive, then delete it.\n    if (pActiveCtx->bDelete && pActiveCtx->iActivationCount == 0)\n    {\n        if (DeleteContext(sCtxName) != RESCTX_DELETED)\n            assert(!\"programmer error\");\n    }\n    // ***WARNING***: accessing variables below this line (such as itActiveCtx, sActiveCtxName, pActiveCtx, etc)\n    // could result in a crash! (we might have deleted the context.)\n    return true;\n}\n\n\n/*====================\n  CResourceInfo::DeleteContext\n  ====================*/\nuint    CResourceInfo::DeleteContext(const tstring &sCtxName)\n{\n    ResContextMap::iterator itFind(m_mapResContexts.find(sCtxName));\n    assert(itFind != m_mapResContexts.end());\n    return DeleteContext(itFind);\n}\n\n\n/*====================\n  CResourceInfo::CalcOrphanedResources\n  ====================*/\nvoid    CResourceInfo::CalcOrphanedResources()\n{\n    PROFILE(\"CResourceInfo::CalcOrphanedResources\");\n\n    ForEachResInfo(IResource* pRes, SResInfo* pInfo)\n    {\n        pInfo->SetFlags(RI_ORPAHNED);\n    }\n\n    ForEachResContext(const tstring* sCtxName, SResContext* pCtx)\n    {\n        ForEachResChain(const ResInfoStack& stkParents, uint uiDepth, IResource* pRes, SResInfo* pInfo)\n        {\n            pInfo->ClearFlags(RI_ORPAHNED);\n        }\n        ForEachResChainEnd_DoContext(*sCtxName, pCtx);\n    }\n}\n\n\n/*====================\n  CResourceInfo::PrintContext\n  ====================*/\nvoid    CResourceInfo::PrintContext(CConsoleStream& cStream, const tstring &sCtxName, const tstring &sWildcardChildren, SResContext* pCtx)\n{\n    if (pCtx == nullptr)\n        pCtx = LookupContext(sCtxName);\n\n    if (pCtx == nullptr)\n    {\n        cStream << _T(\"^r[nullptr context]\");\n        return;\n    }\n\n    cStream << _T(\"^w[ResContext ^y\") << sCtxName << _T(\"^w] (^c\") << (uint)pCtx->setToplevelResources.size() << _T(\"^w resources) \") << newl;\n\n    if (!sWildcardChildren.empty())\n    {\n        ForEachResHandle(ResourceSet, pCtx->setToplevelResources,\n            IResource* pResource, SResInfo* pInfo)\n        {\n            if (pResource->MatchesWildcard(sWildcardChildren))\n            {\n                g_ResourceManager.PrintResource(cStream, pResource);\n                cStream << newl;\n            }\n        }\n    }\n}\n\n\n/*====================\n  CResourceInfo::ExecCommand\n  ====================*/\nbool    CResourceInfo::ExecCommand(const tstring &sCommand, const tsvector& vArgs)\n{\n    PROFILE(\"CResourceInfo::ExecCommand\");\n\n    //*********************\n    // ResourceCmdEx graph\n    //*********************\n    if (sCommand == _T(\"graph\"))\n    {\n        if (vArgs.empty())\n        {\n            Console << _T(\"^r'ResourceCmdEx graph' command failed (not enough args): specify a graph command.\") << newl;\n            return false;\n        }\n        const tstring &sGraphCmd(vArgs[0]);\n\n        if (sGraphCmd == _T(\"list\"))\n        {\n            tstring sWild(_T(\"*\"));\n            if (vArgs.size() >= 2)\n                sWild = vArgs[1];\n\n            ForEachResInfo(IResource* pRes, SResInfo* pInfo)\n            {\n                pInfo->ClearFlags(RI_RELEVANT | RI_MATCHED);\n                if (pRes->MatchesWildcard(sWild))\n                    pInfo->SetFlags(RI_MATCHED);\n            }\n\n            ForEachResChain(const ResInfoStack& stkParents, uint uiDepth, IResource* pRes, SResInfo* pInfo)\n            {\n                if (!pInfo->HasFlags(RI_MATCHED))\n                    return;\n\n                pInfo->SetFlags(RI_RELEVANT);\n                ForEachResChain_ForEachParent(stkParents, IResource* pParentRes, SResInfo* pParentInfo)\n                {\n                    pParentInfo->SetFlags(RI_RELEVANT);\n                }\n            }\n            ForEachResChainEnd_DoAllToplevel();\n\n            ForEachResChain(const ResInfoStack& stkParents, uint uiDepth, IResource* pRes, SResInfo* pInfo)\n            {\n                bool bMatched(pInfo->HasFlags(RI_MATCHED));\n\n                if (!pInfo->HasFlags(RI_MATCHED))\n                    if (!pInfo->HasFlags(RI_RELEVANT))\n                        return;\n\n                CConsoleStream& cStream(Console.DefaultStream());\n\n                if (uiDepth == 0)\n                    cStream << newl;\n\n                if (bMatched)\n                    cStream << _T(\"^m\");\n                else\n                    cStream << _T(\"^v\");\n\n                // print the indentation.\n                if (uiDepth == 0)\n                    cStream << _T(\"> \");\n                else\n                {\n                    cStream << _T(\"  \");\n                    for (uint i(0); i < uiDepth; ++i)\n                    {\n                        cStream << _T(\"* \");\n                    }\n                }\n\n                // print the resource.\n                g_ResourceManager.PrintResource(cStream, pRes,\n                    false, \n                    (bMatched ? nullptr : _T(\"^v\")));\n                cStream << newl;\n            }\n            ForEachResChainEnd_DoAllToplevel();\n\n            return true;\n        }\n\n        Console << _T(\"^r'ResourceCmdEx graph \") << sGraphCmd << _T(\"' failed: unknown graph command\") << newl;\n        return false;\n    }\n\n    //*********************\n    // ResourceCmdEx context\n    //*********************\n    if (sCommand == _T(\"context\"))\n    {\n        if (vArgs.empty())\n        {\n            Console << _T(\"^r'ResourceCmdEx context' command failed (not enough args): specify a context command.\") << newl;\n            return false;\n        }\n        const tstring &sContextCmd(vArgs[0]);\n\n        //*********************\n        // ResourceCmdEx context activate <string sContextName>\n        //*********************\n        if (sContextCmd == _T(\"push\") || sContextCmd == _T(\"activate\"))\n        {\n            if (vArgs.size() < 2)\n            {\n                Console << _T(\"^r'ResourceCmdEx context push' command failed (not enough args): specify a context name.\") << newl;\n                return false;\n            }\n            const tstring &sContextName(vArgs[1]);\n\n            ActivateContextPushTop(sContextName);\n\n            return true;\n        }\n\n        //*********************\n        // ResourceCmdEx context deactivate <string sContextName>\n        //*********************\n        if (sContextCmd == _T(\"pop\") || sContextCmd == _T(\"deactivate\"))\n        {\n            if (vArgs.size() < 2)\n            {\n                Console << _T(\"^r'ResourceCmdEx context pop' command failed (not enough args): specify a context name.\") << newl;\n                return false;\n            }\n            const tstring &sContextName(vArgs[1]);\n\n            if (!DeactivateContextPopTop(sContextName))\n            {\n                Console << _T(\"^rFailed to pop context \") << sContextName << _T(\": it is not the topmost context.\") << newl;\n                return false;\n            }\n\n            return true;\n        }\n\n        //*********************\n        // ResourceCmdEx context delete <string sContextName>\n        //*********************\n        if (sContextCmd == _T(\"delete\"))\n        {\n            try\n            {\n                if (vArgs.size() < 2)\n                    EX_ERROR(_T(\"not enough args; specify the context you want to delete\"));\n                const tstring &sContextName(vArgs[1]);\n\n                // is it a wildcard deletion?\n                bool bWildcard(false);\n                const tstring &sWildcard(sContextName);\n                if (sContextName.find(_T('*')) != tstring::npos)\n                    bWildcard = true;\n\n                // global context.\n                SResContext* pGlobalCtx(nullptr);\n                if (!m_stkPushedContexts.empty())\n                    pGlobalCtx = &((*m_stkPushedContexts.front()).second);\n\n                for (ResContextMap::iterator it(m_mapResContexts.begin()), itNext, itEnd(m_mapResContexts.end()); it != itEnd; it = itNext)\n                {\n                    const tstring&  sCurCtxName(it->first);\n                    SResContext*    pCtx(&it->second);\n\n                    itNext = it;\n                    ++itNext;\n\n                    // never delete the global context.\n                    if (pCtx == pGlobalCtx)\n                        continue;\n\n                    if (bWildcard)\n                    {\n                        // wildcard name match\n                        if (!EqualsWildcards(sWildcard, sCurCtxName))\n                            continue;\n                    }\n                    else\n                    {\n                        // exact name match\n                        if (sCurCtxName != sContextName)\n                            continue;\n                    }\n\n                    tstring sCurCtxNameCopy(sCurCtxName);\n                    if (uint uiResult = DeleteContext(sCurCtxNameCopy))\n                    {\n                        if (uiResult == RESCTX_DELETED)\n                            Console << _T(\"ResContext: deleted context '^y\") << sCurCtxNameCopy << _T(\"^*'\") << newl;\n                        else if (uiResult == RESCTX_SCHEDULED_FOR_DELETION)\n                            Console << _T(\"ResContext: scheduled context '^y\") << sCurCtxNameCopy << _T(\"^*' to be deleted when it goes inactive.\") << newl;\n                        else if (uiResult == RESCTX_ALREADY_DELETING)\n                            Console << _T(\"ResContext: context '^y\") << sCurCtxNameCopy << _T(\"^*' was already scheduled to be deleted when it goes inactive.\") << newl;\n                        else\n                            assert(false);\n                    }\n                    else\n                    {\n                        Console << _T(\"ResContext: Failed to delete '^y\") << sCurCtxNameCopy << _T(\"^*'\") << newl;\n                    }\n                }\n\n                return true;\n            }\n            catch (CException& ex)\n            {\n                ex.Process(_T(\"'ResourceCmdEx context delete <contextName>' command: \"), NO_THROW);\n                return false;\n            }\n        }\n\n        //*********************\n        // ResourceCmdEx context copy <string sSrcContextName> <string sDstContextName>\n        //*********************\n        if (sContextCmd == _T(\"copy\") || sContextCmd == _T(\"clone\") || sContextCmd == _T(\"cp\"))\n        {\n            try\n            {\n                if (vArgs.size() < 3)\n                    EX_ERROR(_T(\"not enough args\"));\n\n                const tstring &sSrcContextName(vArgs[1]);\n                const tstring &sDstContextName(vArgs[2]);\n\n                SResContext* pSrcContext(LookupContext(sSrcContextName));\n                if (pSrcContext == nullptr)\n                    EX_ERROR(_TS(\"unknown source context '\") + sSrcContextName + _T(\"'\"));\n\n                bool bReplacing(false);\n                uint uiPrevResCount(0);\n\n                SResContext* pDstContext(LookupContext(sDstContextName));\n                if (pDstContext != nullptr)\n                {\n                    bReplacing = true;\n                    uiPrevResCount = (uint)pDstContext->setToplevelResources.size();\n                }\n                else\n                    pDstContext = LookupContext(sDstContextName, true);\n                assert(pDstContext != nullptr);\n\n                pDstContext->setToplevelResources = pSrcContext->setToplevelResources;\n\n                if (bReplacing)\n                {\n                    Console << _T(\"ResContext: replaced '^y\") << sDstContextName << _T(\"^*' (\") << uiPrevResCount << _T(\" resources)\");\n                    Console << _T(\" with '^y\") << sSrcContextName << _T(\"^*' (^c\") << (uint)pSrcContext->setToplevelResources.size() << _T(\"^* resources)\");\n                    Console << newl;\n                }\n                else\n                {\n                    Console << _T(\"ResContext: created '^y\") << sDstContextName << _T(\"^*' and copied contents\");\n                    Console << _T(\" from '^y\") << sSrcContextName << _T(\"^*' (^c\") << (uint)pSrcContext->setToplevelResources.size() << _T(\"^* resources)\");\n                    Console << newl;\n                }\n\n                return true;\n            }\n            catch (CException& ex)\n            {\n                ex.Process(_T(\"'ResourceCmdEx context copy <srcContextName> <dstContextName>' command: \"), NO_THROW);\n                return false;\n            }\n        }\n\n        //*********************\n        // ResourceCmdEx context move <string sSrcContextName> <string sDstContextName>\n        //*********************\n        if (sContextCmd == _T(\"move\") || sContextCmd == _T(\"mv\"))\n        {\n            try\n            {\n                if (vArgs.size() < 3)\n                    EX_ERROR(_T(\"not enough args\"));\n\n                const tstring &sSrcContextName(vArgs[1]);\n                const tstring &sDstContextName(vArgs[2]);\n\n                SResContext* pSrcContext(LookupContext(sSrcContextName));\n                if (pSrcContext == nullptr)\n                    EX_ERROR(_TS(\"unknown source context '\") + sSrcContextName + _T(\"'\"));\n\n                bool bReplacing(false);\n                uint uiPrevResCount(0);\n\n                SResContext* pDstContext(LookupContext(sDstContextName));\n                if (pDstContext != nullptr)\n                {\n                    bReplacing = true;\n                    uiPrevResCount = (uint)pDstContext->setToplevelResources.size();\n                }\n                else\n                {\n                    pDstContext = LookupContext(sDstContextName, true);\n                }\n                assert(pDstContext != nullptr);\n\n                pDstContext->setToplevelResources = pSrcContext->setToplevelResources;\n\n                if (bReplacing)\n                {\n                    Console << _T(\"ResContext: replaced '^y\") << sDstContextName << _T(\"^*' (\") << uiPrevResCount << _T(\" resources)\");\n                    Console << _T(\" with '^y\") << sSrcContextName << _T(\"^*' (^c\") << (uint)pSrcContext->setToplevelResources.size() << _T(\"^* resources)\");\n                    Console << _T(\" and deleted '^y\") << sSrcContextName << _T(\"^*'\");\n                    Console << newl;\n                }\n                else\n                {\n                    Console << _T(\"ResContext: created '^y\") << sDstContextName << _T(\"^*', copied contents \");\n                    Console << _T(\" from '^y\") << sSrcContextName << _T(\"^*' (^c\") << (uint)pSrcContext->setToplevelResources.size() << _T(\"^* resources), \");\n                    Console << _T(\" and deleted '^y\") << sSrcContextName << _T(\"^*'\");\n                    Console << newl;\n                }\n\n                DeleteContext(sSrcContextName);\n\n                return true;\n            }\n            catch (CException& ex)\n            {\n                ex.Process(_T(\"'ResourceCmdEx context move <srcContextName> <dstContextName>' command: \"), NO_THROW);\n                return false;\n            }\n        }\n\n        //*********************\n        // ResourceCmdEx context exists <string sContextName>\n        //*********************\n        if (sContextCmd == _T(\"exists\"))\n        {\n            try\n            {\n                if (vArgs.size() < 2)\n                    EX_ERROR(_T(\"not enough args\"));\n\n                const tstring &sContextName(vArgs[0]);\n\n                SResContext* pSrcContext(LookupContext(sContextName));\n                if (pSrcContext == nullptr)\n                    Console << XtoA(_T(\"false\"));\n                else\n                    Console << XtoA(_T(\"true\"));\n                Console << newl;\n\n                return true;\n            }\n            catch (CException& ex)\n            {\n                ex.Process(_T(\"'ResourceCmdEx context exists <contextName>' command: \"), NO_THROW);\n                return false;\n            }\n        }\n\n        //*********************\n        // ResourceCmdEx context list <string sWildcardContextNames>\n        //*********************\n        if (sContextCmd == _T(\"list\"))\n        {\n            tstring sWildcardContext(_T(\"*\"));\n            tstring sWildcardContextChildren; // don't print any context resources unless specified.\n            if (vArgs.size() >= 2)\n                sWildcardContext = vArgs[1];\n            if (vArgs.size() >= 3)\n                sWildcardContextChildren = vArgs[2];\n\n            ForEachResContext(const tstring* sCtxName, SResContext* pCtx)\n            {\n                if (EqualsWildcards(sWildcardContext, *sCtxName))\n                    PrintContext(Console.DefaultStream(), *sCtxName, sWildcardContextChildren, pCtx);\n            }\n\n            return true;\n        }\n\n        Console << _T(\"^r'ResourceCmdEx context \") << sContextCmd << _T(\"' failed: unknown context command\") << newl;\n        return true;\n    }\n\n    //*********************\n    // ResourceCmdEx orphans\n    //*********************\n    if (sCommand == _T(\"orphans\"))\n    {\n        if (vArgs.empty())\n        {\n            Console << _T(\"^r'ResourceCmdEx orphans' command failed (not enough args): specify an orphans command.\") << newl;\n            return false;\n        }\n        const tstring &sOrphansCmd(vArgs[0]);\n\n\n        //*********************\n        // ResourceCmdEx orphans list\n        //*********************\n        if (sOrphansCmd == _T(\"list\"))\n        {\n            CalcOrphanedResources();\n\n            ForEachResInfo(IResource* pRes, SResInfo* pInfo)\n            {\n                if (pInfo->HasFlags(RI_ORPAHNED))\n                {\n                    Console << _T(\"Orphaned \");\n                    g_ResourceManager.PrintResource(Console.DefaultStream(), pRes);\n                    Console << newl;\n                }\n            }\n\n            return true;\n        }\n\n\n        //*********************\n        // ResourceCmdEx orphans unregister\n        //*********************\n        if (sOrphansCmd == _T(\"unregister\"))\n        {\n            CalcOrphanedResources();\n\n            ResourceSet setUnregister;\n\n            ForEachResInfo(IResource* pRes, SResInfo* pInfo)\n            {\n                switch (pRes->GetResType())\n                {\n                case RES_TEXTURE:\n                case RES_MATERIAL:\n                case RES_MODEL:\n                case RES_CLIP:\n                case RES_SAMPLE:\n                case RES_EFFECT:\n                    {\n                        if (pInfo->HasFlags(RI_ORPAHNED))\n                        {\n                            ResHandle hRes(pRes->GetHandle());\n                            setUnregister.insert(hRes);\n                        }\n                    }\n                    break;\n                }\n            }\n\n            while (!setUnregister.empty())\n            {\n                ResHandle hRes(*setUnregister.begin());\n                g_ResourceManager.Unregister(hRes, UNREG_RESERVE_HANDLE);\n                setUnregister.erase(setUnregister.begin());\n            }\n\n            return true;\n        }\n\n        Console << _T(\"^r'ResourceCmdEx orphans \") << sOrphansCmd << _T(\"' failed: unknown orphans command\") << newl;\n        return true;\n    }\n\n    Console << _T(\"^rUnknown resource context command: \") << sCommand << newl;\n    return false;\n}\n\n\n/*====================\n  CResourceInfo::ExecCommandLine\n  ====================*/\nbool    CResourceInfo::ExecCommandLine(const tstring &sCommandLine)\n{\n    size_t uiPos(sCommandLine.find_first_of(_T(' ')));\n\n    // no args?\n    if (uiPos == tstring::npos)\n        return ExecCommand(sCommandLine);\n\n    // execute with args.\n    tsvector vArgs;\n    SplitBy(vArgs, sCommandLine, _TS(\" \"), uiPos + 1, SPLITBY_ERASE_EMPTY_SPLITS);\n    assert(!vArgs.empty());\n    return ExecCommand(sCommandLine.substr(0, uiPos), vArgs);\n}\n\n//=============================================================================\n\n/*--------------------\n  ResourceCmdEx\n  --------------------*/\nCMD(ResourceCmdEx)\n{\n    if (vArgList.empty())\n    {\n        Console << _T(\"ResourceCmdEx <string sCommand>\") << newl;\n        return false;\n    }\n\n    const tstring &sCommand(LowerString(vArgList[0]));\n    tsvector vArgs(vArgList.begin() + 1, vArgList.end());\n    g_ResourceInfo.ExecCommand(sCommand, vArgs);\n    return true;\n}\n\n\n/*--------------------\n  ListResourceGraph\n  --------------------*/\nCMD(ListResourceGraph)\n{\n    tstring sWildcard(_T(\"*\"));\n    if (!vArgList.empty())\n        sWildcard = vArgList[0];\n\n    tsvector vArgs;\n    vArgs.push_back(sWildcard);\n    for (size_t i(1); i < vArgList.size(); ++i)\n        vArgs.push_back(vArgList[i]);\n\n    g_ResourceInfo.ExecCommand(_T(\"graph\"), vArgs);\n    return true;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_resourceinfo.cpp b/src/k2/c_resourceinfo.cpp
--- a/src/k2/c_resourceinfo.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_resourceinfo.cpp	(date 1684979147136)
@@ -106,20 +106,25 @@
   CGraphResource::CGraphResource
   ====================*/
 CGraphResource::CGraphResource()
-: m_pPrevParent(nullptr)
-, m_hResource(INVALID_RESOURCE)
-, m_bValid(true)
-, m_bDone(false)
-, m_bLinking(false)
 {
     // store the current parent.
     m_pPrevParent = s_pCurrentParent;
-    
+
     // make ourselves the current parent.
     s_pCurrentParent = this;
 }
 
 
+/*====================
+  CGraphResource::CGraphResource
+  ====================*/
+CGraphResource::CGraphResource(ResHandle hResource)
+: CGraphResource()
+{
+    SetHandle(hResource);
+}
+
+
 /*====================
   CGraphResource::SetDebugPath
   ====================*/
Index: src/k2/c_vid.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_vid.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_vid.h\"\n#include \"c_cmd.h\"\n#include \"i_resourcelibrary.h\"\n#include \"c_scenestats.h\"\n#include \"c_uicmd.h\"\n#include \"i_widget.h\"\n#include \"i_listwidget.h\"\n#include \"c_uimanager.h\"\n#include \"c_resourcemanager.h\"\n\n#undef pVid\n#undef Vid\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nCVid    *pVid = CVid::GetInstance();\n\nEXTERN_CVAR_STRING(host_vidDriver);\nEXTERN_CVAR_STRING(host_startupCfg);\n\nCVAR_STRING     (vid_currentMode,               \"\");\nCVAR_INTF       (vid_mode,                      -1,         CVAR_READONLY);\n#ifdef linux\nCVAR_STRINGF    (vid_display,                   \"\",         CVAR_SAVECONFIG);\nCVAR_BOOLF      (vid_blankOtherDisplays,        false,      CVAR_SAVECONFIG);\n#endif\n#ifdef __APPLE__\nCVAR_INTF       (vid_display,                   -1,         CVAR_SAVECONFIG);\n#endif\nARRAY_CVAR_UINTF(vid_resolution,                _T(\"0,0\"),  CVAR_SAVECONFIG);\nCVAR_INTF       (vid_bpp,                       0,          CVAR_SAVECONFIG);\nCVAR_INTF       (vid_refreshRate,               0,          CVAR_SAVECONFIG);\nCVAR_STRINGF    (vid_aspect,                    \"\",         CVAR_SAVECONFIG);\nCVAR_FLOATF     (vid_gamma,                     1.1f,       CVAR_SAVECONFIG);\nARRAY_CVAR_UINTF(vid_antialiasing,              _T(\"0,0\"),  CVAR_SAVECONFIG);\nCVAR_INTR       (vid_textureFiltering,          TEXTUREFILTERING_TRILINEAR, CVAR_SAVECONFIG, 0, NUM_TEXTUREFILTERING_MODES - 1);\nCVAR_BOOLF      (vid_fullscreen,                false,      CVAR_SAVECONFIG);\nCVAR_BOOL       (vid_windowResize,              false);\n\ntypedef void (*_initapis_t)(SVidDriver *vid_api, void *_MainWndProc, void *hInstance);\n\nSINGLETON_INIT(CVid)\n//=============================================================================\n\n/*====================\n  CVid::CVid\n\n  Set the singleton up for a SetDriver call\n  ====================*/\nCVid::CVid() :\nm_iCurrentMode(-1),\nm_bInitialized(false),\nm_hVidDLL(nullptr)\n{\n#ifdef _WIN32\n    MemManager.Set(&m_Driver, 0, sizeof(m_Driver));\n#else\n    MemManager.Set((char*)(&m_Driver) + sizeof(tstring), 0, sizeof(m_Driver) - sizeof(tstring));\n#endif\n}\n\n\n/*====================\n  CVid::~CVid\n  ====================*/\nCVid::~CVid()\n{\n    UnloadVidModule();\n}\n\n\n/*====================\n  CVid::SetDriver\n  ====================*/\nvoid    CVid::SetDriver(const tstring &sDriverName)\n{\n    bool reload = false;\n    if (!m_Driver.sDriverName.empty()) // Shutdown an old driver if we had one\n    {\n        if (m_Driver.sDriverName == sDriverName)\n            return;\n\n        Shutdown(); // Shutdown old driver\n        UnloadVidModule();\n        reload = true;\n\n        // UTTAR: Not ideal but best solution I can find for cvars to stick properly.\n        // All other alternatives either required redoing some systems or had disadvantages (or crashes...)\n        Console.ExecuteScript(host_startupCfg);\n    }\n\n    LoadVidModule(sDriverName);\n\n    StartDriver();\n\n    // UTTAR: Reload all the resources the video driver is directly aware of...\n    if (reload)\n    {\n        g_ResourceManager.GetLib(RES_PIXEL_SHADER)->ReloadAll();\n        g_ResourceManager.GetLib(RES_VERTEX_SHADER)->ReloadAll();\n        g_ResourceManager.GetLib(RES_TEXTURE)->ReloadAll();\n        g_ResourceManager.GetLib(RES_MATERIAL)->ReloadAll();\n        g_ResourceManager.GetLib(RES_MODEL)->ReloadAll();\n    }\n    host_vidDriver.SetModified(0);\n}\n\n\n/*====================\n  CVid::RegisterModel\n  ====================*/\nint     CVid::RegisterModel(CModel *pModel)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterModel(pModel);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterModel\n  ====================*/\nvoid    CVid::UnregisterModel(CModel *pModel)\n{\n    if (m_bInitialized)\n        return m_Driver.UnregisterModel(pModel);\n}\n\n\n/*====================\n  CVid::GetCamera\n  ====================*/\nconst CCamera*  CVid::GetCamera()\n{\n    if (m_bInitialized)\n        return m_Driver.GetCamera();\n    else\n        return nullptr;\n}\n\n\n/*====================\n  CVid::StartDriver\n  ====================*/\nvoid    CVid::StartDriver()\n{\n    Console.Video << _T(\"---------------------------------------------------------\") << newl\n            << _T(\"CVid::StartDriver():\") << newl;\n\n    m_Driver.Init();\n\n    SVidMode vm;\n    for (int i(0); m_Driver.GetMode(i, &vm); ++i)\n    {\n        // Create two cvars, one for each direction\n        ICvar::CreateString(_T(\"SetVideoMode\") + XtoA(i, FMT_PADZERO, 2), vm.sName);\n        ICvar::CreateInt(vm.sName, i);\n    }\n\n    for (int i(0); i < NUM_TEXTUREFILTERING_MODES; ++i)\n    {\n        if (!TextureFilteringModeAvailable(ETextureFilteringModes(i)))\n            continue;\n\n        ICvar::CreateString(_T(\"vid_textureFiltering\") + XtoA(i, FMT_PADZERO, 1), g_aTextureFilteringNames[i]);\n    }\n\n    if (!vid_resolution[0] || !vid_resolution[1] || !vid_bpp\n#ifndef __APPLE__\n        // some devices report a refresh rate of 0 under OS X\n        || !vid_refreshRate\n#endif\n        )\n    {\n        SVidMode vm;\n        if (m_Driver.GetMode(0, &vm))\n        {\n            if (vid_resolution.GetSize() != 2)\n                vid_resolution.Resize(2, 0);\n\n            if (vid_fullscreen)\n            {\n                vid_resolution.SetValue(0, vm.iWidth);\n                vid_resolution.SetValue(1, vm.iHeight);\n            }\n            else\n            {\n                // Subtract a bit of resolution to account for title bar\n                vid_resolution.SetValue(0, MAX(720, vm.iWidth - 160));\n                vid_resolution.SetValue(1, MAX(480, vm.iHeight - 100));\n            }\n            vid_bpp = vm.iBpp;\n            vid_refreshRate = vm.iRefreshRate;\n        }\n    }\n\n    vid_mode = m_iCurrentMode = m_Driver.SetMode();\n    m_Driver.GetCurrentMode(&m_VidMode);\n\n    m_bInitialized = true;\n    m_Driver.Start();\n\n    m_Driver.GetCurrentMode(&m_VidMode);\n    Console.Video << _T(\"Using mode \") << m_iCurrentMode << _T(\": \") << m_VidMode.iWidth << _T(\"x\") << m_VidMode.iHeight << _T(\"x\") << m_VidMode.iBpp << newl;\n    vid_currentMode = XtoA(m_VidMode.iWidth) + _T(\"x\") + XtoA(m_VidMode.iHeight) + _T(\"x\") + XtoA(m_VidMode.iBpp);\n}\n\n\n/*====================\n  CVid::Shutdown\n  ====================*/\nvoid    CVid::Shutdown()\n{\n    if (m_bInitialized)\n        m_Driver.Shutdown();\n    m_bInitialized = false;\n}\n\n\n/*====================\n  CVid::RenderScene\n  ====================*/\nvoid    CVid::RenderScene(class CCamera &camera)\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::RenderScene\");\n        m_Driver.RenderScene(camera);\n    }\n}\n\n\n/*====================\n  CVid::Add2dRect\n  ====================*/\nvoid    CVid::Add2dRect(float x, float y, float w, float h, float s1, float t1, float s2, float t2, ResHandle hTexture, int iFlags)\n{\n    if (m_bInitialized)\n        m_Driver.Add2dRect(x, y, w, h, s1, t1, s2, t2, hTexture, iFlags);\n}\n\n\n/*====================\n  CVid::Add2dQuad\n  ====================*/\nvoid    CVid::Add2dQuad(const CVec2f& v1, const CVec2f& v2, const CVec2f& v3, const CVec2f& v4,\n                        const CVec2f& t1, const CVec2f& t2, const CVec2f& t3, const CVec2f& t4, ResHandle hTexture, int iFlags)\n{\n    if (m_bInitialized)\n        m_Driver.Add2dQuad(v1, v2, v3, v4, t1, t2, t3, t4, hTexture, iFlags);\n}\n\n\n/*====================\n  CVid:Add2dLine\n  ====================*/\nvoid    CVid::Add2dLine(const CVec2f& v1, const CVec2f& v2, const CVec4f& v4Color1, const CVec4f& v4Color2, int iFlags)\n{\n    if (m_bInitialized)\n        m_Driver.Add2dLine(v1, v2, v4Color1, v4Color2, iFlags);\n}\n\n\n/*====================\n  CVid::AddPoint\n  ====================*/\nvoid    CVid::AddPoint(const CVec3f &v3Point, const CVec4f &v4Color)\n{\n    if (m_bInitialized)\n        m_Driver.AddPoint(v3Point, v4Color);\n}\n\n\n/*====================\n  CVid::AddLine\n  ====================*/\nvoid    CVid::AddLine(const CVec3f &v3Start, const CVec3f &v3End, const CVec4f &v4Color)\n{\n    if (m_bInitialized)\n        m_Driver.AddLine(v3Start, v3End, v4Color);\n}\n\n\n/*====================\n  CVid::Clear\n  ====================*/\nvoid    CVid::Clear()\n{\n    if (m_bInitialized)\n        m_Driver.Clear();\n}\n\n\n/*====================\n  CVid::NormalizeColor\n  ====================*/\nvoid    CVid::NormalizeColor(const vec4_t color, vec4_t out)\n{\n    //just clamp values brighter than 1\n    if (color[0] > 1)\n        out[0] = 1;\n    else\n        out[0] = color[0];\n\n    if (color[1] > 1)\n        out[1] = 1;\n    else\n        out[1] = color[1];\n\n    if (color[2] > 1)\n        out[2] = 1;\n    else\n        out[2] = color[2];\n\n    out[3] = color[3];\n}\n\n\n/*====================\n  CVid::SetColor\n  ====================*/\nvoid    CVid::SetColor(CVec4f v4Color)\n{\n    if (m_bInitialized)\n        m_Driver.SetColor(v4Color);\n}\n\n\n/*====================\n  CVid::Notify\n  ====================*/\nvoid    CVid::Notify(EVidNotifyMessage eMsg, int iParam1, int iParam2, int iParam3, void *pData, const tstring &sResContext)\n{\n    if (m_bInitialized)\n        m_Driver.Notify(eMsg, iParam1, iParam2, iParam3, pData, sResContext);\n}\n\n\n/*====================\n  CVid::BeginFrame\n  ====================*/\nvoid    CVid::BeginFrame()\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::BeginFrame\");\n        m_Driver.BeginFrame();\n    }\n}\n\n\n/*====================\n  CVid::EndFrame\n  ====================*/\nvoid    CVid::EndFrame()\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::EndFrame\");\n        m_Driver.EndFrame();\n    }\n\n    SceneStats.ResetFrame();\n}\n\n\n/*====================\n  CVid::GetScreenW\n  ====================*/\nint     CVid::GetScreenW()\n{\n    return m_VidMode.iWidth;\n}\n\n\n/*====================\n  CVid::GetScreenH\n  ====================*/\nint     CVid::GetScreenH()\n{\n    return m_VidMode.iHeight;\n}\n\n\n/*====================\n  CVid::GetFrameBuffer\n  ====================*/\nvoid    CVid::GetFrameBuffer(CBitmap &bmp)\n{\n    if (m_bInitialized)\n        return m_Driver.GetFrameBuffer(bmp);\n}\n\n\n/*====================\n  CVid::ProjectVertex\n  ====================*/\nCVec2f  CVid::ProjectVertex(const class CCamera &cam, const CVec3f &vecVertex)\n{\n    if (m_bInitialized)\n        return m_Driver.ProjectVertex(cam, vecVertex);\n    else\n        return CVec2f(0,0);\n}\n\n\n/*====================\n  CVid::IsFullScreen\n  ====================*/\nbool    CVid::IsFullScreen()\n{\n    if (m_bInitialized)\n        return m_Driver.IsFullScreen();\n    else\n        return false;\n}\n\n\n/*====================\n  CVid::GetHWnd\n  ====================*/\nvoid*   CVid::GetHWnd()\n{\n    if (m_bInitialized)\n        return m_Driver.GetHWnd();\n    else\n        return nullptr;\n}\n\n\n/*====================\n  CVid::OpenTextureArchive\n  ====================*/\nvoid    CVid::OpenTextureArchive(bool bNoReload)\n{\n    if (m_bInitialized)\n        m_Driver.OpenTextureArchive(bNoReload);\n}\n\n\n/*====================\n  CVid::CloseTextureArchive\n  ====================*/\nvoid    CVid::CloseTextureArchive()\n{\n    if (m_bInitialized)\n        m_Driver.CloseTextureArchive();\n}\n\n\n/*====================\n  CVid::GetTextureList\n  ====================*/\nvoid    CVid::GetTextureList(const tstring &sPath, const tstring &sSearch, tsvector &vResult)\n{\n    if (m_bInitialized)\n        m_Driver.GetTextureList(sPath, sSearch, vResult);\n}\n\n\n/*====================\n  CVid::RegisterTexture\n  ====================*/\nint     CVid::RegisterTexture(CTexture *pTexture)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterTexture(pTexture);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterTexture\n  ====================*/\nvoid    CVid::UnregisterTexture(CTexture *pTexture)\n{\n    if (m_bInitialized)\n        m_Driver.UnregisterTexture(pTexture);\n}\n\n\n/*====================\n  CVid::RegisterVertexShader\n  ====================*/\nint     CVid::RegisterVertexShader(CVertexShader *pVertexShader)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterVertexShader(pVertexShader);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterVertexShader\n  ====================*/\nvoid    CVid::UnregisterVertexShader(CVertexShader *pVertexShader)\n{\n    if (m_bInitialized)\n        m_Driver.UnregisterVertexShader(pVertexShader);\n}\n\n\n/*====================\n  CVid::RegisterPixelShader\n  ====================*/\nint     CVid::RegisterPixelShader(CPixelShader *pPixelShader)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterPixelShader(pPixelShader);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterPixelShader\n  ====================*/\nvoid    CVid::UnregisterPixelShader(CPixelShader *pPixelShader)\n{\n    if (m_bInitialized)\n        m_Driver.UnregisterPixelShader(pPixelShader);\n}\n\n\n/*====================\n  CVid::RegisterShaderPair\n  ====================*/\nvoid    CVid::RegisterShaderPair(CVertexShader *pVertexShader, CPixelShader *pPixelShader)\n{\n    if (m_bInitialized)\n        m_Driver.RegisterShaderPair(pVertexShader, pPixelShader);\n}\n\n\n/*====================\n  CVid::RenderFogofWar\n  ====================*/\nvoid    CVid::RenderFogofWar(float fClear, bool bTexture, float fLerp)\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::RenderFogofWar\");\n        m_Driver.RenderFogofWar(fClear, bTexture, fLerp);\n    }\n}\n\n\n/*====================\n  CVid::UpdateFogofWar\n  ====================*/\nvoid    CVid::UpdateFogofWar(const CBitmap &cBmp)\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::UpdateFogofWar\");\n        m_Driver.UpdateFogofWar(cBmp);\n    }\n}\n\n\n/*====================\n  CVid::ShowCursor\n  ====================*/\nvoid    CVid::ShowCursor(bool bShow)\n{\n    if (m_bInitialized)\n    {\n        m_Driver.ShowCursor(bShow);\n    }\n}\n\n\n/*====================\n  CVid::SetCursor\n  ====================*/\nvoid    CVid::SetCursor(ResHandle hCursor)\n{\n    if (m_bInitialized)\n    {\n        m_Driver.SetCursor(hCursor);\n    }\n}\n\n\n/*====================\n  CVid::GetMode\n  ====================*/\nbool    CVid::GetMode(int iMode, SVidMode *pVidMode)\n{\n    if (m_bInitialized)\n    {\n        return m_Driver.GetMode(iMode, pVidMode);\n    }\n\n    return false;\n}\n\n\n/*====================\n  CVid::GetCurrentMode\n  ====================*/\nbool    CVid::GetCurrentMode(SVidMode *pVidMode)\n{\n    if (m_bInitialized)\n    {\n        return m_Driver.GetCurrentMode(pVidMode);\n    }\n\n    return false;\n}\n\n\n/*====================\n  CVid::GetTextureColor\n  ====================*/\nCVec4f  CVid::GetTextureColor(CTexture *pTexture)\n{\n    if (m_bInitialized)\n    {\n        return m_Driver.GetTextureColor(pTexture);\n    }\n\n    return WHITE;\n}\n\n\n/*====================\n  CVid::GetAAMode\n  ====================*/\nbool    CVid::GetAAMode(int iMode, SAAMode *pAAMode)\n{\n    if (!m_bInitialized)\n        return false;\n\n    return m_Driver.GetAAMode(iMode, pAAMode);\n}\n\n\n/*====================\n  CVid::GetCurrentAAMode\n  ====================*/\nbool    CVid::GetCurrentAAMode(SAAMode *pAAMode)\n{\n    if (!m_bInitialized)\n        return false;\n\n    return m_Driver.GetCurrentAAMode(pAAMode);\n}\n\n\n/*====================\n  CVid::TextureExists\n  ====================*/\nbool    CVid::TextureExists(const tstring &sFilename, uint uiTextureFlags)\n{\n    if (m_bInitialized)\n    {\n#if TKTK\n        return m_Driver.TextureExists(sFilename, uiTextureFlags);\n#else\n        if (m_Driver.TextureExists(sFilename, uiTextureFlags))\n            return true;\n        // try each image fallback extension.\n        for (auto sFallbackExt : {_T(\"png\"), _T(\"dds\"), _T(\"tga\")})\n        {\n            if (CompareNoCase(Filename_GetExtension(sFilename), sFallbackExt) == 0)\n                continue;\n            tstring sNewFilename(Filename_StripExtension(sFilename) + _T(\".\") + sFallbackExt);\n            if (m_Driver.TextureExists(sNewFilename, uiTextureFlags))\n                return true;\n        }\n        return false;\n#endif\n    }\n    else\n        return false;\n}\n\n\n/*====================\n  CVid::ChangeMode\n  ====================*/\nvoid    CVid::ChangeMode(int iMode)\n{\n    if (!m_bInitialized)\n        return;\n\n    int iWidth0(m_VidMode.iWidth);\n    int iHeight0(m_VidMode.iHeight);\n\n    if (iMode != -1)\n    {\n        SVidMode vm;\n        if (m_Driver.GetMode(iMode, &vm))\n        {\n            if (vid_resolution.GetSize() != 2)\n                vid_resolution.Resize(2, 0);\n\n            vid_resolution.SetValue(0, vm.iWidth);\n            vid_resolution.SetValue(1, vm.iHeight);\n            vid_bpp = vm.iBpp;\n            vid_refreshRate = vm.iRefreshRate;\n        }\n        else\n            return;\n    }\n\n    vid_mode = m_iCurrentMode = m_Driver.SetMode();\n    m_Driver.GetCurrentMode(&m_VidMode);\n    m_Driver.GetCurrentAAMode(&m_AAMode);\n    Console.Video << _T(\"Video Mode: width=\") << m_VidMode.iWidth << _T(\", height=\") << m_VidMode.iHeight << _T(\", bpp=\") << m_VidMode.iBpp << _T(\", refreshrate=\") << m_VidMode.iRefreshRate << _T(\", samples=\") << m_AAMode.iSamples << newl;\n    vid_currentMode = XtoA(m_VidMode.iWidth) + _T(\"x\") + XtoA(m_VidMode.iHeight) + _T(\"x\") + XtoA(m_VidMode.iBpp);\n\n    if (iWidth0 != m_VidMode.iWidth || iHeight0 != m_VidMode.iHeight)\n    {\n        Host.SetResolutionChange(true);\n\n        UIManager.ResizeInterface(_T(\"loading\"), m_VidMode.iWidth, m_VidMode.iHeight);\n\n        SetColor(BLACK);\n        Clear();\n    }\n}\n\n\n/*====================\n  CVid::TextureFilteringModeAvailable\n  ====================*/\nbool    CVid::TextureFilteringModeAvailable(ETextureFilteringModes eMode)\n{\n    if (!m_bInitialized)\n        return false;\n\n    return m_Driver.TextureFilteringModeAvailable(eMode);\n}\n\n\n/*====================\n  CVid::LoadVidModule\n  ====================*/\nvoid    CVid::LoadVidModule(const tstring &sFileName)\n{\n    _initapis_t InitAPIs;\n\n    m_hVidDLL = K2System.LoadLibrary(sFileName);\n    if (m_hVidDLL == nullptr)\n        K2System.Error(_T(\"Couldn't load \") + sFileName);\n\n    //find and call CL_InitAPIs to get function pointers to the client game functions\n    InitAPIs = (_initapis_t)K2System.GetProcAddress(m_hVidDLL, _T(\"InitAPIs\"));\n    if (!InitAPIs)\n        K2System.Error(_T(\"Couldn't find entry function InitAPIs()\"));\n\n    InitAPIs(&m_Driver, K2System.GetMainWndProc(), K2System.GetInstanceHandle());\n}\n\n\n/*====================\n  CVid::UnloadVidModule\n  ====================*/\nvoid    CVid::UnloadVidModule()\n{\n    if (m_hVidDLL)\n    {\n        K2System.FreeLibrary(m_hVidDLL);\n        m_hVidDLL = nullptr;\n\n#ifdef _WIN32\n        MemManager.Set(&m_Driver, 0, sizeof(m_Driver));\n#else\n        MemManager.Set((char*)(&m_Driver) + sizeof(tstring), 0, sizeof(m_Driver) - sizeof(tstring));\n        m_Driver.sDriverName.clear();\n#endif\n    }\n}\n\n\n/*--------------------\n  cmdSetVideoMode\n  --------------------*/\nCMD(SetVideoMode)\n{\n    CVid::GetInstance()->ChangeMode(vArgList.size() > 0 ? AtoI(vArgList[0]) : -1);\n    return true;\n}\n\n#if defined(linux) || defined(__APPLE__)\n/*--------------------\n  AddDisplays\n  --------------------*/\nUI_VOID_CMD(AddDisplays, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n    \n    mapParams[_T(\"label\")] = _T(\"Automatic\");\n#ifdef linux\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"\"), mapParams);\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        if (vm.sDisplay.empty() || setNames.find(vm.sDisplay) != setNames.end())\n            continue;\n\n        setNames.insert(vm.sDisplay);\n\n        mapParams[_T(\"label\")] = vm.sDisplay;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), vm.sDisplay, mapParams);\n    }\n#else\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"-1\"), mapParams);\n    \n    set<int> setDpys;\n    \n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        if (setDpys.find(vm.iDisplay) != setDpys.end())\n            continue;\n        \n        setDpys.insert(vm.iDisplay);\n        \n        mapParams[_T(\"label\")] = XtoA(vm.iDisplay);\n        \n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iDisplay), mapParams);\n    }\n#endif\n}\n#endif\n\n\n/*--------------------\n  AddVideoModes\n  --------------------*/\nUI_VOID_CMD(AddVideoModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    tsvector vVidModeList;\n\n    SVidMode vm;\n    for (int i(0); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        vVidModeList.push_back(vm.sName);\n    }\n\n    for (int i(0); i < int(vVidModeList.size()); ++i)\n    {\n        mapParams[_T(\"label\")] = vVidModeList[i];\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(i), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddTextureFilteringModes\n  --------------------*/\nUI_VOID_CMD(AddTextureFilteringModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    for (int i(0); i < NUM_TEXTUREFILTERING_MODES; ++i)\n    {\n        if (!CVid::GetInstance()->TextureFilteringModeAvailable(ETextureFilteringModes(i)))\n            continue;\n        \n        mapParams[_T(\"label\")] = g_aTextureFilteringNames[i];\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(i), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddAntiAliasingModes\n  --------------------*/\nUI_VOID_CMD(AddAntiAliasingModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    SAAMode cMode;\n    for (int i(0); CVid::GetInstance()->GetAAMode(i, &cMode); ++i)\n    {\n        mapParams[_T(\"label\")] = cMode.sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(cMode.iSamples) + _T(\",\") + XtoA(cMode.iQuality), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddAspectModes\n  --------------------*/\nUI_VOID_CMD(AddAspectModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    mapParams[_T(\"label\")] = _T(\"Automatic\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"4:3\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"4:3\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"16:10\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"16:10\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"16:9\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"16:9\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"5:4\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"5:4\"), mapParams);\n}\n\n\n#ifdef linux\nEXTERN_CVAR_STRING(options_display);\n#endif\n#ifdef __APPLE__\nEXTERN_CVAR_INT(options_display);\n#endif\n/*--------------------\n  AddResolutions\n  --------------------*/\nUI_VOID_CMD(AddResolutions, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n#ifdef linux\n        if (!options_display.GetValue().empty() && !vm.sDisplay.empty() && options_display.GetValue() != vm.sDisplay)\n            continue;\n#endif\n#ifdef __APPLE__\n        if (options_display > -1 && options_display != vm.iDisplay)\n            continue;\n#endif\n        \n        tstring sName(XtoA(vm.iWidth) + _T(\"x\") + XtoA(vm.iHeight));\n\n        if (setNames.find(sName) != setNames.end())\n            continue;\n\n        setNames.insert(sName);\n\n        mapParams[_T(\"label\")] = sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iWidth) + _T(\",\") + XtoA(vm.iHeight), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddColorDepths\n  --------------------*/\nUI_VOID_CMD(AddColorDepths, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        tstring sName(XtoA(vm.iBpp) + _T(\" bit\"));\n\n        if (setNames.find(sName) != setNames.end())\n            continue;\n\n        setNames.insert(sName);\n\n        mapParams[_T(\"label\")] = sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iBpp), mapParams);\n    }\n}\n\n\nEXTERN_ARRAY_CVAR_UINT(options_resolution);\n/*--------------------\n  AddRefreshRates\n  --------------------*/\nUI_VOID_CMD(AddRefreshRates, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n#ifdef linux\n        if (!options_display.GetValue().empty() && options_display.GetValue() != vm.sDisplay)\n            continue;\n        \n        if (vm.iWidth != options_resolution[0] || vm.iHeight != options_resolution[1])\n            continue;\n#endif\n#ifdef __APPLE__\n        if (options_display > -1 && options_display != vm.iDisplay)\n            continue;\n        \n        if (vm.iWidth != options_resolution[0] || vm.iHeight != options_resolution[1])\n            continue;\n#endif\n        \n        tstring sName(XtoA(vm.iRefreshRate) + _T(\" Hertz\"));\n        if (vm.iRefreshRate == 0)\n            sName = _T(\"Automatic\");\n\n        if (setNames.find(sName) != setNames.end())\n            continue;\n\n        setNames.insert(sName);\n\n        mapParams[_T(\"label\")] = sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iRefreshRate), mapParams);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_vid.cpp b/src/k2/c_vid.cpp
--- a/src/k2/c_vid.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_vid.cpp	(date 1684987088115)
@@ -162,12 +162,14 @@
 
     m_Driver.Init();
 
-    SVidMode vm;
-    for (int i(0); m_Driver.GetMode(i, &vm); ++i)
-    {
-        // Create two cvars, one for each direction
-        ICvar::CreateString(_T("SetVideoMode") + XtoA(i, FMT_PADZERO, 2), vm.sName);
-        ICvar::CreateInt(vm.sName, i);
+    {
+        SVidMode vm;
+        for (int i(0); m_Driver.GetMode(i, &vm); ++i)
+        {
+            // Create two cvars, one for each direction
+            ICvar::CreateString(_T("SetVideoMode") + XtoA(i, FMT_PADZERO, 2), vm.sName);
+            ICvar::CreateInt(vm.sName, i);
+        }
     }
 
     for (int i(0); i < NUM_TEXTUREFILTERING_MODES; ++i)
@@ -183,7 +185,7 @@
         // some devices report a refresh rate of 0 under OS X
         || !vid_refreshRate
 #endif
-        )
+            )
     {
         SVidMode vm;
         if (m_Driver.GetMode(0, &vm))
Index: src/vid_gl2/gl2_main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2008 S2 Games\n// gl2_main.cpp\n//\n// Implements the K2 Renderer API\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"vid_common.h\"\n\n#include \"c_gfxinit.h\"\n#include \"c_gfxshaders.h\"\n#include \"c_gfx2d.h\"\n#include \"c_gfxmodels.h\"\n#include \"c_gfxterrain.h\"\n#include \"c_gfxutils.h\"\n#include \"c_gfxtextures.h\"\n#include \"gl2_foliage.h\"\n#include \"c_fogofwar.h\"\n#include \"c_shadowmap.h\"\n#include \"c_treescenemanager.h\"\n#include \"c_scenebuffer.h\"\n#include \"c_postbuffer.h\"\n#include \"../k2/c_resourceinfo.h\"\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nconst CCamera           *g_pCam;\nCVec3f                  g_vCamOrigin;\n\nbool                    g_bFullscreen = false;\nbool                    gl_initialized = false;\nbool                    g_bValidScene = false;\nint                     g_iScreenWidth;\nint                     g_iScreenHeight;\nbyte                    g_dwDrawColor[4];\n\nint                     g_iCurrentVideoMode(-1);\nSVidMode                g_CurrentVidMode;\nSVidMode                g_VidModes[MAX_VID_MODES];\nint                     g_iNumVidModes;\n\nSAAMode                 g_CurrentAAMode;\nSAAMode                 g_AAModes[MAX_AA_MODES];\nint                     g_iNumAAModes;\n\n// Texture settings\nGLint                   g_iMaxTextureImageUnits;\nGLint                   g_textureMagFilter(GL_LINEAR);\nGLint                   g_textureMinFilter(GL_LINEAR);\nGLint                   g_textureMinFilterMipmap(GL_LINEAR_MIPMAP_LINEAR);\nGLfloat                 g_textureMaxAnisotropy(1.0f);\n\nconst float             DEFAULT_OVERBRIGHT = 1.0f;\n\nResHandle               g_hCursor(INVALID_RESOURCE);\n\nSDeviceCaps             g_DeviceCaps;\n//=============================================================================\n\n//=============================================================================\n// Cvars\n//=============================================================================\nCVAR_INT    (terrain_chunkSize,         64);\nCVAR_INT    (foliage_chunkSize,         16);\n\nCVAR_INTF   (gl_swapInterval,           0,      CVAR_SAVECONFIG);\n//=============================================================================\n\n\n/*====================\n  GL_Init\n  ====================*/\nint     GL_Global_Init()\n{\n    GfxInit->Init();\n    return 1;\n}\n\n\n/*====================\n  GL_GetDeviceCaps\n\n  Determine features supported by this video card in this video mode\n  ====================*/\nvoid    GL_GetDeviceCaps()\n{\n#ifdef __APPLE__\n    g_DeviceCaps.bNonSquareMatrix = false;\n#else\n    g_DeviceCaps.bNonSquareMatrix = (GLEW_VERSION_2_1 == GL_TRUE);\n#endif\n    \n    g_DeviceCaps.bTextureCompression = (GLEW_EXT_texture_compression_s3tc == GL_TRUE);\n\n    glGetIntegerv(GL_MAX_VARYING_FLOATS_ARB, &g_DeviceCaps.iMaxVaryingFloats);\n    glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB, &g_iMaxTextureImageUnits);\n\n    if (g_iMaxTextureImageUnits > 32)\n        g_iMaxTextureImageUnits = 32;\n}\n\n\n/*====================\n  GL_Global_Start\n  ====================*/\nvoid    GL_Global_Start()\n{\n    GfxInit->Start();\n    GL_SetupTextureFilterSettings(); \n#ifdef _WIN32\n    if (WGLEW_EXT_swap_control)\n        wglSwapIntervalEXT(gl_swapInterval);\n#endif\n}\n\n\n/*====================\n  GL_Create\n  ====================*/\nvoid    GL_Create()\n{\n}\n\n\n/*====================\n  GL_GetMode\n  ====================*/\nbool    GL_GetMode(int iMode, SVidMode *pVidMode)\n{\n    if (!pVidMode || iMode < 0 || iMode >= g_iNumVidModes)\n        return false;\n\n#ifdef linux\n    pVidMode->sDisplay = g_VidModes[iMode].sDisplay;\n#endif\n#ifdef __APPLE__\n    pVidMode->iDisplay = g_VidModes[iMode].iDisplay;\n#endif\n    pVidMode->iWidth = g_VidModes[iMode].iWidth;\n    pVidMode->iHeight = g_VidModes[iMode].iHeight;\n    pVidMode->iBpp = g_VidModes[iMode].iBpp;\n    pVidMode->iRefreshRate = g_VidModes[iMode].iRefreshRate;\n    pVidMode->sName = g_VidModes[iMode].sName;\n    return true;\n}\n\n\n/*====================\n  GL_GetCurrentMode\n  ====================*/\nbool    GL_GetCurrentMode(SVidMode *pVidMode)\n{\n    pVidMode->iWidth = g_CurrentVidMode.iWidth;\n    pVidMode->iHeight = g_CurrentVidMode.iHeight;\n    pVidMode->iBpp = g_CurrentVidMode.iBpp;\n    pVidMode->iRefreshRate = g_CurrentVidMode.iRefreshRate;\n    pVidMode->sName = g_CurrentVidMode.sName;\n    return true;\n}\n\n\n/*====================\n  GL_IsFullScreen\n  ====================*/\nbool    GL_IsFullScreen()\n{\n    return g_bFullscreen;\n}\n\n\n/*====================\n  GL_GetAAMode\n  ====================*/\nbool    GL_GetAAMode(int iMode, SAAMode *pAAMode)\n{\n    if (!pAAMode || iMode < 0 || iMode >= g_iNumAAModes)\n        return false;\n\n    pAAMode->iSamples = g_AAModes[iMode].iSamples;\n    pAAMode->iQuality = g_AAModes[iMode].iQuality;\n    pAAMode->sName = g_AAModes[iMode].sName;\n    return true;\n}\n\n\n/*====================\n  GL_GetCurrentAAMode\n  ====================*/\nbool    GL_GetCurrentAAMode(SAAMode *pAAMode)\n{\n    pAAMode->iSamples = g_CurrentAAMode.iSamples;\n    pAAMode->iQuality = g_CurrentAAMode.iQuality;\n    pAAMode->sName = g_CurrentAAMode.sName;\n    return true;\n}\n\n\n/*====================\n  GL_Global_Shutdown\n  ====================*/\nvoid    GL_Global_Shutdown()\n{\n    glBindBufferARB(GL_ARRAY_BUFFER_ARB, 0);\n    glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER, 0);\n    glUseProgramObjectARB(0);\n    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);\n\n    Gfx2D->Shutdown();\n    Gfx3D->Shutdown();\n    GfxModels->Shutdown();\n    GfxTextures->Shutdown();\n    GfxShaders->Shutdown();\n    GfxTerrain->Shutdown();\n\n    GL_DestroyFoliage();\n\n    g_pTreeSceneManager->Destroy();\n\n    g_Shadowmap.Release();\n    g_FogofWar.Release();\n    g_SceneBuffer.Release();\n    g_PostBuffer.Release();\n\n    PRINT_GLERROR_BREAK();\n}\n\n\n/*====================\n  GL_TextureFilteringModeAvailable\n  ====================*/\nbool    GL_TextureFilteringModeAvailable(ETextureFilteringModes eMode)\n{\n    float fMaxAnisotropy(0);\n    \n    if (GLEW_EXT_texture_filter_anisotropic)\n        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &fMaxAnisotropy);\n    \n    switch (eMode)\n    {\n    case TEXTUREFILTERING_ANISOTROPIC16: return fMaxAnisotropy >= 16.0;\n    case TEXTUREFILTERING_ANISOTROPIC12: return fMaxAnisotropy >= 12.0;\n    case TEXTUREFILTERING_ANISOTROPIC8: return fMaxAnisotropy >= 8.0;\n    case TEXTUREFILTERING_ANISOTROPIC6: return fMaxAnisotropy >= 6.0;\n    case TEXTUREFILTERING_ANISOTROPIC4: return fMaxAnisotropy >= 4.0;\n    case TEXTUREFILTERING_ANISOTROPIC2: return fMaxAnisotropy >= 2.0;\n    default: return true;\n    }\n    \n    return false;\n}\n\n\n/*====================\n  GL_SetupTextureFilterSettings\n  ====================*/\nvoid    GL_SetupTextureFilterSettings()\n{\n    // texture filtering settings\n    float fMaxAnisotropy(1.0f);\n        \n    if (GLEW_EXT_texture_filter_anisotropic)\n        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &fMaxAnisotropy);\n        \n    switch (ETextureFilteringModes(vid_textureFiltering.GetValue()))\n    {\n    case TEXTUREFILTERING_NONE:\n        g_textureMagFilter = GL_NEAREST;\n        g_textureMinFilter = GL_NEAREST;\n        g_textureMinFilterMipmap = GL_NEAREST_MIPMAP_NEAREST;\n        g_textureMaxAnisotropy = 1.0f;\n        break;\n    case TEXTUREFILTERING_BILINEAR:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_NEAREST;\n        g_textureMaxAnisotropy = 1.0f;\n        break;\n    case TEXTUREFILTERING_TRILINEAR:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = 1.0f;\n        break;\n    case TEXTUREFILTERING_ANISOTROPIC2:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = MIN(2.0f, fMaxAnisotropy);\n        break;\n    case TEXTUREFILTERING_ANISOTROPIC4:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = MIN(4.0f, fMaxAnisotropy);\n        break;\n    case TEXTUREFILTERING_ANISOTROPIC6:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = MIN(6.0f, fMaxAnisotropy);\n        break;\n    case TEXTUREFILTERING_ANISOTROPIC8:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = MIN(8.0f, fMaxAnisotropy);\n        break;\n    case TEXTUREFILTERING_ANISOTROPIC12:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = MIN(12.0f, fMaxAnisotropy);\n        break;\n    case TEXTUREFILTERING_ANISOTROPIC16:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = MIN(16.0f, fMaxAnisotropy);\n        break;\n    case TEXTUREFILTERING_ANISOTROPIC32:\n        g_textureMagFilter = GL_LINEAR;\n        g_textureMinFilter = GL_LINEAR;\n        g_textureMinFilterMipmap = GL_LINEAR_MIPMAP_LINEAR;\n        g_textureMaxAnisotropy = MIN(32.0f, fMaxAnisotropy);\n        break;\n    case NUM_TEXTUREFILTERING_MODES:\n        K2_UNREACHABLE();\n        break;\n    }\n}\n\n\n/*====================\n  GL_BeginFrame\n  ====================*/\nvoid    GL_BeginFrame()\n{\n    GL_SetGamma(vid_gamma);\n    \n    g_bValidScene = true;\n\n    GfxShaders->Frame();\n}\n\n\n/*====================\n  GL_Global_EndFrame\n  ====================*/\nvoid    GL_Global_EndFrame()\n{\n    Gfx2D->Draw();\n    g_bValidScene = false;\n\n    GfxModels->lCustomMappings.clear();\n}\n\n\n/*====================\n  GL_RenderScene\n  ====================*/\nvoid    GL_RenderScene(CCamera &camera)\n{\n    Gfx2D->Draw();\n\n    glDepthMask(GL_TRUE);\n\n    if (!(camera.GetFlags() & CAM_NO_DEPTH_CLEAR))\n        glClear(GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n    \n    Gfx3D->Draw(camera);\n}\n\n\n/*====================\n  GL_Notify\n  ====================*/\nvoid    GL_Notify(EVidNotifyMessage eMsg, int iParam1, int iParam2, int iParam3, void *pData, const tstring &sResContext)\n{\n    K2_RESOURCE_CONTEXT(sResContext);\n\n    switch (eMsg)\n    {\n    case VID_NOTIFY_UPDATE_SHADERS:\n    case VID_NOTIFY_RELOAD_SHADER_CACHE:\n    case VID_NOTIFY_ADD_CLIFF:\n    case VID_NOTIFY_REMOVE_CLIFF:\n    case VID_NOTIFY_REBUILD_CLIFFS:\n    case VID_NOTIFY_FOG_OF_WAR:\n        break;\n    case VID_NOTIFY_NEW_WORLD:\n        GfxTerrain->Rebuild(terrain_chunkSize, static_cast<CWorld*>(pData));\n        GL_RebuildFoliage(foliage_chunkSize, static_cast<CWorld*>(pData));\n        break;\n\n    case VID_NOTIFY_WORLD_DESTROYED:\n        GfxTerrain->Destroy();\n        GL_DestroyFoliage();\n        break;\n\n    case VID_NOTIFY_TERRAIN_COLOR_MODIFIED:\n        if (iParam3)\n            GfxTerrain->InvalidateTerrainLayer(TERRAIN_REBUILD_COLORS | TERRAIN_REBUILD_TEXCOORDS);\n        else\n            GfxTerrain->InvalidateTerrainVertex(iParam1, iParam2, TERRAIN_REBUILD_COLORS);\n        break;\n\n    case VID_NOTIFY_TERRAIN_NORMAL_MODIFIED:\n        if (iParam3)\n            GfxTerrain->InvalidateTerrainLayer(TERRAIN_REBUILD_NORMALS | TERRAIN_REBUILD_TEXCOORDS);\n        else\n            GfxTerrain->InvalidateTerrainVertex(iParam1, iParam2, TERRAIN_REBUILD_NORMALS);\n        break;\n\n    case VID_NOTIFY_TERRAIN_VERTEX_MODIFIED:\n        if (iParam3)\n            GfxTerrain->InvalidateTerrainLayer(TERRAIN_REBUILD_VERTICES);\n        else\n            GfxTerrain->InvalidateTerrainVertex(iParam1, iParam2, TERRAIN_REBUILD_VERTICES);\n        break;\n\n    case VID_NOTIFY_TERRAIN_SHADER_MODIFIED:\n        if (iParam3)\n            GfxTerrain->InvalidateTerrainLayer(TERRAIN_REBUILD_SHADERS);\n        else\n            GfxTerrain->InvalidateTerrainVertex(iParam1, iParam2, TERRAIN_REBUILD_SHADERS);\n        break;\n\n    case VID_NOTIFY_TERRAIN_TEXCOORD_MODIFIED:\n        if (iParam3)\n            GfxTerrain->InvalidateTerrainLayer(TERRAIN_REBUILD_TEXCOORDS);\n        else\n            GfxTerrain->InvalidateTerrainVertex(iParam1, iParam2, TERRAIN_REBUILD_TEXCOORDS);\n        break;\n    case VID_NOTIFY_TERRAIN_TEXEL_ALPHA_MODIFIED:\n        if (iParam3)\n            GfxTerrain->InvalidateTerrainLayer(TERRAIN_REBUILD_SHADERS);\n        else\n            GfxTerrain->InvalidateTerrainTexel(iParam1, iParam2, TERRAIN_REBUILD_ALPHAMAP);\n        break;\n    case VID_NOTIFY_TEXTURE_FILTERING_SETTINGS_MODIFIED:\n        GL_SetupTextureFilterSettings();\n        break;\n    case VID_NOTIFY_FOLIAGE_TEXTURE_MODIFIED:\n        if (iParam3)\n            GL_InvalidateFoliageLayer(FOLIAGE_REBUILD_SHADERS);\n        else\n            GL_InvalidateFoliageTile(iParam1, iParam2, FOLIAGE_REBUILD_SHADERS);\n        break;\n\n    case VID_NOTIFY_FOLIAGE_DENSITY_MODIFIED:\n        if (iParam3)\n            GL_InvalidateFoliageLayer(FOLIAGE_REBUILD_VERTICES);\n        else\n            GL_InvalidateFoliageVertex(iParam1, iParam2, FOLIAGE_REBUILD_VERTICES);\n        break;\n\n    case VID_NOTIFY_FOLIAGE_SIZE_MODIFIED:\n        if (iParam3)\n            GL_InvalidateFoliageLayer(FOLIAGE_REBUILD_VERTICES);\n        else\n            GL_InvalidateFoliageVertex(iParam1, iParam2, FOLIAGE_REBUILD_VERTICES);\n        break;\n    case VID_NOTIFY_X11_EVENT:\n#ifdef linux\n        GL_X11_Event(static_cast<XEvent*>(pData));\n#else\n        break;\n#endif\n    }\n}\n\n\n/*====================\n  GL_Add2dRect\n  ====================*/\nvoid    GL_Add2dRect(float x, float y, float w, float h, float s1, float t1, float s2, float t2, ResHandle hTexture, int iFlags)\n{\n    Gfx2D->AddRect(x,y,w,h,s1,t1,s2,t2,hTexture,iFlags);\n}\n\n\n/*====================\n  GL_Add2dQuad\n  ====================*/\nvoid    GL_Add2dQuad(const CVec2f& v1, const CVec2f& v2, const CVec2f&      v3, const CVec2f& v4, const CVec2f& t1, const CVec2f& t2, const CVec2f& t3, const CVec2f& t4, ResHandle hTexture, int iFlags)\n{\n    Gfx2D->AddQuad(v1,v2,v3,v4,t1,t2,t3,t4,hTexture,iFlags);\n}\n\n\n/*====================\n  GL_Add2dLine\n  ====================*/\nvoid    GL_Add2dLine(const CVec2f& v1, const CVec2f& v2, const CVec4f &v4Color1, const CVec4f &v4Color2, int iFlags)\n{\n    Gfx2D->AddLine(v1,v2,v4Color1,v4Color2,iFlags);\n}\n\n\n/*====================\n  GL_AddPoint\n  ====================*/\nvoid    GL_AddPoint(const CVec3f &v3Point, const CVec4f &v4Color)\n{\n    Gfx3D->AddPoint(v3Point, v4Color);\n}\n\n\n/*====================\n  GL_AddLine\n  ====================*/\nvoid    GL_AddLine(const CVec3f &v3Start, const CVec3f &v3End, const CVec4f &v4Color)\n{\n    Gfx3D->AddLine(v3Start, v3End, v4Color);\n}\n\n\n/*====================\n  GL_SetColor\n  ====================*/\nvoid    GL_SetColor(CVec4f v4Color)\n{\n    GfxUtils->SetCurrentColor(v4Color);\n}\n\n\n/*====================\n  GL_GetFrameBuffer\n  ====================*/\nvoid    GL_GetFrameBuffer(CBitmap &bmp)\n{\n    bmp.Alloc(g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BITMAP_RGB);\n\n    glReadPixels(0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, GL_RGB, GL_UNSIGNED_BYTE, bmp.GetBuffer());\n\n    bmp.Flip();\n}\n\n\n/*====================\n  GL_ProjectVertex\n  ====================*/\nCVec2f  GL_ProjectVertex(const CCamera &cam, const CVec3f &vecVertex)\n{\n    return CVec2f(0, 0);\n}\n\n\n/*====================\n  GL_Clear\n  ====================*/\nvoid    GL_Clear()\n{\n    Gfx3D->Clear();\n}\n\n\n/*====================\n  GL_RegisterTexture\n  ====================*/\nint     GL_RegisterTexture(CTexture *pTexture)\n{\n    return GfxTextures->RegisterTexture(pTexture);\n}\n\n\n/*====================\n  GL_UnregisterTexture\n  ====================*/\nvoid    GL_UnregisterTexture(CTexture *pTexture)\n{\n    GfxTextures->UnregisterTexture(pTexture->GetPath());\n}\n\n\n/*====================\n  GL_RegisterModel\n  ====================*/\nint     GL_RegisterModel(CModel *pModel)\n{\n    return GfxModels->RegisterModel(pModel);\n}\n\n\n/*====================\n  GL_UnregisterModel\n  ====================*/\nvoid    GL_UnregisterModel(CModel *pModel)\n{\n    GfxModels->UnregisterModel(pModel);\n}\n\n\n/*====================\n  GL_RegisterVertexShader\n  ====================*/\nint     GL_RegisterVertexShader(CVertexShader *pVertexShader)\n{\n    return GfxShaders->RegisterVertexShader(pVertexShader);\n}\n\n\n/*====================\n  GL_UnregisterVertexShader\n  ====================*/\nvoid    GL_UnregisterVertexShader(CVertexShader *pVertexShader)\n{\n    GfxShaders->UnregisterVertexShader(pVertexShader);\n}\n\n\n/*====================\n  GL_RegisterPixelShader\n  ====================*/\nint     GL_RegisterPixelShader(CPixelShader *pPixelShader)\n{\n    return GfxShaders->RegisterPixelShader(pPixelShader);\n}\n\n\n/*====================\n  GL_UnregisterPixelShader\n  ====================*/\nvoid    GL_UnregisterPixelShader(CPixelShader *pPixelShader)\n{\n    return GfxShaders->UnregisterPixelShader(pPixelShader);\n}\n\n\n/*====================\n  GL_RegisterShaderPair\n  ====================*/\nvoid    GL_RegisterShaderPair(CVertexShader *pVertexShader, CPixelShader *pPixelShader)\n{   \n    GfxShaders->RegisterShaderPair(pVertexShader, pPixelShader);\n}\n\n\n/*====================\n  GL_GetCamera\n  ====================*/\nconst CCamera*  GL_GetCamera()\n{\n    return g_pCam;\n}\n\n\n/*====================\n  GL_RenderFogofWar\n  ====================*/\nvoid    GL_RenderFogofWar(float fClear, bool bTexture, float fLerp)\n{\n    g_FogofWar.Render(fClear, bTexture, fLerp);\n}\n\n\n/*====================\n  GL_UpdateFogofWar\n  ====================*/\nvoid    GL_UpdateFogofWar(const CBitmap &cBmp)\n{\n    g_FogofWar.Update(cBmp);\n}\n\n\n/*====================\n  GL_GetTextureColor\n  ====================*/\nCVec4f  GL_GetTextureColor(CTexture *pResource)\n{\n    glPushAttrib(GL_ENABLE_BIT);\n\n    glActiveTextureARB(GL_TEXTURE0_ARB);\n\n    glBindTexture(GL_TEXTURE_2D, pResource->GetIndex());\n\n    int iMaxTextureSize;\n    glGetIntegerv(GL_MAX_TEXTURE_SIZE, (GLint*)(&iMaxTextureSize));\n\n    int iMaxLevel(INT_ROUND(log(float(iMaxTextureSize)) / log(2.0f)));\n\n    int iLevel(0);\n    \n    GLint iTextureWidth;\n    glGetTexLevelParameteriv(GL_TEXTURE_2D, iLevel, GL_TEXTURE_WIDTH, &iTextureWidth);\n    \n    GLint iTextureHeight;\n    glGetTexLevelParameteriv(GL_TEXTURE_2D, iLevel, GL_TEXTURE_HEIGHT, &iTextureHeight);\n\n    while (iLevel < iMaxLevel)\n    {\n        int iNextLevel(iLevel + 1);\n\n        GLint iNextTextureWidth;\n        glGetTexLevelParameteriv(GL_TEXTURE_2D, iNextLevel, GL_TEXTURE_WIDTH, &iNextTextureWidth);\n        \n        GLint iNextTextureHeight;\n        glGetTexLevelParameteriv(GL_TEXTURE_2D, iNextLevel, GL_TEXTURE_WIDTH, &iNextTextureHeight);\n\n        if (iNextTextureWidth == 0 || iNextTextureHeight == 0)\n            break;\n\n        iTextureWidth = iNextTextureWidth;\n        iTextureHeight = iNextTextureHeight;\n        iLevel = iNextLevel;\n    }\n\n    if (iTextureWidth == 1 && iTextureHeight == 1)\n    {\n        byte color[4];\n        glGetTexImage(GL_TEXTURE_2D, iLevel, GL_RGBA, GL_UNSIGNED_BYTE, &color);\n\n        glPopAttrib();\n\n        return CVec4f(color[0] / 255.0f, color[1] / 255.0f, color[2] / 255.0f, color[3] / 255.0f);\n    }\n    else\n    {\n        glPopAttrib();\n\n        return WHITE;\n    }\n    \n}\n\n\n/*====================\n  InitAPIs\n\n  Sets up calls for core engine into vid code\n  ====================*/\nvoid    InitAPIs_Global(SVidDriver *vid_api)\n{\n    vid_api->sDriverName = _T(\"OpenGL 2.1 [GLSL]\");\n\n    vid_api->Init = GL_Init;\n    vid_api->Start = GL_Start;\n    vid_api->SetMode = GL_SetMode;\n    vid_api->GetMode = GL_GetMode;\n    vid_api->GetCurrentMode = GL_GetCurrentMode;\n    vid_api->IsFullScreen = GL_IsFullScreen;\n    vid_api->Shutdown = GL_Shutdown;\n    \n    vid_api->TextureFilteringModeAvailable = GL_TextureFilteringModeAvailable;\n\n    vid_api->BeginFrame = GL_BeginFrame;\n    vid_api->EndFrame = GL_EndFrame;\n    vid_api->RenderScene = GL_RenderScene;\n    vid_api->Add2dRect = GL_Add2dRect;\n    vid_api->Add2dQuad = GL_Add2dQuad;\n    vid_api->Add2dLine = GL_Add2dLine;\n    vid_api->AddPoint = GL_AddPoint;\n    vid_api->AddLine = GL_AddLine;\n    vid_api->SetColor = GL_SetColor;\n    vid_api->Notify = GL_Notify;\n    vid_api->GetFrameBuffer = GL_GetFrameBuffer;\n    vid_api->ProjectVertex = GL_ProjectVertex;\n    \n    vid_api->GetHWnd = GL_GetHWnd;\n    vid_api->Clear = GL_Clear;\n\n    vid_api->OpenTextureArchive = GL_OpenTextureArchive;\n    vid_api->CloseTextureArchive = GL_CloseTextureArchive;\n    vid_api->GetTextureList = GL_GetTextureList;\n    vid_api->TextureExists = GL_TextureExists;\n    \n    vid_api->RegisterTexture = GL_RegisterTexture;\n    vid_api->UnregisterTexture = GL_UnregisterTexture;\n    \n    vid_api->RegisterVertexShader = GL_RegisterVertexShader;\n    vid_api->UnregisterVertexShader = GL_UnregisterVertexShader;\n    \n    vid_api->RegisterPixelShader = GL_RegisterPixelShader;\n    vid_api->UnregisterPixelShader = GL_UnregisterPixelShader;\n    \n    vid_api->RegisterShaderPair = GL_RegisterShaderPair;\n    \n    vid_api->RegisterModel = GL_RegisterModel;\n    vid_api->UnregisterModel = GL_UnregisterModel;\n    \n    vid_api->GetCamera = GL_GetCamera;\n    \n    vid_api->RenderFogofWar = GL_RenderFogofWar;\n    vid_api->UpdateFogofWar = GL_UpdateFogofWar;\n\n    vid_api->ShowCursor = GL_ShowCursor;\n    vid_api->SetCursor = GL_SetCursor;\n    \n    vid_api->GetTextureColor = GL_GetTextureColor;\n    \n    vid_api->GetAAMode = GL_GetAAMode;\n    vid_api->GetCurrentAAMode = GL_GetCurrentAAMode;\n}\n\n\n/*--------------------\n  cmdVidReset\n  --------------------*/\nCMD(VidReset)\n{\n    GL_SetMode();\n\n    return true;\n}\n\n\n/*--------------------\n  ListVidModes\n  --------------------*/\nCMD(ListVidModes)\n{\n    for (int i(0); i < g_iNumVidModes; ++i)\n        Console << XtoA(i, 2) << _T(\": \") << g_VidModes[i].sName << newl;\n    return true;\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/vid_gl2/gl2_main.cpp b/src/vid_gl2/gl2_main.cpp
--- a/src/vid_gl2/gl2_main.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/vid_gl2/gl2_main.cpp	(date 1684987088112)
@@ -162,6 +162,16 @@
     return true;
 }
 
+/*====================
+  GL_GetMaxWindowSize
+  ====================*/
+bool    GL_GetMaxWindowSize(SVidMode *pVidMode)
+{
+    if (!pVidMode)
+        return false;
+    return true;
+}
+
 
 /*====================
   GL_IsFullScreen
Index: src/k2/c_skeleton.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_skeleton.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_skeleton.h\"\n#include \"c_k2model.h\"\n#include \"c_anim.h\"\n#include \"c_bone.h\"\n#include \"c_mesh.h\"\n#include \"c_model.h\"\n#include \"c_clip.h\"\n#include \"i_resource.h\"\n#include \"c_skeletonbonepool.h\"\n#include \"c_resourcemanager.h\"\n\n#include \"../public/modelclip_t.h\"\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\nCVAR_BOOL(skel_interpolate, true);\nCVAR_BOOL(skel_blendAnims, true);\nCVAR_BOOL(skel_noPose, false);\nCVAR_BOOL(skel_debug, false);\n//=============================================================================\n\n/*====================\n  CSkeleton::CSkeleton\n  ====================*/\nCSkeleton::CSkeleton() :\nm_pBoneStates(nullptr),\nm_pTempBoneStates(nullptr),\nm_uiNumBones(0),\nm_bIsValid(false),\n\nm_bIsCharacter(false),\nm_uiPoseTime(INVALID_TIME),\nm_uiPrevPoseTime(INVALID_TIME),\nm_uiSavedPoseTime(INVALID_TIME),\nm_fPrevPitch(0.0f),\nm_fPitch(0.0f),\nm_fPrevYaw(0.0f),\nm_fYaw(0.0f),\n\nm_sDefaultAnimName(_T(\"idle\")),\n\nm_hModel(INVALID_RESOURCE),\nm_pModel(nullptr)\n{\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        m_pAnim[i] = nullptr;\n        m_fSpeed[i] = 1.0f;\n        m_uiForceLength[i] = 0;\n        m_bPassiveAnim[i] = true;\n        m_pCurrentPose[i] = nullptr;\n        m_pSavedPose[i] = nullptr;\n        m_pTempPose[i] = nullptr;\n        m_iParentChannel[i] = -1;\n        m_bValidPose[i] = false;\n        m_uiStartTime[i] = INVALID_TIME;\n        m_fSpeed[i] = 1.0f;\n        m_uiForceLength[i] = 0;\n        m_iOffsetTime[i] = 0;\n        m_aAnimRequest[i].sAnim.clear();\n        m_aAnimRequest[i].uiTime = INVALID_TIME;\n    }\n\n    Clear();\n}\n\n\n/*====================\n  CSkeleton::~CSkeleton\n  ====================*/\nCSkeleton::~CSkeleton()\n{\n    // Give the bone data back to the pool\n    SSkeletonBoneData cBoneData;\n    cBoneData.uiNumBones = m_uiNumBones;\n    \n    cBoneData.pBoneStates = m_pBoneStates;\n    cBoneData.pTempBoneStates = m_pTempBoneStates;\n\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        cBoneData.pCurrentPose[i] = m_pCurrentPose[i];\n        cBoneData.pSavedPose[i] = m_pSavedPose[i];\n        cBoneData.pTempPose[i] = m_pTempPose[i];\n    }\n\n    SkeletonBonePool.Deallocate(cBoneData);\n\n    g_ResourceManager.RemoveResourceWatcher(this, m_hModel);\n}\n\n\n/*====================\n  CSkeleton::SetBoneState\n  ====================*/\nvoid    CSkeleton::SetBoneState(uint uiBone, int iState)\n{\n    if (uiBone == INVALID_BONE)\n        return;\n\n    m_pBoneStates[uiBone].poseState = iState;\n\n    CBone *pBone(m_pModel->GetBone(uiBone));\n    uint uiNumChildren(pBone->NumChildren());\n    for (uint n(0); n < uiNumChildren; ++n)\n    {\n        uint uiChild(pBone->GetChildIndex(n));\n        SetBoneState(uiChild, iState);\n    }\n}\n\n\n/*====================\n  CSkeleton::SetBoneState\n  ====================*/\nvoid    CSkeleton::SetBoneState(const tstring &sBoneName, int iState)\n{\n    uint uiBone(m_pModel->GetBoneIndex(sBoneName));\n    if (uiBone == INVALID_BONE)\n        return;\n\n    SetBoneState(uiBone, iState);\n}\n\n\n/*====================\n  CSkeleton::SetBoneState\n  ====================*/\nvoid    CSkeleton::SetBoneState(int iState)\n{\n    for (uint n(0); n < m_uiNumBones; ++n)\n        m_pBoneStates[n].poseState = iState;\n}\n\n\n\n/*====================\n  CSkeleton::Clear\n  ====================*/\nvoid    CSkeleton::Clear()\n{\n    // Give the bone data back to the pool\n    SSkeletonBoneData cBoneData;\n    cBoneData.uiNumBones = m_uiNumBones;\n    cBoneData.pBoneStates = m_pBoneStates;\n    cBoneData.pTempBoneStates = m_pTempBoneStates;\n\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        cBoneData.pCurrentPose[i] = m_pCurrentPose[i];\n        cBoneData.pSavedPose[i] = m_pSavedPose[i];\n        cBoneData.pTempPose[i] = m_pTempPose[i];\n    }\n\n    SkeletonBonePool.Deallocate(cBoneData);\n\n    m_uiNumBones = 0;\n    m_pBoneStates = nullptr;\n    m_pTempBoneStates = nullptr;\n\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        m_pCurrentPose[i] = nullptr;\n        m_pSavedPose[i] = nullptr;\n        m_pTempPose[i] = nullptr;\n    }\n\n    m_pModel = nullptr;\n    m_bIsValid = false;\n\n    m_bIsCharacter = false;\n    m_uiPoseTime = INVALID_TIME;\n    m_uiPrevPoseTime = INVALID_TIME;\n    m_uiSavedPoseTime = INVALID_TIME;\n\n    m_fYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPrevPitch = 0.0f;\n\n    for (int n(0); n < NUM_ANIM_CHANNELS; ++n)\n    {\n        m_pAnim[n] = nullptr;\n        m_uiBlendTime[n] = 0;\n        m_uiBlendStartTime[n] = 0;\n        m_uiTime[n] = 0;\n        m_iParentChannel[n] = n;\n        m_iLastAnimTime[n] = 0;\n        m_bPassiveAnim[n] = true;\n        m_bValidPose[n] = false;\n        m_uiStartTime[n] = INVALID_TIME;\n        m_fSpeed[n] = 1.0f;\n        m_uiForceLength[n] = 0;\n        m_iOffsetTime[n] = 0;\n\n        m_aAnimRequest[n].sAnim.clear();\n        m_aAnimRequest[n].uiTime = INVALID_TIME;\n    }\n\n    ClearEvents();\n}\n\n\n/*====================\n  CSkeleton::GetBoneXform\n  ====================*/\nvoid    CSkeleton::GetBoneXform(SBoneMotion *pMotion, int iLoFrame, int iHiFrame, float fLerp, SBoneXForm &cBone)\n{   \n    if (skel_interpolate)\n    {\n        // Translation\n        cBone.v3Pos.x = pMotion->keys_x.num_keys == 1 ? pMotion->keys_x.keys[0] : LERP(fLerp, pMotion->keys_x.keys[iLoFrame], pMotion->keys_x.keys[iHiFrame]);\n        cBone.v3Pos.y = pMotion->keys_y.num_keys == 1 ? pMotion->keys_y.keys[0] : LERP(fLerp, pMotion->keys_y.keys[iLoFrame], pMotion->keys_y.keys[iHiFrame]);\n        cBone.v3Pos.z = pMotion->keys_z.num_keys == 1 ? pMotion->keys_z.keys[0] : LERP(fLerp, pMotion->keys_z.keys[iLoFrame], pMotion->keys_z.keys[iHiFrame]);\n\n        // Rotation\n        if (pMotion->keys_quat.num_keys == 1)\n        {\n            M_CopyVec4(pMotion->keys_quat.keys[0], vec4_cast(cBone.v4Quat));\n        }\n        else\n        {\n            M_LerpQuat(fLerp,\n                pMotion->keys_quat.keys[iLoFrame % pMotion->keys_quat.num_keys],\n                pMotion->keys_quat.keys[iHiFrame % pMotion->keys_quat.num_keys],\n                vec4_cast(cBone.v4Quat));\n        }\n\n        // Scale\n        cBone.v3Scale.x = pMotion->keys_scalex.num_keys == 1 ? pMotion->keys_scalex.keys[0] : LERP(fLerp, pMotion->keys_scalex.keys[iLoFrame], pMotion->keys_scalex.keys[iHiFrame]);\n        cBone.v3Scale.y = pMotion->keys_scaley.num_keys == 1 ? pMotion->keys_scaley.keys[0] : LERP(fLerp, pMotion->keys_scaley.keys[iLoFrame], pMotion->keys_scaley.keys[iHiFrame]);\n        cBone.v3Scale.z = pMotion->keys_scalez.num_keys == 1 ? pMotion->keys_scalez.keys[0] : LERP(fLerp, pMotion->keys_scalez.keys[iLoFrame], pMotion->keys_scalez.keys[iHiFrame]);\n    }\n    else\n    {\n        // Translation\n        cBone.v3Pos.x = pMotion->keys_x.keys[iLoFrame % pMotion->keys_x.num_keys];\n        cBone.v3Pos.y = pMotion->keys_y.keys[iLoFrame % pMotion->keys_y.num_keys];\n        cBone.v3Pos.z = pMotion->keys_z.keys[iLoFrame % pMotion->keys_z.num_keys];\n        M_CopyVec4(pMotion->keys_quat.keys[iLoFrame % pMotion->keys_quat.num_keys], vec4_cast(cBone.v4Quat));\n\n        // Scale\n        cBone.v3Scale.x = pMotion->keys_scalex.keys[iLoFrame % pMotion->keys_scalex.num_keys];\n        cBone.v3Scale.y = pMotion->keys_scaley.keys[iLoFrame % pMotion->keys_scaley.num_keys];\n        cBone.v3Scale.z = pMotion->keys_scalez.keys[iLoFrame % pMotion->keys_scalez.num_keys];\n    }\n}\n\n\n/*====================\n  CSkeleton::PoseBones\n  ====================*/\nvoid    CSkeleton::PoseBones(SBoneMotion **ppMotions, int iLoFrame, int iHiFrame, float fLerp, int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone, ++ppMotions)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n\n        SBoneMotion *pMotion(*ppMotions);\n\n        if (!pMotion)\n        {\n            m_pCurrentPose[iChannel][uiBone].v3Pos = CVec3f(0.0f, 0.0f, 0.0f);\n            m_pCurrentPose[iChannel][uiBone].v4Quat = CVec4f(0.0f, 0.0f, 0.0f, 1.0f);\n            m_pCurrentPose[iChannel][uiBone].v3Scale = CVec3f(1.0f, 1.0f, 1.0f);\n            \n            pBoneState->visibility = 255;\n            continue;\n        }\n\n        GetBoneXform(pMotion, iLoFrame, iHiFrame, fLerp, m_pCurrentPose[iChannel][uiBone]);\n        \n        // Update bone sisibility\n        if (pMotion->keys_visibility.num_keys == 0)\n            pBoneState->visibility = 255;\n        else\n            pBoneState->visibility = pMotion->keys_visibility.num_keys == 1 ?\n                pMotion->keys_visibility.keys[0] : pMotion->keys_visibility.keys[iLoFrame % pMotion->keys_visibility.num_keys];\n    }\n}\n\n\n/*====================\n  CSkeleton::UpdateBones\n\n  update skeleton local tms\n  ====================*/\nvoid    CSkeleton::UpdateBones(int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n        \n        SBoneXForm &cCurrentPose(m_pCurrentPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = cCurrentPose.v3Pos;\n\n        // Rotation\n        M_QuatToAxis(vec4_cast(cCurrentPose.v4Quat), pBoneState->tm.axis);\n\n        // Scale\n        if (cCurrentPose.v3Scale[X] != 1.0f)\n            M_MultVec3(pBoneState->tm.axis[X], cCurrentPose.v3Scale[X], pBoneState->tm.axis[X]);\n        if (cCurrentPose.v3Scale[Y] != 1.0f)\n            M_MultVec3(pBoneState->tm.axis[Y], cCurrentPose.v3Scale[Y], pBoneState->tm.axis[Y]);\n        if (cCurrentPose.v3Scale[Z] != 1.0f)\n            M_MultVec3(pBoneState->tm.axis[Z], cCurrentPose.v3Scale[Z], pBoneState->tm.axis[Z]);\n    }\n}\n\n\n/*====================\n  CSkeleton::UpdateBonesLerp\n\n  update skeleton local tms\n  ====================*/\nvoid    CSkeleton::UpdateBonesLerp(float fLerp, int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n        \n        SBoneXForm &cSavedPose(m_pSavedPose[iChannel][uiBone]);\n        SBoneXForm &cCurrentPose(m_pCurrentPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = LERP(fLerp, cSavedPose.v3Pos, cCurrentPose.v3Pos);\n\n        // Rotation\n        vec4_t quat;\n        M_LerpQuat(fLerp, vec4_cast(cSavedPose.v4Quat), vec4_cast(cCurrentPose.v4Quat), vec4_cast(quat));\n        M_QuatToAxis(quat, pBoneState->tm.axis);\n\n        // Scale\n        M_MultVec3(pBoneState->tm.axis[X], LERP(fLerp, cSavedPose.v3Scale[X], cCurrentPose.v3Scale[X]), pBoneState->tm.axis[X]);\n        M_MultVec3(pBoneState->tm.axis[Y], LERP(fLerp, cSavedPose.v3Scale[Y], cCurrentPose.v3Scale[Y]), pBoneState->tm.axis[Y]);\n        M_MultVec3(pBoneState->tm.axis[Z], LERP(fLerp, cSavedPose.v3Scale[Z], cCurrentPose.v3Scale[Z]), pBoneState->tm.axis[Z]);\n    }\n}\n\n\n\n/*====================\n  CSkeleton::BlendBones\n\n  Update the current skeleton quats to most recent blend so we can save the values\n  to be used in a new blend.  This only happens during a StartAnim call.\n  ====================*/\nvoid    CSkeleton::BlendBones(float fLerp, int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n        \n        SBoneXForm &cSavedPose(m_pSavedPose[iChannel][uiBone]);\n        SBoneXForm &cCurrentPose(m_pCurrentPose[iChannel][uiBone]);\n\n        cCurrentPose.v3Pos = LERP(fLerp, cSavedPose.v3Pos, cCurrentPose.v3Pos);\n        M_LerpQuat(fLerp, vec4_cast(cSavedPose.v4Quat), vec4_cast(cCurrentPose.v4Quat), vec4_cast(cCurrentPose.v4Quat));\n        cCurrentPose.v3Scale = LERP(fLerp, cSavedPose.v3Scale, cCurrentPose.v3Scale);\n    }\n}\n\n\n/*====================\n  CSkeleton::SetAnim\n  ====================*/\nvoid    CSkeleton::SetAnim(const tstring &sAnim, uint uiTime, int iBlendTime, int iChannel, float fSpeed, uint uiForceLength, bool bStartEvent, bool bEndEvent)\n{\n    if (!m_pModel)\n        return;\n\n    m_bPassiveAnim[iChannel] = (sAnim == m_sDefaultAnimName);\n\n    CAnim *pNewAnim(m_pModel->GetAnim(sAnim));\n\n    if (!pNewAnim)\n        return;\n\n    CAnim *pOldAnim(m_pAnim[iChannel]);\n\n    // Add end events\n    if (pOldAnim && bEndEvent)\n    {\n        const tsvector &vEndEvents(pOldAnim->GetEndEvents());\n        for (tsvector::const_iterator it(vEndEvents.begin()); it != vEndEvents.end(); ++it)\n            AddEvent(*it, 0);\n    }\n\n    m_pAnim[iChannel] = pNewAnim;\n\n    // Calculate and save the current pose for blending\n    if (iChannel == 1)\n    {\n        SetBoneState(POSE_MASKED);\n        SetBoneState(_T(\"Bip01 Spine\"), 0);\n    }\n\n    uint uiBlendTime(m_fSpeed[iChannel] != 0.0f ? INT_ROUND(m_uiBlendTime[iChannel] / m_fSpeed[iChannel]) : 0);\n\n    if (uiBlendTime && uiTime - m_uiBlendStartTime[iChannel] < uiBlendTime && skel_blendAnims)\n    {\n        float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(uiBlendTime)));\n        BlendBones(fBlend, iChannel);\n    }\n\n    if (iChannel == 1)\n        SetBoneState(0);\n\n    if (pOldAnim && m_bValidPose[iChannel])\n    {\n        // Start a new blend\n        MemManager.Copy(m_pSavedPose[iChannel], m_pCurrentPose[iChannel], sizeof(SBoneXForm) * m_pModel->GetNumBones());\n\n        if (iBlendTime == -1)\n            iBlendTime = pNewAnim->GetBlendTime();\n\n        m_uiBlendTime[iChannel] = iBlendTime;\n    }\n    else\n    {\n        m_uiBlendTime[iChannel] = 0;\n    }\n\n    m_uiBlendStartTime[iChannel] = uiTime;\n    m_uiStartTime[iChannel] = uiTime;\n    m_fSpeed[iChannel] = fSpeed;\n    m_uiForceLength[iChannel] = uiForceLength;\n    m_iOffsetTime[iChannel] = (M_Randnum(m_pAnim[iChannel]->GetMinStartFrame(), m_pAnim[iChannel]->GetMaxStartFrame()) - m_pAnim[iChannel]->GetStartFrame()) * m_pAnim[iChannel]->GetMSperFrame();\n    m_iLastAnimTime[iChannel] = m_iOffsetTime[iChannel];\n    m_uiPoseTime = INVALID_TIME;\n\n    // Add start events\n    if (pNewAnim && bStartEvent)\n    {\n        const tsvector &vStartEvents(pNewAnim->GetStartEvents());\n        for (tsvector::const_iterator it(vStartEvents.begin()); it != vStartEvents.end(); ++it)\n            AddEvent(*it, 0);\n    }\n}\n\n\n/*====================\n  CSkeleton::StartAnim\n  ====================*/\nint     CSkeleton::StartAnim(const tstring &sAnim, uint uiTime, int iChannel, int iBlendTime, float fSpeed, uint uiForceLength)\n{\n    PROFILE(\"CSkeleton::StartAnim\");\n\n    if (!m_pModel)\n        return -1;\n\n    assert(iChannel >= 0 && iChannel < NUM_ANIM_CHANNELS); \n\n    //Console.Dev << \"CSkeleton::StartAnim() - \" << sAnim << _T(\" \") << uiTime << _T(\" \") << iChannel << newl;\n\n    // Update old anims to the current time\n    if (m_uiPoseTime != uiTime && HasValidAnims())\n        Pose(uiTime);\n\n    SetAnim(sAnim, uiTime, iBlendTime, iChannel, fSpeed, uiForceLength, true, true);\n    m_iParentChannel[iChannel] = iChannel;\n\n    for (int i(0); i < NUM_ANIM_CHANNELS; ++i)\n    {\n        CAnim *pDefaultAnim = m_pModel->GetAnim(m_sDefaultAnimName);\n\n        if (iChannel != i && (m_bPassiveAnim[i] || m_iParentChannel[i] == iChannel) && !(pDefaultAnim && pDefaultAnim->GetLock()))\n        {\n            SetAnim(sAnim, uiTime, iBlendTime, i, fSpeed, uiForceLength, false, false);\n            m_iParentChannel[i] = iChannel;\n        }\n    }\n    return -1;\n}\n\n\n/*====================\n  CSkeleton::StopAnim\n  ====================*/\nvoid    CSkeleton::StopAnim(int iChannel, uint uiTime)\n{\n    PROFILE(\"CSkeleton::StartAnim\");\n\n    if (iChannel < 0 || iChannel > NUM_ANIM_CHANNELS)\n    {\n        Console.Warn << _T(\"CSkeleton::StopAnim() - Invalid channel: \") << iChannel << newl;\n        return;\n    }\n\n    CAnim *pDefaultAnim(m_pModel->GetAnim(m_sDefaultAnimName));\n\n    // If possible, synch with channel zero, otherwise fall\n    // back to the current default anim\n    if (iChannel != 0 && m_pAnim[0] != nullptr && !(pDefaultAnim && pDefaultAnim->GetLock()))\n    {\n        if (m_iParentChannel[0] == iChannel)\n            StopAnim(0, uiTime);\n\n        SetAnim(m_pAnim[0]->GetName(), uiTime, -1, iChannel, m_fSpeed[0], m_uiForceLength[0], false, m_iParentChannel[iChannel] != iChannel);\n        m_uiStartTime[iChannel] = m_uiStartTime[0];\n        m_fSpeed[iChannel] = m_fSpeed[0];\n        m_uiForceLength[iChannel] = m_uiForceLength[0];\n        m_iOffsetTime[iChannel] = m_iOffsetTime[0];\n        m_iParentChannel[iChannel] = 0;\n    }\n    else\n    {\n        SetAnim(m_sDefaultAnimName, uiTime, -1, iChannel, 1.0f, 0, iChannel == 0, iChannel == 0);\n        m_iParentChannel[iChannel] = iChannel;\n    }\n}\n\n\n/*====================\n  CSkeleton::HasAnim\n  ====================*/\nbool    CSkeleton::HasAnim(const tstring &sAnim)\n{\n    if (!m_pModel)\n        return false;\n\n    return (m_pModel->GetAnim(sAnim) != nullptr);\n}\n\n\n/*====================\n  CSkeleton::ProcessAnimRequests\n  ====================*/\nvoid    CSkeleton::ProcessAnimRequests(uint uiTime)\n{\n    // Process StopAnim's\n    for (int n(0); n < NUM_ANIM_CHANNELS; ++n)\n    {\n        if (m_aAnimRequest[n].uiTime == INVALID_TIME)\n            continue;\n\n        if (m_aAnimRequest[n].sAnim.empty())\n        {\n            StopAnim(n, m_aAnimRequest[n].uiTime);\n\n            m_aAnimRequest[n].sAnim.clear();\n            m_aAnimRequest[n].uiTime = INVALID_TIME;\n        }\n    }\n\n    // Process StartAnim's\n    for (int n(NUM_ANIM_CHANNELS - 1); n >= 0; --n)\n    {\n        if (m_aAnimRequest[n].uiTime == INVALID_TIME)\n            continue;\n\n        if (!m_aAnimRequest[n].sAnim.empty())\n        {\n            StartAnim(m_aAnimRequest[n].sAnim, m_aAnimRequest[n].uiTime, n, m_aAnimRequest[n].iBlendTime, m_aAnimRequest[n].fSpeed, m_aAnimRequest[n].uiForceLength);\n\n            m_aAnimRequest[n].sAnim.clear();\n            m_aAnimRequest[n].uiTime = INVALID_TIME;\n        }\n    }\n}\n\n\n/*====================\n  CSkeleton::PoseStandard\n  ====================*/\nvoid    CSkeleton::PoseStandard(uint uiTime)\n{\n    PROFILE(\"CSkeleton::PoseStandard\");\n\n    m_bIsCharacter = false;\n    m_fPrevPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fYaw = 0.0f;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    PoseSkeleton(uiTime, 0);\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::Pose\n  ====================*/\nvoid    CSkeleton::Pose(uint uiTime, float fParam1, float fParam2)\n{\n    if (m_pModel == nullptr)\n        return;\n\n    m_uiPrevPoseTime = m_uiPoseTime;\n    m_uiPoseTime = uiTime;\n\n    ProcessAnimRequests(uiTime);\n\n    switch(m_pModel->GetPoseType())\n    {\n    default:\n    case POSE_STANDARD:\n        PoseStandard(uiTime);\n        break;\n\n    case POSE_CHARACTER:\n        PoseCharacter(uiTime, fParam1, fParam2);\n        break;\n\n    case POSE_VEHICLE:\n        PoseVehicle(uiTime, fParam1);\n        break;\n\n    case POSE_GADGET:\n        PoseGadget(uiTime, fParam1, fParam2);\n        break;\n    }\n}\n\n\n/*====================\n  CSkeleton::PoseCharacter\n\n  Specialized character version of the Pose functions\n  ====================*/\nvoid    CSkeleton::PoseCharacter(uint uiTime, float fPitch, float fYaw)\n{\n    PROFILE(\"CSkeleton::PoseCharacter\");\n\n    m_bIsCharacter = true;\n    m_fPrevPitch = m_fPitch;\n    m_fPrevYaw = m_fYaw;\n    m_fPitch = fPitch;\n    m_fYaw = fYaw;\n    m_uiSavedPoseTime = uiTime;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    uint uiBip01Spine(m_pModel->GetBoneIndex(_T(\"Bip01 Spine\")));\n\n    // *** Channel 0 ***\n    // Mask everything above the spine\n    SetBoneState(0);\n    SetBoneState(uiBip01Spine, POSE_MASKED);\n\n    PoseSkeleton(uiTime, 0);\n\n    // *** Channel 1 ***\n    // Mask everything below the spine so only the upper\n    // body gets posed\n    SetBoneState(POSE_MASKED);\n    SetBoneState(uiBip01Spine, 0);\n\n    PoseSkeleton(uiTime, 1);\n\n    if (fPitch > 180.0f)\n        fPitch -= 360.0f;\n    if (fPitch < -180.0f)\n        fPitch += 360.0f;\n\n    if (fYaw > 180.0f)\n        fYaw -= 360.0f;\n    if (fYaw < -180.0f)\n        fYaw += 360.0f;\n\n    // Head movements\n    // HACK: For some reason pitch and yaw values are swapped in the biped\n    // Biped orients X towards children\n    RotateBone(_T(\"Bip01 Head\"), -fPitch / 4.0f, 0, fYaw * 0.25f, true);\n    RotateBone(_T(\"Bip01 Spine\"), -fPitch / 6.0f, 0, fYaw * 0.75f, true);\n\n    // Get the final world coordinate transformation, then\n    // unmask the legs\n    SetBoneState(0);\n\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::PoseVehicle\n\n  Specialized character version of the Pose functions\n  ====================*/\nvoid    CSkeleton::PoseVehicle(uint uiTime, uint uiWheelTime)\n{\n    PROFILE(\"CSkeleton::PoseVehicle\");\n\n    m_bIsCharacter = false;\n    m_fPrevPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fYaw = 0.0f;\n\n    // Make the posing happier\n    m_uiStartTime[0] = 0;\n    m_uiBlendTime[0] = 0;\n    m_uiBlendStartTime[0] = 0;\n    m_iOffsetTime[0] = 0;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    // *** Channel 0 ***\n    // Mask everything above the spine\n    SetBoneState(0);\n    SetBoneState(_T(\"Bip01 Spine\"), POSE_MASKED);\n\n    PoseSkeleton(uiWheelTime, 0);\n\n    // *** Channel 1 ***\n    // Mask everything below the spine so only the upper\n    // body gets posed\n    SetBoneState(POSE_MASKED);\n    SetBoneState(_T(\"Bip01 Spine\"), 0);\n\n    PoseSkeleton(uiTime, 1);\n\n    // Get the final world coordinate transformation, then\n    // unmask the legs\n    SetBoneState(0);\n\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::PoseGadget\n\n  Specialized character version of the Pose functions\n  ====================*/\nvoid    CSkeleton::PoseGadget(uint uiTime, float fPitch, float fYaw)\n{\n    PROFILE(\"CSkeleton::PoseGadget\");\n\n    m_bIsCharacter = true;\n    m_fPrevPitch = m_fPitch;\n    m_fPrevYaw = m_fYaw;\n    m_fPitch = fPitch;\n    m_fYaw = fYaw;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    PoseSkeleton(uiTime, 0);\n\n    if (fPitch > 180.0f)\n        fPitch -= 360.0f;\n    if (fPitch < -180.0f)\n        fPitch += 360.0f;\n\n    if (fYaw > 180.0f)\n        fYaw -= 360.0f;\n    if (fYaw < -180.0f)\n        fYaw += 360.0f;\n\n    RotateBone(_T(\"gun_pivot\"), fYaw, 0, -fPitch, true);\n\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::PoseLite\n  ====================*/\nvoid    CSkeleton::PoseLite(uint uiTime)\n{\n    if (m_pModel == nullptr)\n        return;\n\n    ProcessAnimRequests(uiTime);\n\n    switch (m_pModel->GetPoseType())\n    {\n    default:\n    case POSE_STANDARD:\n    case POSE_GADGET:\n        PoseSkeletonLite(uiTime, 0);\n        break;\n\n    case POSE_CHARACTER:\n    case POSE_VEHICLE:\n        PoseSkeletonLite(uiTime, 0);\n        PoseSkeletonLite(uiTime, 1);\n        break;\n    }\n}\n\n\n/*====================\n  CSkeleton::CheckAnims\n  ====================*/\nbool    CSkeleton::CheckAnims(uint uiTime)\n{\n    for (int iChannel(0); iChannel < NUM_ANIM_CHANNELS; ++iChannel)\n    {\n        if (m_pAnim[iChannel] == nullptr)\n            StartAnim(m_sDefaultAnimName, uiTime, iChannel);\n        if (m_pAnim[iChannel] == nullptr)\n        {\n            Invalidate();\n            return false;\n        }\n        //else\n        //  m_bPassiveAnim[iChannel] = (m_pAnim[iChannel]->GetName() == m_sDefaultAnimName);\n    }\n    return true;\n}\n\n\n/*====================\n  CSkeleton::HasValidAnims\n  ====================*/\nbool    CSkeleton::HasValidAnims()\n{\n    for (int iChannel(0); iChannel < NUM_ANIM_CHANNELS; ++iChannel)\n    {\n        if (m_pAnim[iChannel] == nullptr)\n            return false;\n    }\n    return true;\n}\n\n\n/*====================\n  CSkeleton::PoseSkeleton\n  ====================*/\nvoid    CSkeleton::PoseSkeleton(uint uiTime, int iChannel)\n{\n    PROFILE(\"PoseSkeleton\");\n\n    if (skel_noPose)\n        return;\n\n    // Make sure we have an anim to pose\n    if (!CheckAnims(uiTime))\n        return;\n\n    if (uiTime < m_uiStartTime[iChannel])\n        uiTime = m_uiStartTime[iChannel];\n\n    // Determine hi and lo frames and interpolation amount\n    int     iAnimTime(m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]));\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    if (iAnimTime - m_iLastAnimTime[iChannel] > 0xffff)\n    {\n        if (skel_debug)\n            Console.Warn << _T(\"CSkeleton::PoseSkeleton delta AnimTime == \") << iAnimTime - m_iLastAnimTime[iChannel] << newl;\n\n        if (iAnimTime < 0xffff)\n            m_iLastAnimTime[iChannel] = 0;\n        else\n            m_iLastAnimTime[iChannel] = iAnimTime - 0xffff;\n    }\n\n    bool bEnd = false;\n    if (!m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]) &&\n        !m_bPassiveAnim[iChannel])\n        bEnd = true;\n\n    // Check for events on this frame\n    if ((m_pModel->GetPoseType() != POSE_VEHICLE && (iChannel == 0 || m_pAnim[iChannel] != m_pAnim[0]))\n        || (m_pModel->GetPoseType() == POSE_VEHICLE && (iChannel == 1 || m_pAnim[iChannel] != m_pAnim[1])))\n        m_pAnim[iChannel]->CheckEvents(this, m_iLastAnimTime[iChannel], iAnimTime, iChannel);\n    m_iLastAnimTime[iChannel] = iAnimTime;\n\n    // Get the clip\n    CClip *pClip = g_ResourceManager.GetClip(m_pAnim[iChannel]->GetClip());\n    if (pClip)\n    {\n        int iNumFrames = pClip->GetNumFrames();\n        if (iNumFrames != 0)\n        {\n            // Make sure we don't get an access violation trying to access bad frames\n            iLoFrame = (int)iLoFrame % iNumFrames;\n            iHiFrame = (int)iHiFrame % iNumFrames;\n        }\n    }\n\n    {\n        PROFILE(\"PoseBones\");\n\n        // iLoFrame and iHiFrame should be valid array indexes at this point\n        PoseBones(m_pAnim[iChannel]->GetMotions(), iLoFrame, iHiFrame, fLerp, iChannel);\n    }\n\n    {\n        PROFILE(\"UpdateBones\");\n\n        uint uiBlendTime(m_fSpeed[iChannel] != 0.0f ? INT_ROUND(m_uiBlendTime[iChannel] / m_fSpeed[iChannel]) : 0);\n\n        // Blending\n        if (uiBlendTime && uiTime - m_uiBlendStartTime[iChannel] < uiBlendTime && skel_blendAnims)\n        {\n            float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(uiBlendTime)));\n            UpdateBonesLerp(fBlend, iChannel);\n        }\n        else\n            UpdateBones(iChannel);\n    }\n\n    Validate();\n\n    m_uiTime[iChannel] = uiTime;\n\n    if (bEnd)\n        StopAnim(iChannel, uiTime);\n\n    m_bValidPose[iChannel] = true;\n}\n\n\n/*====================\n  CSkeleton::PoseSkeletonLite\n  ====================*/\nvoid    CSkeleton::PoseSkeletonLite(uint uiTime, int iChannel)\n{\n    // Make sure we have an anim to pose\n    if (!CheckAnims(uiTime))\n        return;\n\n    if (uiTime < m_uiStartTime[iChannel])\n        uiTime = m_uiStartTime[iChannel];\n\n    // Determine hi and lo frames and interpolation amount\n    int     iAnimTime(m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]));\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    if (iAnimTime - m_iLastAnimTime[iChannel] > 0xffff)\n    {\n        if (skel_debug)\n            Console.Warn << _T(\"CSkeleton::PoseSkeletonLite delta AnimTime == \") << iAnimTime - m_iLastAnimTime[iChannel] << newl;\n\n        if (iAnimTime < 0xffff)\n            m_iLastAnimTime[iChannel] = 0;\n        else\n            m_iLastAnimTime[iChannel] = iAnimTime - 0xffff;\n    }\n\n    bool bEnd = false;\n    if (!m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]) &&\n        !m_bPassiveAnim[iChannel])\n        bEnd = true;\n\n    // Check for events on this frame\n    if ((m_pModel->GetPoseType() != POSE_VEHICLE && (iChannel == 0 || m_pAnim[iChannel] != m_pAnim[0]))\n        || (m_pModel->GetPoseType() == POSE_VEHICLE && (iChannel == 1 || m_pAnim[iChannel] != m_pAnim[1])))\n        m_pAnim[iChannel]->CheckEvents(this, m_iLastAnimTime[iChannel], iAnimTime, iChannel);\n    m_iLastAnimTime[iChannel] = iAnimTime;\n}\n\n\n/*====================\n  CSkeleton::RelativeToWorldRecurse\n  ====================*/\nvoid    CSkeleton::RelativeToWorldRecurse(uint uiBone)\n{\n    SBoneState  *pBoneState(GetBoneState(uiBone));\n\n    if (!(pBoneState->poseState & POSE_MASKED))\n    {\n        const CBone *pParent(m_pModel->GetBoneParent(uiBone));\n        const CBone *pThis(m_pModel->GetBone(uiBone));\n        if (pParent != nullptr)\n        {\n            M_MultiplyMatrix(&m_pBoneStates[pParent->GetIndex()].tm_local, &pBoneState->tm, &pBoneState->tm_local);\n            M_MultiplyMatrix(&pBoneState->tm_local, &pThis->m_invBase, &pBoneState->tm_world);\n        }\n        else\n        {\n            pBoneState->tm_local = pBoneState->tm;\n            M_MultiplyMatrix(&pBoneState->tm_local, &pThis->m_invBase, &pBoneState->tm_world);\n        }\n    }\n\n    const uivector *pvChildren(m_pModel->GetBoneChildren(uiBone));\n    uivector::const_iterator itEnd(pvChildren->end());\n    for (uivector::const_iterator it(pvChildren->begin()); it != itEnd; ++it)\n        RelativeToWorldRecurse(*it);\n}\n\n\n/*====================\n  CSkeleton::CalcWorldTransforms\n  ====================*/\nvoid    CSkeleton::CalcWorldTransforms()\n{\n    PROFILE(\"CSkeleton::CalcWorldTransforms\");\n\n    RelativeToWorldRecurse(0);\n}\n\n\n/*====================\n  CSkeleton::RotateBone\n\n  set euler angles for bone.  'multiply' specifies whether or not\n  to multiply by the current transform or to use an absolute\n  orientation\n  ====================*/\nvoid    CSkeleton::RotateBone(const tstring &sBoneName, float yaw_offset, float roll_offset, float pitch_offset, bool multiply)\n{\n    uint uiBone = m_pModel->GetBoneIndex(sBoneName);\n    if (uiBone == INVALID_BONE)\n        return;\n\n    matrix43_t rotation = g_identity43;\n\n    // Postmultiply the rotation\n    M_GetAxis(pitch_offset, roll_offset, yaw_offset, rotation.axis);\n\n    if (multiply)\n    {\n        matrix43_t temp;\n        M_MultiplyMatrix(&GetBoneState(uiBone)->tm, &rotation, &temp);\n        GetBoneState(uiBone)->tm = temp;\n    }\n    else\n    {\n        MemManager.Copy(GetBoneState(uiBone)->tm.axis, rotation.axis, sizeof(rotation.axis));\n    }\n}\n\n\n/*====================\n  CSkeleton::SetModel\n  ====================*/\nvoid    CSkeleton::SetModel(ResHandle hModel)\n{\n    if (m_hModel != INVALID_RESOURCE)\n        g_ResourceManager.RemoveResourceWatcher(this, m_hModel);\n\n    // store the new model and add it as a resource dependent.\n    m_hModel = hModel;\n    g_ResourceManager.AddResourceWatcher(this, hModel);\n\n    CModel *pModel(g_ResourceManager.GetModel(hModel));\n\n    if (pModel == nullptr)\n    {\n        Clear();\n        Invalidate();\n        return;\n    }\n\n    IModel *pIModel = pModel->GetModelFile();\n\n    if (pIModel == nullptr || pIModel->GetType() != MODEL_K2)\n    {\n        Clear();\n        Invalidate();\n        return;\n    }\n\n    CK2Model *pK2Model = static_cast<CK2Model *>(pIModel);\n\n    if (pK2Model == nullptr)\n    {\n        Clear();\n        Invalidate();\n        return;\n    }\n\n    // If the skeleton is using a new model, clear all the data\n    if (pK2Model != m_pModel)\n    {\n        Clear();\n        m_pModel = pK2Model;\n        m_uiNumBones = pK2Model->GetNumBones();\n\n        // Grab bone allocated bone data from bone pool\n        SSkeletonBoneData cBoneData;\n        SkeletonBonePool.Allocate(m_uiNumBones, cBoneData);\n\n        m_pBoneStates = cBoneData.pBoneStates;\n        m_pTempBoneStates = cBoneData.pTempBoneStates;\n\n        MemManager.Set(m_pBoneStates, 0, sizeof(SBoneState) * m_uiNumBones);\n        MemManager.Set(m_pTempBoneStates, 0, sizeof(SBoneState) * m_uiNumBones);\n\n        // Reset masks, etc\n        for (size_t z(0); z < pK2Model->GetNumBones(); ++z)\n        {\n            m_pBoneStates[z].poseState = 0;\n            m_pBoneStates[z].visibility = 255;\n\n            m_pTempBoneStates[z].poseState = 0;\n            m_pTempBoneStates[z].visibility = 255;\n        }\n\n        for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n        {\n            m_pCurrentPose[i] = cBoneData.pCurrentPose[i];\n            m_pSavedPose[i] = cBoneData.pSavedPose[i];\n            m_pTempPose[i] = cBoneData.pTempPose[i];\n        }\n\n        const tsvector &vSpawnEvents(pIModel->GetSpawnEvents());\n        for (tsvector::const_iterator it(vSpawnEvents.begin()); it != vSpawnEvents.end(); ++it)\n            AddEvent(*it, 0);\n\n        g_ResourceManager.AddResourceWatcher(this, hModel);\n    }\n\n    Validate();\n}\n\n\n/*====================\n  CSkeleton::Rebuild\n  ====================*/\nvoid    CSkeleton::Rebuild(ResHandle hResource)\n{\n    Clear();\n    SetModel(hResource);\n}\n\n\n/*====================\n  CSkeleton::ClearEvents\n  ====================*/\nvoid    CSkeleton::ClearEvents()\n{\n    m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::CheckEvents\n  ====================*/\nbool    CSkeleton::CheckEvents()\n{\n    return m_vEventCmds.size() > 0;\n}\n\n\n/*====================\n  CSkeleton::AddEvent\n  ====================*/\nvoid    CSkeleton::AddEvent(const tstring &sCmd, int iTimeNudge)\n{\n    if (m_vEventCmds.size() >= 255)\n    {\n        Console.Warn << _T(\"Large number of events on skeleton\") << newl;\n        return;\n    }\n\n    m_vEventCmds.push_back(SAnimEventCmd(sCmd, iTimeNudge));\n}\n\n\n/*====================\n  CSkeleton::GetAnimIndex\n  ====================*/\nuint    CSkeleton::GetAnimIndex(int iChannel)\n{\n    if (m_pAnim[iChannel])\n        return m_pAnim[iChannel]->GetIndex();\n    else\n        return -1;\n}\n\n\n/*====================\n  CSkeleton::GetAnimIndex\n  ====================*/\nint     CSkeleton::GetAnimIndex(const tstring &sAnim)\n{\n    if (m_pModel != nullptr)\n        return m_pModel->GetAnimIndex(sAnim);\n    else\n        return -1;\n}\n\n\n/*====================\n  CSkeleton::TempUpdateBonesLerp\n\n  update skeleton local tms (temp version)\n  ====================*/\nvoid    CSkeleton::TempUpdateBonesLerp(uint uiBone, float fLerp, int iChannel)\n{\n    while (uiBone != INVALID_INDEX)\n    {\n        SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n        {\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        SBoneXForm &cSavedPose(m_pSavedPose[iChannel][uiBone]);\n        SBoneXForm &cTempPose(m_pTempPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = LERP(fLerp, cSavedPose.v3Pos, cTempPose.v3Pos);\n\n        // Rotation\n        vec4_t quat;\n        M_LerpQuat(fLerp, vec4_cast(cSavedPose.v4Quat), vec4_cast(cTempPose.v4Quat), vec4_cast(quat));\n        M_QuatToAxis(quat, pBoneState->tm.axis);\n\n        // Scale\n        M_MultVec3(pBoneState->tm.axis[X], LERP(fLerp, cSavedPose.v3Scale[X], cTempPose.v3Scale[X]), pBoneState->tm.axis[X]);\n        M_MultVec3(pBoneState->tm.axis[Y], LERP(fLerp, cSavedPose.v3Scale[Y], cTempPose.v3Scale[Y]), pBoneState->tm.axis[Y]);\n        M_MultVec3(pBoneState->tm.axis[Z], LERP(fLerp, cSavedPose.v3Scale[Z], cTempPose.v3Scale[Z]), pBoneState->tm.axis[Z]);\n\n        uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n    }\n}\n\n\n/*====================\n  CSkeleton::TempUpdateBones\n\n  update skeleton local tms (temp version)\n  ====================*/\nvoid    CSkeleton::TempUpdateBones(uint uiBone, int iChannel)\n{\n    while (uiBone != INVALID_INDEX)\n    {\n        SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n        {\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        SBoneXForm &cTempPose(m_pTempPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = cTempPose.v3Pos;\n    \n        // Rotation\n        M_QuatToAxis(vec4_cast(cTempPose.v4Quat), pBoneState->tm.axis);\n\n        // Scale\n        M_MultVec3(pBoneState->tm.axis[X], cTempPose.v3Scale[X], pBoneState->tm.axis[X]);\n        M_MultVec3(pBoneState->tm.axis[Y], cTempPose.v3Scale[Y], pBoneState->tm.axis[Y]);\n        M_MultVec3(pBoneState->tm.axis[Z], cTempPose.v3Scale[Z], pBoneState->tm.axis[Z]);\n\n        uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n    }\n}\n\n\n/*====================\n  CSkeleton::TempPoseBone\n  ====================*/\nvoid    CSkeleton::TempPoseBone(SBoneMotion **ppMotions, uint uiBone, int iLoFrame, int iHiFrame, float fLerp, int iChannel)\n{\n    if (m_pModel->GetNumBones() <= uiBone)\n        return;\n\n    while (uiBone != INVALID_INDEX)\n    {\n        if (GetTempBoneState(uiBone)->poseState & POSE_MASKED)\n        {\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        if (!ppMotions[uiBone])\n        {\n            m_pTempPose[iChannel][uiBone].v3Pos = CVec3f(0.0f, 0.0f, 0.0f);\n            m_pTempPose[iChannel][uiBone].v4Quat = CVec4f(0.0f, 0.0f, 0.0f, 1.0f);\n            m_pTempPose[iChannel][uiBone].v3Scale = CVec3f(1.0f, 1.0f, 1.0f);\n\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        GetBoneXform(ppMotions[uiBone], iLoFrame, iHiFrame, fLerp, m_pTempPose[iChannel][uiBone]);\n\n        uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n    }\n}\n\n\n/*====================\n  CSkeleton::TempPose\n\n  Pose function which changes a temp bone state structure instead of the normal bone state structure\n  ====================*/\nvoid    CSkeleton::TempPose(uint uiTime, uint uiBone, int iChannel)\n{\n    if (uiTime < m_uiStartTime[iChannel])\n        uiTime = m_uiStartTime[iChannel]; // don't try to pose back farther then we started this animation\n\n    if (skel_noPose)\n        return;\n\n    // Make sure we have an anim to pose\n    if (!CheckAnims(uiTime))\n        return;\n\n    // Determine hi and lo frames and interpolation amount\n    int     iAnimTime(m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]));\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]);\n\n    // Get the clip\n    CClip *pClip = g_ResourceManager.GetClip(m_pAnim[iChannel]->GetClip());\n    if (pClip)\n    {\n        int iNumFrames = pClip->GetNumFrames();\n        if (iNumFrames != 0)\n        {\n            // Make sure we don't get an access violation trying to access bad frames\n            iLoFrame = (int)iLoFrame % iNumFrames;\n            iHiFrame = (int)iHiFrame % iNumFrames;\n        }\n    }\n\n    // iLoFrame and iHiFrame should be valid array indices at this point\n    TempPoseBone(m_pAnim[iChannel]->GetMotions(), uiBone, iLoFrame, iHiFrame, fLerp, iChannel);\n\n    // Blending\n    if (m_uiBlendTime[iChannel] && uiTime - m_uiBlendStartTime[iChannel] < m_uiBlendTime[iChannel] && skel_blendAnims)\n    {\n        float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(m_uiBlendTime[iChannel])));\n        TempUpdateBonesLerp(uiBone, fBlend, iChannel);\n    }\n    else\n        TempUpdateBones(uiBone, iChannel);\n}\n\n\n/*====================\n  CSkeleton::TempCalcWorldTransforms\n  ====================*/\nvoid    CSkeleton::TempCalcWorldTransforms(uint uiBone)\n{\n    uint uiParentIndex(m_pModel->GetBone(uiBone)->GetParentIndex());\n\n    if (uiParentIndex != INVALID_INDEX)\n    {\n        if (uiParentIndex > m_pModel->GetNumBones())\n        {\n            Console.Warn << _T(\"CSkeleton::TempCalcWorldTransforms() - Invalid bone parent index: \") << uiParentIndex << _T(\", model: \") << m_pModel->GetName() << _T(\", model bones: \") << m_pModel->GetNumBones() << _T(\", skeleton bones: \") << GetNumBones() << _T(\", child bone: \") << uiBone << newl;\n            uiParentIndex = INVALID_INDEX;\n        }\n        else\n            TempCalcWorldTransforms(uiParentIndex);\n    }\n\n    SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n    if (!(pBoneState->poseState & POSE_MASKED))\n    {\n        if (uiParentIndex != INVALID_INDEX)\n            M_MultiplyMatrix(&m_pTempBoneStates[uiParentIndex].tm_local, &pBoneState->tm, &pBoneState->tm_local);\n        else\n            pBoneState->tm_local = pBoneState->tm;\n    }\n}\n\n\n/*====================\n  CSkeleton::SetTempBoneState\n  ====================*/\nvoid    CSkeleton::SetTempBoneState(uint uiBone, int iState)\n{\n    if (uiBone == INVALID_BONE)\n        return;\n\n    m_pTempBoneStates[uiBone].poseState = iState;\n\n    CBone *pBone(m_pModel->GetBone(uiBone));\n    uint uiNumChildren(pBone->NumChildren());\n    for (uint n(0); n < uiNumChildren; ++n)\n    {\n        uint uiChild(pBone->GetChildIndex(n));\n        SetTempBoneState(uiChild, iState);\n    }\n}\n\n\n/*====================\n  CSkeleton::SetTempBoneState\n  ====================*/\nvoid    CSkeleton::SetTempBoneState(const tstring &sBoneName, int iState)\n{\n    uint uiBone(m_pModel->GetBoneIndex(sBoneName));\n    if (uiBone == INVALID_BONE)\n        return;\n\n    SetTempBoneState(uiBone, iState);\n}\n\n\n/*====================\n  CSkeleton::SetTempBoneState\n  ====================*/\nvoid    CSkeleton::SetTempBoneState(int iState)\n{\n    for (uint n(0); n < m_uiNumBones; ++n)\n        m_pTempBoneStates[n].poseState = iState;\n}\n\n\n/*====================\n  CSkeleton::TempRotateBone\n\n  set euler angles for bone.  'multiply' specifies whether or not\n  to multiply by the current transform or to use an absolute\n  orientation\n  ====================*/\nvoid    CSkeleton::TempRotateBone(const tstring &sBoneName, float yaw_offset, float roll_offset, float pitch_offset, bool multiply)\n{\n    uint uiBone = m_pModel->GetBoneIndex(sBoneName);\n    if (uiBone == INVALID_BONE)\n        return;\n\n    SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n    if (m_pModel->GetBone(uiBone)->GetParentIndex() != INVALID_INDEX)\n        TempCalcWorldTransforms(m_pModel->GetBone(uiBone)->GetParentIndex());\n\n    matrix43_t rotation = g_identity43;\n\n    // Postmultiply the rotation\n    M_GetAxis(pitch_offset, roll_offset, yaw_offset, rotation.axis);\n\n    if (multiply)\n    {\n        matrix43_t temp;\n        M_MultiplyMatrix(&pBoneState->tm, &rotation, &temp);\n        pBoneState->tm = temp;\n    }\n    else\n    {\n        MemManager.Copy(pBoneState->tm.axis, rotation.axis, sizeof(rotation.axis));\n    }\n}\n\n\n/*====================\n  CSkeleton::GetBonePose\n  ====================*/\nCVec3f  CSkeleton::GetBonePose(uint uiBone, uint uiTime)\n{\n    PROFILE(\"CSkeleton::GetBonePose\");\n\n    if (uiBone == INVALID_BONE || !m_pModel)\n        return V3_ZERO;\n\n    if (uiTime == m_uiPoseTime || m_pModel->GetPoseType() == POSE_VEHICLE)\n        return CVec3_cast(m_pBoneStates[uiBone].tm_local.pos);\n\n    if (m_pModel->GetPoseType() == POSE_CHARACTER)\n    {\n        uint uiBip01Spine(m_pModel->GetBoneIndex(_T(\"Bip01 Spine\")));\n\n        // *** Channel 0 ***\n        // Mask everything above the spine\n        SetTempBoneState(0);\n        SetTempBoneState(uiBip01Spine, POSE_MASKED);\n\n        TempPose(uiTime, uiBone, 0);\n\n        // *** Channel 1 ***\n        // Mask everything below the spine so only the upper\n        // body gets posed\n        SetTempBoneState(POSE_MASKED);\n        SetTempBoneState(uiBip01Spine, 0);\n\n        TempPose(uiTime, uiBone, 1);\n\n        // Head/Torso movements\n        if (m_uiSavedPoseTime != INVALID_TIME)\n        {\n            float fPitch;\n            float fYaw;\n\n            if (m_uiPrevPoseTime != INVALID_TIME)\n            {\n                fPitch = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevPitch, m_fPitch);\n                fYaw = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevYaw, m_fYaw);\n            }\n            else\n            {\n                fPitch = m_fPitch;\n                fYaw = m_fYaw;\n            }\n\n            if (fPitch > 180.0f)\n                fPitch -= 360.0f;\n            if (fPitch < -180.0f)\n                fPitch += 360.0f;\n\n            if (fYaw > 180.0f)\n                fYaw -= 360.0f;\n            if (fYaw < -180.0f)\n                fYaw += 360.0f;\n            \n            if (fYaw || fPitch)\n            {\n                // HACK: For some reason pitch and yaw values are swapped in the biped\n                // Biped orients X towards children\n                TempRotateBone(_T(\"Bip01 Head\"), -fPitch / 4.0f, 0, fYaw * 0.25f, true);\n                TempRotateBone(_T(\"Bip01 Spine\"), -fPitch / 6.0f, 0, fYaw * 0.75f, true);\n            }\n        }\n\n        // Get the final world coordinate transformation, then\n        // unmask the legs\n        SetTempBoneState(0);\n    }\n    else\n    {\n        TempPose(uiTime, uiBone, 0);\n    }\n\n    {\n        PROFILE(\"CSkeleton::TempCalcWorldTransforms\");\n        TempCalcWorldTransforms(uiBone);\n    }\n\n    return CVec3_cast(m_pTempBoneStates[uiBone].tm_local.pos);\n}\n\n\n/*====================\n  CSkeleton::GetBonePoseAxisPos\n  ====================*/\nvoid    CSkeleton::GetBonePoseAxisPos(uint uiBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    PROFILE(\"CSkeleton::GetBonePoseAxisPos\");\n\n    if (uiBone == INVALID_BONE || !m_pModel)\n    {\n        aOutAxis = CAxis(0.0f, 0.0f, 0.0f);\n        v3OutPos = CVec3f(0.0f, 0.0f, 0.0f);\n        return;\n    }\n\n    if (uiTime == m_uiPoseTime || m_pModel->GetPoseType() == POSE_VEHICLE)\n    {\n        aOutAxis = CAxis_cast(m_pBoneStates[uiBone].tm_local.axis);\n        v3OutPos = CVec3_cast(m_pBoneStates[uiBone].tm_local.pos);\n        return;\n    }\n\n    if (m_pModel->GetPoseType() == POSE_CHARACTER)\n    {\n        uint uiBip01Spine(m_pModel->GetBoneIndex(_T(\"Bip01 Spine\")));\n\n        // *** Channel 0 ***\n        // Mask everything above the spine\n        SetTempBoneState(0);\n        SetTempBoneState(uiBip01Spine, POSE_MASKED);\n\n        TempPose(uiTime, uiBone, 0);\n\n        // *** Channel 1 ***\n        // Mask everything below the spine so only the upper\n        // body gets posed\n        SetTempBoneState(POSE_MASKED);\n        SetTempBoneState(uiBip01Spine, 0);\n\n        TempPose(uiTime, uiBone, 1);\n\n        // Head/Torso movements\n        if (m_uiSavedPoseTime != INVALID_TIME)\n        {\n            float fPitch;\n            float fYaw;\n\n            if (m_uiPrevPoseTime != INVALID_TIME)\n            {\n                fPitch = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevPitch, m_fPitch);\n                fYaw = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevYaw, m_fYaw);\n            }\n            else\n            {\n                fPitch = m_fPitch;\n                fYaw = m_fYaw;\n            }\n\n            if (fPitch > 180.0f)\n                fPitch -= 360.0f;\n            if (fPitch < -180.0f)\n                fPitch += 360.0f;\n\n            if (fYaw > 180.0f)\n                fYaw -= 360.0f;\n            if (fYaw < -180.0f)\n                fYaw += 360.0f;\n            \n            if (fYaw || fPitch)\n            {\n                // HACK: For some reason pitch and yaw values are swapped in the biped\n                // Biped orients X towards children\n                TempRotateBone(_T(\"Bip01 Head\"), -fPitch / 4.0f, 0, fYaw * 0.25f, true);\n                TempRotateBone(_T(\"Bip01 Spine\"), -fPitch / 6.0f, 0, fYaw * 0.75f, true);\n            }\n        }\n\n        // Get the final world coordinate transformation, then\n        // unmask the legs\n        SetTempBoneState(0);\n    }\n    else\n    {\n        TempPose(uiTime, uiBone, 0);\n    }\n\n    {\n        TempCalcWorldTransforms(uiBone);\n    }\n\n    aOutAxis = CAxis_cast(m_pTempBoneStates[uiBone].tm_local.axis);\n    v3OutPos = CVec3_cast(m_pTempBoneStates[uiBone].tm_local.pos);\n\n#if 0\n    if (!aOutAxis.Forward().IsValid() || \n        !aOutAxis.Right().IsValid() ||\n        !aOutAxis.Up().IsValid() ||\n        !v3OutPos.IsValid())\n    {\n        Console << _T(\"CSkeleton::GetBonePoseAxisPos - NAN\") << newl;\n        \n        aOutAxis = CAxis(0.0f, 0.0f, 0.0f);\n        v3OutPos = CVec3f(0.0f, 0.0f, 0.0f);\n    }\n#endif\n\n    return;\n}\n\n\n/*====================\n  CSkeleton::GetCurrentAnimName\n  ====================*/\nconst tstring&  CSkeleton::GetCurrentAnimName(int iChannel)\n{\n    if (m_pAnim[iChannel])\n        return m_pAnim[iChannel]->GetName();\n    else\n        return TSNULL;\n}\n\n\n/*====================\n  CSkeleton::SetAnimSpeed\n  ====================*/\nvoid    CSkeleton::SetAnimSpeed(float fSpeed, int iChannel)\n{\n    if (m_fSpeed[iChannel] == fSpeed ||\n        m_uiTime[iChannel] == INVALID_TIME ||\n        m_uiStartTime[iChannel] == INVALID_TIME ||\n        m_iParentChannel[iChannel] != iChannel ||\n        !m_pModel || m_pModel->GetPoseType() == POSE_VEHICLE)\n        return;\n\n#if 0\n    int iOldOffsetTime(m_iOffsetTime[iChannel]);\n#endif\n\n    if (fSpeed == 0.0f)\n    {\n        int iAnimTime(INT_FLOOR((m_uiTime[iChannel] - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel])) * m_fSpeed[iChannel]);\n        m_iOffsetTime[iChannel] = iAnimTime;\n    }\n    else\n    {\n        if (m_fSpeed[iChannel] == 0.0f)\n        {\n            int iAnimTime(m_iOffsetTime[iChannel]);\n            m_iOffsetTime[iChannel] = INT_FLOOR((iAnimTime - (m_uiTime[iChannel] - m_uiStartTime[iChannel]) * fSpeed) / fSpeed);\n        }\n        else\n        {\n            int iAnimTime(INT_FLOOR((m_uiTime[iChannel] - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel])) * m_fSpeed[iChannel]);\n            m_iOffsetTime[iChannel] = INT_FLOOR((iAnimTime - (m_uiTime[iChannel] - m_uiStartTime[iChannel]) * fSpeed) / fSpeed);\n        }\n    }\n\n#if 0\n    if (m_iOffsetTime[iChannel] < -1000000)\n    {\n        int x = 0;\n    }\n#endif\n\n    m_fSpeed[iChannel] = fSpeed;\n\n    for (int i(0); i < NUM_ANIM_CHANNELS; ++i)\n    {\n        if (i != iChannel && m_iParentChannel[i] == iChannel)\n        {\n            m_iOffsetTime[i] = m_iOffsetTime[iChannel];\n            m_fSpeed[i] = m_fSpeed[iChannel];\n        }\n    }\n}\n\n\n/*====================\n  CSkeleton::SetAnimTime\n  ====================*/\nvoid    CSkeleton::SetAnimTime(int iAnimTime, int iChannel)\n{\n    if (m_fSpeed[iChannel] == 0.0f)\n    {\n        m_iOffsetTime[iChannel] = iAnimTime;\n    }\n}\n\n\n/*====================\n  CSkeleton::SetAnimTime\n  ====================*/\nvoid    CSkeleton::SetAnimTime(float fFraction, int iChannel)\n{\n    if (m_fSpeed[iChannel] == 0.0f)\n    {\n        m_iOffsetTime[iChannel] = INT_ROUND(m_pAnim[iChannel]->GetNumFrames() * m_pAnim[iChannel]->GetMSperFrame() * fFraction);\n    }\n}\n\n\n/*====================\n  CSkeleton::Pose\n  ====================*/\nvoid    CSkeleton::Pose(uint uiTime, SBoneXForm *pPose)\n{\n    PROFILE(\"CSkeleton::Pose\");\n\n    m_bIsCharacter = false;\n    m_fPrevPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fYaw = 0.0f;\n    int iChannel(0);\n\n    if (!m_pModel)\n        return;\n\n    MemManager.Copy(m_pCurrentPose[iChannel], pPose, sizeof(SBoneXForm) * m_uiNumBones);\n\n    {\n        PROFILE(\"UpdateBones\");\n\n        uint uiBlendTime(m_fSpeed[iChannel] != 0.0f ? INT_ROUND(m_uiBlendTime[iChannel] / m_fSpeed[iChannel]) : 0);\n\n        // Blending\n        if (uiBlendTime && uiTime - m_uiBlendStartTime[iChannel] < uiBlendTime && skel_blendAnims)\n        {\n            float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(uiBlendTime)));\n            UpdateBonesLerp(fBlend, iChannel);\n        }\n        else\n            UpdateBones(iChannel);\n    }\n\n    Validate();\n\n    m_uiTime[iChannel] = uiTime;\n\n    m_bValidPose[iChannel] = true;\n\n    CalcWorldTransforms();\n}\n\n\n/*====================\n  CSkeleton::ComputeAnimFrame\n  ====================*/\nvoid    CSkeleton::ComputeAnimFrame(uint uiTime, int iChannel, int &iAnimTime, float &fFrame, float &fFraction)\n{\n    if (!CheckAnims(uiTime))\n        return;\n\n    // Determine hi and lo frames and interpolation amount\n    iAnimTime = m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]);\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    bool bEnd = false;\n    if (!m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]) &&\n        !m_bPassiveAnim[iChannel])\n        bEnd = true;\n\n    fFrame = iLoFrame - m_pAnim[iChannel]->GetStartFrame() + fLerp;\n    fFraction = fFrame / m_pAnim[iChannel]->GetNumFrames();\n}\n\n\n/*====================\n  CSkeleton::RequestStartAnim\n  ====================*/\nvoid    CSkeleton::RequestStartAnim(const tstring &sAnim, uint uiTime, int iChannel, int iBlendTime, float fSpeed, uint uiForceLength)\n{\n    PROFILE(\"CSkeleton::RequestStartAnim\");\n\n    //Console.Dev << \"CSkeleton::RequestStartAnim() - \" << sAnim << _T(\" \") << uiTime << _T(\" \") << iChannel << newl;\n\n    m_aAnimRequest[iChannel].sAnim = sAnim;\n    m_aAnimRequest[iChannel].uiTime = uiTime;\n    m_aAnimRequest[iChannel].iBlendTime = iBlendTime;\n    m_aAnimRequest[iChannel].fSpeed = fSpeed;\n    m_aAnimRequest[iChannel].uiForceLength = uiForceLength;\n}\n\n\n/*====================\n  CSkeleton::RequestStopAnim\n  ====================*/\nvoid    CSkeleton::RequestStopAnim(int iChannel, uint uiTime)\n{\n    PROFILE(\"CSkeleton::RequestStopAnim\");\n\n    m_aAnimRequest[iChannel].sAnim.clear();\n    m_aAnimRequest[iChannel].uiTime = uiTime;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_skeleton.cpp b/src/k2/c_skeleton.cpp
--- a/src/k2/c_skeleton.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/k2/c_skeleton.cpp	(date 1684975201828)
@@ -97,8 +97,6 @@
     }
 
     SkeletonBonePool.Deallocate(cBoneData);
-
-    g_ResourceManager.RemoveResourceWatcher(this, m_hModel);
 }
 
 
@@ -1079,10 +1077,8 @@
   ====================*/
 void    CSkeleton::SetModel(ResHandle hModel)
 {
-    if (m_hModel != INVALID_RESOURCE)
-        g_ResourceManager.RemoveResourceWatcher(this, m_hModel);
-
-    // store the new model and add it as a resource dependent.
+    // store the new model and add it as a resource dependent.
+    g_ResourceManager.RemoveResourceWatcher(this, m_hModel);
     m_hModel = hModel;
     g_ResourceManager.AddResourceWatcher(this, hModel);
 
Index: src/vid_gl2/gl2_win32.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2008 S2 Games\n// gl2_win32.cpp\n//\n// Win32 specific renderer API functions\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"vid_common.h\"\n\n#include \"../k2/c_uimanager.h\"\n#include \"../k2/c_cursor.h\"\n#include \"../k2/c_resourcemanager.h\"\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nWNDPROC     MainWndProc;\nHINSTANCE   g_hInstance;\nHWND        g_hWnd;\nHDC         g_hDC;\nHGLRC       g_hglrc;\nICONINFO    g_IconInfo = {0};\nHICON       g_hCursorIcon = nullptr;\n\nCVAR_BOOL   (win_changeDisplayMode,     false);\n//=============================================================================\n\n/*====================\n  InitAPIs\n\n  This is what's exported by the DLL and called by the rest of\n  the engine. It's a wrapper to do the windows-specific stuff\n  and call the shared API initialization function, basically.\n  ====================*/\nextern \"C\" __declspec(dllexport)\nvoid    InitAPIs(SVidDriver *vid_api, WNDPROC _MainWndProc, HINSTANCE hInstance)\n{\n    g_hInstance = hInstance;\n    MainWndProc = _MainWndProc;\n\n    InitAPIs_Global(vid_api);\n}\n\n\n/*====================\n  GL_GetHWnd\n  ====================*/\nvoid*   GL_GetHWnd()\n{\n    return g_hWnd;\n}\n\n\n/*====================\n  GL_Init\n  ====================*/\nint     GL_Init()\n{\n    int modenum = 0;\n    BOOL bSuccess(FALSE);\n    DEVMODE devmode;\n    \n    gl_initialized = false;\n\n    ZeroMemory(&devmode, sizeof(devmode));\n    devmode.dmSize = sizeof(DEVMODE);\n\n    // Fill in the default mode (Desktop)\n    if (EnumDisplaySettings(nullptr, ENUM_REGISTRY_SETTINGS, &devmode))\n    {\n        g_VidModes[0].iWidth = devmode.dmPelsWidth;\n        g_VidModes[0].iHeight = devmode.dmPelsHeight;\n        g_VidModes[0].iBpp = devmode.dmBitsPerPel;\n        g_VidModes[0].iRefreshRate = devmode.dmDisplayFrequency;\n        g_VidModes[0].sName = _T(\"Desktop \") + ParenStr(XtoA(g_VidModes[0].iWidth) + _T(\"x\") + XtoA(g_VidModes[0].iHeight) + _T(\"x\") + XtoA(g_VidModes[0].iBpp) + _T(\"@\") + XtoA(g_VidModes[0].iRefreshRate));\n    }\n    else\n        K2System.Error(_T(\"EnumDisplaySettings failed on mode 0\"));\n\n    g_iNumVidModes = 1;  // Always keep mode 0 open\n\n    do\n    {\n        bool bModeExists(false);\n        bSuccess = EnumDisplaySettings(nullptr, modenum, &devmode);\n        if (!bSuccess)\n        {\n            if (modenum == 0)\n                K2System.Error(_T(\"EnumDisplaySettings failed on mode 0\"));\n            break;\n        }\n\n        if (devmode.dmBitsPerPel >= 15 && devmode.dmPelsWidth >= 1024 && devmode.dmPelsHeight >= 720 && g_iNumVidModes < MAX_VID_MODES)\n        {\n            // See if the mode is valid\n            devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;\n            if (ChangeDisplaySettings(&devmode, CDS_TEST | CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL)\n            {\n                // Make sure the mode doesn't already exist\n                for (int n = 1; n < g_iNumVidModes; ++n)\n                {\n                    if (g_VidModes[n].iWidth == int(devmode.dmPelsWidth) &&\n                        g_VidModes[n].iHeight == int(devmode.dmPelsHeight) &&\n                        g_VidModes[n].iBpp == int(devmode.dmBitsPerPel) &&\n                        g_VidModes[n].iRefreshRate == int(devmode.dmDisplayFrequency))\n                        bModeExists = true;\n                }\n                if (!bModeExists)\n                {\n                    // The mode is valid, so add it to g_VidModes\n                    g_VidModes[g_iNumVidModes].iWidth = int(devmode.dmPelsWidth);\n                    g_VidModes[g_iNumVidModes].iHeight = int(devmode.dmPelsHeight);\n                    g_VidModes[g_iNumVidModes].iBpp = int(devmode.dmBitsPerPel);\n                    g_VidModes[g_iNumVidModes].iRefreshRate = int(devmode.dmDisplayFrequency);\n                    g_VidModes[g_iNumVidModes].sName = XtoA(devmode.dmPelsWidth) + _T(\"x\") + XtoA(devmode.dmPelsHeight) + _T(\"x\") + XtoA(devmode.dmBitsPerPel) + _T(\" @ \") + XtoA(devmode.dmDisplayFrequency) + _T(\" Hz\");\n\n                    Console.Video << _T(\"Vid mode \") << g_iNumVidModes << _T(\": \")\n                                << _T(\"Width: \") << devmode.dmPelsWidth\n                                << _T(\", Height: \") << devmode.dmPelsHeight\n                                << _T(\", Bpp: \") << devmode.dmBitsPerPel\n                                << _T(\", Refresh rate: \") << devmode.dmDisplayFrequency << newl;\n                    ++g_iNumVidModes;\n                }\n            }\n        }\n        ++modenum;\n    }\n    while (bSuccess);\n    \n    return GL_Global_Init();\n}\n\n\n/*====================\n  GL_SetupPixelFormat\n  ====================*/\nvoid    GL_SetupPixelFormat()\n{\n    int pixelformat;\n    static PIXELFORMATDESCRIPTOR pfd = {\n    sizeof(PIXELFORMATDESCRIPTOR),  // size of this pfd\n    1,                      // version number\n    PFD_DRAW_TO_WINDOW      // support window\n    | PFD_SUPPORT_OPENGL    // support OpenGL\n    | PFD_DOUBLEBUFFER,     // double buffered\n    PFD_TYPE_RGBA,          // RGBA type\n    24,                     // 24-bit color depth\n    0, 0, 0, 0, 0, 0,       // color bits ignored\n    0,                      // no alpha buffer\n    0,                      // shift bit ignored\n    0,                      // no accumulation buffer\n    0, 0, 0, 0,             // accum bits ignored\n    24,                     // 24-bit z-buffer  \n    0,                      // no stencil buffer\n    0,                      // no auxiliary buffer\n    PFD_MAIN_PLANE,         // main layer\n    0,                      // reserved\n    0, 0, 0                 // layer masks ignored\n    };\n    \n    if (!(pixelformat = ChoosePixelFormat(g_hDC, &pfd)))    \n       K2System.Error(_T(\"GL_SetupPixelFormat: ChoosePixelFormat failed\"));            \n\n    if (!SetPixelFormat(g_hDC, pixelformat, &pfd))\n        K2System.Error(_T(\"SetPixelFormat failed\"));\n}\n\n\n/*====================\n  GL_Start\n  ====================*/\nvoid    GL_Start()\n{\n    static bool class_registered = false;\n\n    // Register window class\n    if (!class_registered)\n    {\n        WNDCLASS wc;\n\n        MemManager.Set(&wc, 0, sizeof(WNDCLASS));       \n        wc.lpfnWndProc = MainWndProc;\n        wc.hInstance = g_hInstance;\n        wc.lpszClassName = _T(\"K2_OpenGL\");\n#if TKTK // LoadIcon\n        wc.hIcon = LoadIcon(wc.hInstance, MAKEINTRESOURCE(IDI_ICON1));\n#endif\n\n        if (!RegisterClass(&wc))\n            K2System.Error(_T(\"GL_Start: RegisterClass() failed\"));\n        class_registered = true;\n    }\n\n    // Create the window\n    HWND hWnd = CreateWindowEx\n    (\n        WS_EX_ACCEPTFILES,\n        _T(\"K2_OpenGL\"),\n        K2System.GetGameName().c_str(),\n        WS_MAXIMIZE | WS_POPUP,\n        0, \n        0, \n        g_CurrentVidMode.iWidth,\n        g_CurrentVidMode.iHeight,\n        nullptr,\n        nullptr,\n        g_hInstance,\n        nullptr\n    );\n\n    if (!hWnd)\n        K2System.Error(_T(\"GL_Start: CreateWindow() failed\"));\n    K2System.SetWindowHandle(hWnd);\n\n    g_hWnd = hWnd;\n    g_hDC = GetDC(g_hWnd);\n\n    GL_SetMode();\n\n    ShowWindow(hWnd, SW_SHOW);\n    UpdateWindow(hWnd);\n\n    PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n\n    GL_SetupPixelFormat();\n\n    if (!(g_hglrc = wglCreateContext(g_hDC)))\n        K2System.Error(_T(\"GL_Start: wglCreateContext() failed\"));\n\n    if (!wglMakeCurrent(g_hDC, g_hglrc))\n        K2System.Error(_T(\"GL_Start: wglMakeCurrent() failed\"));\n\n    gl_initialized = true;\n\n    PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n\n    GL_Global_Start();\n\n    // Build anti-aliasing mode list\n    g_AAModes[0].iSamples = 0;\n    g_AAModes[0].iQuality = 0;\n    g_AAModes[0].sName = _T(\"None\");\n    g_iNumAAModes = 1; // Always keep mode 0 open\n\n    for (int i(2); i <= 16; ++i)\n    {\n        int iAttributes[] =\n        {\n            WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,\n            WGL_SUPPORT_OPENGL_ARB, GL_TRUE,\n            WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,\n            WGL_COLOR_BITS_ARB, 24,\n            WGL_ALPHA_BITS_ARB, 8,\n            WGL_DEPTH_BITS_ARB, 16,\n            WGL_STENCIL_BITS_ARB, 0,\n            WGL_DOUBLE_BUFFER_ARB, GL_TRUE,\n            WGL_SAMPLE_BUFFERS_ARB, GL_TRUE,\n            WGL_SAMPLES_ARB, i,\n            0, 0\n        };\n\n        float fAttributes[] = {0, 0};\n        int iPixelFormat;\n        UINT uiNumFormats;\n\n        BOOL bValid(wglChoosePixelFormatARB(g_hDC, iAttributes, fAttributes, 1, &iPixelFormat, &uiNumFormats));\n     \n        if (!bValid || uiNumFormats == 0)\n            continue;\n\n        g_AAModes[g_iNumAAModes].iSamples = i;\n        g_AAModes[g_iNumAAModes].iQuality = 0;\n        g_AAModes[g_iNumAAModes].sName = XtoA(i) + _T(\"x\");\n\n        ++g_iNumAAModes;\n    }\n\n    GL_SetGamma(DEFAULT_OVERBRIGHT);\n}\n\n\n/*====================\n  GL_SetMode\n  ====================*/\nint     GL_SetMode()\n{\n    int iMode(-1);\n\n    // Try to match a valid mode\n    for (int i(0); i < g_iNumVidModes; ++i)\n    {\n        if (g_VidModes[i].iWidth == vid_resolution[0] &&\n            g_VidModes[i].iHeight == vid_resolution[1] &&\n            g_VidModes[i].iBpp == vid_bpp &&\n            g_VidModes[i].iRefreshRate == vid_refreshRate)\n        {\n            g_CurrentVidMode = g_VidModes[i];\n            iMode = i;\n            break;\n        }\n    }\n\n    if (iMode == -1)\n    {\n        if (vid_fullscreen)\n        {\n            g_CurrentVidMode = g_VidModes[0];\n            iMode = 0;\n        }\n        else\n        {\n            g_CurrentVidMode.iWidth = vid_resolution[0];\n            g_CurrentVidMode.iHeight = vid_resolution[1];\n            g_CurrentVidMode.iBpp = vid_bpp;\n            g_CurrentVidMode.iRefreshRate = vid_refreshRate;\n        }\n    }\n    \n    g_iCurrentVideoMode = iMode;\n\n    if (vid_antialiasing.GetSize() != 2)\n        vid_antialiasing.Resize(2, 0);\n\n    g_CurrentAAMode.iSamples = vid_antialiasing[0];\n    g_CurrentAAMode.iQuality = vid_antialiasing[1];\n    g_CurrentAAMode.sName = _T(\"\");\n\n    if (vid_fullscreen)\n    {\n        if (iMode != 0 || win_changeDisplayMode)\n        {\n            DEVMODE devmode;\n            MemManager.Set(&devmode, 0, sizeof(devmode));\n            devmode.dmPelsWidth = g_CurrentVidMode.iWidth;\n            devmode.dmPelsHeight = g_CurrentVidMode.iHeight;\n            devmode.dmBitsPerPel = g_CurrentVidMode.iBpp;\n            devmode.dmDisplayFrequency = g_CurrentVidMode.iRefreshRate;\n            devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY;\n\n            devmode.dmSize = sizeof(devmode);\n\n            bool bSuccess(false);\n\n            bSuccess = ChangeDisplaySettings(&devmode, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL;\n\n            if (!bSuccess && iMode != 0)\n            {\n                if (win_changeDisplayMode)\n                {\n                    DEVMODE devmode0;\n                    MemManager.Set(&devmode0, 0, sizeof(devmode0));\n                    devmode0.dmPelsWidth = g_VidModes[0].iWidth;\n                    devmode0.dmPelsHeight = g_VidModes[0].iHeight;\n                    devmode0.dmBitsPerPel = g_VidModes[0].iBpp;\n                    devmode0.dmDisplayFrequency = g_VidModes[0].iRefreshRate;\n                    devmode0.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;\n\n                    bSuccess = ChangeDisplaySettings(&devmode0, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL;\n\n                    devmode = devmode0;\n                }\n                else\n                {\n                    bSuccess = ChangeDisplaySettings(nullptr, 0) == DISP_CHANGE_SUCCESSFUL;\n                }\n\n                g_iCurrentVideoMode = 0;\n            }\n\n            if (!bSuccess)\n            {\n                K2System.Error(_T(\"GL_SetMode: Unable to set Mode 0\"));\n            }\n        }\n        else\n        {\n            if (ChangeDisplaySettings(nullptr, 0) != DISP_CHANGE_SUCCESSFUL)\n                K2System.Error(_T(\"GL_SetMode: Unable to set desktop video mode\"));\n        }\n\n        g_bFullscreen = true;\n    }\n    else\n    {\n        g_bFullscreen = false;\n\n        if (ChangeDisplaySettings(nullptr, 0) != DISP_CHANGE_SUCCESSFUL)\n            K2System.Error(_T(\"GL_SetMode: Unable to set desktop video mode\"));\n    }\n\n    if (g_hWnd)\n    {\n        if (!vid_fullscreen)\n        {\n            DWORD dwWindowStyle(WS_CAPTION | WS_MINIMIZEBOX | WS_VISIBLE | WS_SYSMENU);\n\n            if (vid_windowResize)\n                dwWindowStyle |= WS_SIZEBOX;\n\n            if (!SetWindowLong(g_hWnd, GWL_STYLE, dwWindowStyle))\n                K2System.Error(_TS(\"SetWindowLong() - \") + K2System.GetLastErrorString());\n\n            RECT    winsize;\n            winsize.left = 0;\n            winsize.right = g_CurrentVidMode.iWidth;\n            winsize.top = 0;\n            winsize.bottom = g_CurrentVidMode.iHeight;\n            AdjustWindowRect(&winsize, dwWindowStyle, false);\n            if (!SetWindowPos(g_hWnd, HWND_TOP, 0, 0, winsize.right - winsize.left, winsize.bottom - winsize.top, SWP_SHOWWINDOW))\n                K2System.Error(_TS(\"SetWindowPos() - \") + K2System.GetLastErrorString());\n            GetClientRect(g_hWnd, &winsize);\n    \n            // Resize render surface to match new window size (if it was clipped)\n            g_CurrentVidMode.iWidth = MIN<int>(g_CurrentVidMode.iWidth, winsize.right - winsize.left);\n            g_CurrentVidMode.iHeight = MIN<int>(g_CurrentVidMode.iHeight, winsize.bottom - winsize.top);\n        }\n        else\n        {\n            if (!SetWindowLong(g_hWnd, GWL_STYLE, WS_MAXIMIZE))\n                K2System.Error(_TS(\"SetWindowLong() - \") + K2System.GetLastErrorString());\n\n            if (!SetWindowPos(g_hWnd, HWND_TOP, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, SWP_SHOWWINDOW))\n                K2System.Error(_TS(\"SetWindowPos() - \") + K2System.GetLastErrorString());\n        }\n\n        ShowWindow(g_hWnd, SW_SHOW);\n        UpdateWindow(g_hWnd);\n\n        PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n    }\n\n    return g_iCurrentVideoMode;\n}\n\n\n/*====================\n  GL_SetGamma\n  ====================*/\nvoid    GL_SetGamma(float gamma)\n{\n}\n\n\n/*====================\n  GL_ShowCursor\n  ====================*/\nvoid    GL_ShowCursor(bool bShow)\n{\n    if (bShow)\n        while(ShowCursor(true) < 0);\n    else\n        while(::ShowCursor(false) >= 0);\n}\n\n\n/*====================\n  GL_SetCursor\n  ====================*/\nvoid    GL_SetCursor(ResHandle hCursor)\n{\n    if (hCursor == g_hCursor)\n        return;\n    g_hCursor = hCursor;\n\n    if (g_hCursor == INVALID_RESOURCE)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    CCursor *pCursor(g_ResourceManager.GetCursor(hCursor));\n    if (pCursor == nullptr)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    CBitmap *pBitmap(pCursor->GetBitmapPointer());\n    if (pBitmap == nullptr)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    const int WIDTH(32), HEIGHT(32), BYTEPP(4);\n    \n    if (pBitmap->GetWidth() != WIDTH || pBitmap->GetHeight() != HEIGHT || pBitmap->GetBMPType() != BYTEPP)\n        return;\n\n    byte yBuffer[WIDTH * HEIGHT * 4];\n\n    const byte *pSrcData(static_cast<const byte *>(pBitmap->GetBuffer()));\n    byte *pDstData(yBuffer);\n    int iDeltaPitch(0);\n\n    // Invert\n    pSrcData += pBitmap->GetWidth() * 4 * (pBitmap->GetHeight() - 1);\n    iDeltaPitch -= pBitmap->GetWidth() * 4 * 2;\n\n    for (int y(0); y < pBitmap->GetHeight(); ++y)\n    {\n        for (int x(0); x < pBitmap->GetWidth(); ++x)\n        {\n            pDstData[0] = pSrcData[2];\n            pDstData[1] = pSrcData[1];\n            pDstData[2] = pSrcData[0];\n            pDstData[3] = pSrcData[3];\n\n            pDstData += 4;\n            pSrcData += 4;\n        }\n\n        pSrcData += iDeltaPitch;\n    }\n\n    CVec2i v2Hotspot(pCursor->GetHotspot());\n\n    if (g_hCursorIcon != nullptr) {\n        DeleteObject(g_IconInfo.hbmMask);\n        DeleteObject(g_IconInfo.hbmColor);\n        DestroyIcon(g_hCursorIcon);\n    }\n\n    g_IconInfo.fIcon = false;\n    g_IconInfo.xHotspot = v2Hotspot.x;\n    g_IconInfo.yHotspot = v2Hotspot.y;\n    g_IconInfo.hbmMask = CreateBitmap(WIDTH, HEIGHT, 1, 1, nullptr);\n    g_IconInfo.hbmColor = CreateBitmap(WIDTH, HEIGHT, 1, BYTEPP * 8, yBuffer);\n\n    g_hCursorIcon = CreateIconIndirect(&g_IconInfo);\n\n#ifdef _WIN64\n    SetClassLongPtr(g_hWnd, GCLP_HCURSOR, LONG_PTR(g_hCursorIcon));\n#else\n    SetClassLongPtr(g_hWnd, GCL_HCURSOR, LONG_PTR(g_hCursorIcon));\n#endif\n}\n\n\n/*====================\n  GL_Shutdown\n  ====================*/\nvoid    GL_Shutdown()\n{\n    if (!gl_initialized)\n        return;\n\n    GL_Global_Shutdown();\n\n    wglMakeCurrent(nullptr, nullptr);\n    \n    GL_SetGamma(1);\n\n    if (g_hglrc)\n    {\n        wglDeleteContext(g_hglrc);\n        g_hglrc = 0;\n    }\n\n    if (g_hDC)\n    {\n        ReleaseDC(g_hWnd, g_hDC);\n        g_hDC = 0;\n    }\n\n    if (g_hCursorIcon != nullptr)\n        DestroyIcon(g_hCursorIcon);\n\n    DestroyWindow(g_hWnd);\n    UnregisterClass(_T(\"K2_OpenGL\"), g_hInstance);\n\n    ChangeDisplaySettings(nullptr, 0);\n\n    ShowCursor(TRUE);\n    DestroyIcon(g_hCursorIcon);\n    DeleteObject(g_IconInfo.hbmMask);\n    DeleteObject(g_IconInfo.hbmColor);\n\n    gl_initialized = false;\n    g_bValidScene = false;\n}\n\n\n/*====================\n  GL_EndFrame\n  ====================*/\nvoid    GL_EndFrame()\n{\n    GL_Global_EndFrame();\n    SwapBuffers(g_hDC);\n    \n    PRINT_GLERROR_BREAK();\n}\n\n\n/*====================\n  GL_Break\n  ====================*/\nvoid    GL_Break()\n{\n#ifndef _WIN64\n    __asm int 0x03;\n#else\n    // TODO\n#endif\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/vid_gl2/gl2_win32.cpp b/src/vid_gl2/gl2_win32.cpp
--- a/src/vid_gl2/gl2_win32.cpp	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/src/vid_gl2/gl2_win32.cpp	(date 1684987204759)
@@ -44,6 +44,19 @@
     InitAPIs_Global(vid_api);
 }
 
+inline int get_title_bar_thickness(HWND window_handle)
+{
+    RECT window_rectangle, client_rectangle;
+    int height, width;
+    GetWindowRect(window_handle, &window_rectangle);
+    GetClientRect(window_handle, &client_rectangle);
+    height = (window_rectangle.bottom - window_rectangle.top) -
+    (client_rectangle.bottom - client_rectangle.top);
+    width = (window_rectangle.right - window_rectangle.left) -
+    (client_rectangle.right - client_rectangle.left);
+    return height - (width/2);
+}
+
 
 /*====================
   GL_GetHWnd
Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required(VERSION 3.22)\ncmake_policy(VERSION \"3.22.0\")\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\nif(UNIX AND NOT APPLE)\n  set(LINUX TRUE)\nendif()\n\n# https://stackoverflow.com/questions/17275348/how-to-specify-new-gcc-path-for-cmake\nproject(noh NONE)\nif(APPLE)\n  # Compile with clang version 16, since Apple's default clang is quite out of date (version 12)\n  # brew install llvm\n  set(LLVM_ROOT \"/opt/homebrew/opt/llvm\")\n  set(CMAKE_C_COMPILER \"/opt/homebrew/opt/llvm/bin/clang\" CACHE STRING \"C compiler\" FORCE)\n  set(CMAKE_CXX_COMPILER \"/opt/homebrew/opt/llvm/bin/clang++\" CACHE STRING \"C++ compiler\" FORCE)\n  set(CMAKE_OBJCXX_COMPILER \"/opt/homebrew/opt/llvm/bin/clang++\" CACHE STRING \"Objective-C++ compiler\" FORCE)\n  set(CMAKE_LINKER \"/opt/homebrew/opt/llvm/bin/lld\" CACHE STRING \"Linker\" FORCE)\nendif()\nenable_language(C CXX)\n\n# C++ 20\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nadd_definitions(-D_LIBCPP_ENABLE_CXX20_REMOVED_ALLOCATOR_MEMBERS)\nadd_definitions(-D_HAS_DEPRECATED_ALLOCATOR_MEMBERS)\n\n# from https://gitlab.kitware.com/cmake/cmake/-/issues/22184\nif(APPLE)\n  enable_language(OBJCXX)\n  set (CMAKE_OSX_DEPLOYMENT_TARGET \"13.0\" CACHE STRING \"Minimum OS X deployment version\" FORCE)\n  # Someday try to build universal binaries. Currently this causes a bunch of missing symbol errors on my M1 Air,\n  # since homebrew only installs arm64 versions of the libraries we depend on. I suspect vcpkg might work.\n  #set (CMAKE_OSX_ARCHITECTURES \"x86_64;arm64\" CACHE STRING \"Architectures\" FORCE)\nendif()\n\n# default to RelWithDebInfo\n# https://stackoverflow.com/questions/48832233/have-a-cmake-project-default-to-the-release-build-type\nif (NOT CMAKE_BUILD_TYPE OR CMAKE_BUILD_TYPE STREQUAL \"\")\n  set(CMAKE_BUILD_TYPE \"RelWithDebInfo\" CACHE STRING \"\" FORCE)\nendif()\n\n#\n# Heroes of Newerth\n#\nset(HON_GAME_ID \"hon\")\nset(HON_GAME_NAME \"Heroes of Newerth\")\nset(HON_GAME_NAME_SHORT \"HoN\")\nset(HON_CONTENT_DIR \"${noh_SOURCE_DIR}/Heroes of Newerth\")\nset(HON_ICON \"${HON_CONTENT_DIR}/icon.icns\")\nset_source_files_properties(${HON_ICON} PROPERTIES MACOSX_PACKAGE_LOCATION \"Resources\")\nlist(APPEND NOH_GAMES HON)\n\n#\n# Beatopia\n#\nset(BET_GAME_ID \"bet\")\nset(BET_GAME_NAME \"Beatopia\")\nset(BET_GAME_NAME_SHORT \"BeT\")\nset(BET_CONTENT_DIR \"${noh_SOURCE_DIR}/Beatopia\")\nlist(APPEND NOH_GAMES BET)\n\nset(SUFFIX \"\")\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  set(SUFFIX \"_debug\")\n  set(TITLE_SUFFIX \" Debug\")\n  add_definitions(-DDEBUG -D_DEBUG)\nelse()\n  add_definitions(-DNDEBUG)\nendif()\nif(APPLE)\n  set(LIB_EXT \"${SUFFIX}.dylib\")\n  set(DLL_EXT \"${SUFFIX}.dylib\")\n  set(EXE_EXT \"${TITLE_SUFFIX}\")\n  set(LIB_DIR \"${CMAKE_BINARY_DIR}\")\n  set(BIN_DIR \"${CMAKE_BINARY_DIR}\")\nelseif(WIN32)\n  set(EXE_TYPE WIN32)\n  set(LIB_EXT \"${SUFFIX}.lib\")\n  set(DLL_EXT \"${SUFFIX}.dll\")\n  set(EXE_EXT \"${TITLE_SUFFIX}\")\n  set(LIB_DIR \"${CMAKE_BINARY_DIR}\")\n  set(BIN_DIR \"${CMAKE_BINARY_DIR}\")\nelse()\n  set(LIB_EXT \"${SUFFIX}.so\")\n  set(DLL_EXT \"${SUFFIX}.so\")\n  set(EXE_EXT \"${TITLE_SUFFIX}\")\n  set(LIB_DIR \"${CMAKE_BINARY_DIR}\")\n  set(BIN_DIR \"${CMAKE_BINARY_DIR}\")\nendif()\n\nfunction(app_configure_mods target target_dir content_dir)\n  string(JOIN \"\\;\" game_mods ${ARGN})\n  target_compile_definitions(${target} PRIVATE \"-DGAME_MODS=\\\"${game_mods}\\\"\")\nendfunction()\n\nfunction(app_configure_game_settings target game_name game_subtitle)\n  if(\"${game_name}\" STREQUAL \"\")\n    message(FATAL_ERROR \"game name not set for ${target}\")\n  endif()\n  target_compile_definitions(${target} PRIVATE \"-DGAME_NAME=\\\"${game_name}\\\"\")\n  if(NOT \"${game_subtitle}\" STREQUAL \"\")\n    target_compile_definitions(${target} PRIVATE \"-DGAME_COMPONENT=\\\"${game_subtitle}\\\"\")\n  endif()\nendfunction()\n\nfunction(app_configure_lib library)\n  set(library_dir \"${LIB_DIR}\")\n  set(library_dll \"${library}${DLL_EXT}\")\n  set_target_properties(${library} PROPERTIES\n    PREFIX        \"\"\n    SUFFIX        \"${DLL_EXT}\"\n    IMPORT_SUFFIX \"${LIB_EXT}\"\n    LIBRARY_OUTPUT_DIRECTORY \"${library_dir}\"\n    RUNTIME_OUTPUT_DIRECTORY \"${library_dir}\"\n    # https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#compatible-interface-properties\n    POSITION_INDEPENDENT_CODE ON\n    )\n  # Copy the dll to the content dir of each game\n  foreach(game ${NOH_GAMES})\n    target_copy(${library}\n      \"${library_dir}/${library_dll}\"\n      \"${${game}_CONTENT_DIR}/${library_dll}\"\n      )\n  endforeach()\nendfunction()\n\nfunction(app_configure_exe exe_target exe_output_name exe_icon content_dir)\n  if(K2_SYMLINK_MOD_DIRS_IN_BUILD_DIR)\n    set(exe_dir \"${BIN_DIR}\")\n  else()\n    set(exe_dir \"${content_dir}\")\n  endif()\n  set(exe_name \"${exe_output_name}${EXE_EXT}\")\n  set_target_properties(${exe_target} PROPERTIES\n    RUNTIME_OUTPUT_DIRECTORY \"${exe_dir}\"\n    OUTPUT_NAME              \"${exe_name}\"\n    )\n  app_configure_mods(\"${exe_target}\" \"${exe_dir}\" \"${content_dir}\" ${ARGN})\n  if(UNIX)\n    # Create a symlink in the main directory called e.g. NoH (or NoH_debug) pointing to the freshly-built executable.\n    target_symlink(${exe_target}\n      \"${exe_dir}/${exe_name}\"\n      \"${noh_SOURCE_DIR}/${exe_name}\"\n      )\n  endif()\n  # Set file icon\n  # https://apple.stackexchange.com/questions/6901/how-can-i-change-a-file-or-folder-icon-using-the-terminal\n  if(APPLE)\n    # brew install fileicon\n    target_command(\"${exe_target}\" fileicon set \"${exe_dir}/${exe_name}\" \"${exe_icon}\")\n  endif()\n  if(K2_SYMLINK_MOD_DIRS_IN_BUILD_DIR)\n    # Copy the exe to the content dir of each game\n    foreach(game ${NOH_GAMES})\n      target_copy(${exe_target} \"${exe_dir}/${exe_name}\" \"${${game}_CONTENT_DIR}/${exe_name}\")\n    endforeach()\n  elseif(UNIX)\n    # Create a symlink in the build directory pointing to the content dir's executable\n    target_symlink(${exe_target}\n      \"${exe_dir}/${exe_name}\"\n      \"${BIN_DIR}/${exe_name}\"\n      )\n  endif()\nendfunction()\n\nfunction(app_configure_bundle app_target app_icon app_plist content_dir)\n  set(app_dir \"${CMAKE_BINARY_DIR}\")\n  set(app_name \"${app_target}${SUFFIX}.app\")\n  set(app_bundle \"${app_dir}/${app_name}\")\n  snakecase(\"${app_target}\" app_id)\n  set_target_properties(${app_target} PROPERTIES\n    BUNDLE                             TRUE\n    RUNTIME_OUTPUT_DIRECTORY           \"${app_dir}\"\n    MACOSX_BUNDLE_ICON_FILE            \"icon.icns\"\n    MACOSX_BUNDLE_GUI_IDENTIFIER       \"shawwn.com.${app_id}\"\n    MACOSX_BUNDLE_BUNDLE_NAME          \"${app_target}\"\n    MACOSX_BUNDLE_BUNDLE_VERSION       \"0.1\"\n    MACOSX_BUNDLE_SHORT_VERSION_STRING \"0.1\"\n    MACOSX_BUNDLE_INFO_PLIST           \"${app_plist}\"\n    )\n  target_copy(\"${app_target}\" \"${K2_LIBRARY_DLL}\"      \"${app_bundle}/${K2_LIBRARY}${DLL_EXT}\")\n  target_copy(\"${app_target}\" \"${VID_GL2_LIBRARY_DLL}\" \"${app_bundle}/${VID_GL2_LIBRARY}${DLL_EXT}\")\n  app_configure_mods(\"${app_target}\" \"${app_bundle}\" \"${content_dir}\" ${ARGN})\nendfunction()\n\n\nfunction(disp status)\n  string(JOIN \" \" msg ${ARGN})\n  message(${status} \"${msg}\")\nendfunction()\n\nset(VERBOSE 0)\nfunction(debug)\n  if (VERBOSE)\n    disp(STATUS \" [DEBUG] -- \" ${ARGN})\n  endif()\nendfunction()\n\nfunction(info)\n  disp(STATUS ${ARGN})\nendfunction()\n\nfunction(err)\n  disp(FATAL_ERROR ${ARGN})\nendfunction()\n\nmacro(assert cond)\n  if (NOT ${cond})\n    err(\"Assertion failed: ${cond} \" ${ARGN})\n  endif()\nendmacro()\n\nfunction(symlink src dst)\n  info(\"symlink ${src} -> ${dst}\")\n  execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink \"${src}\" \"${dst}\")\nendfunction()\n\nfunction(symlinks)\n  set(l ${ARGN})\n  while(l)\n    list(POP_FRONT l src dst)\n    debug(\"src: ${src} -> dst: ${dst}\")\n    assert(dst \"symlinks: dst is null\")\n    symlink(\"${src}\" \"${dst}\")\n  endwhile()\nendfunction()\n\nfunction(target_command target)\n  debug(\"adding ${target} post build command: \" ${ARGN})\n  add_custom_command(\n    TARGET \"${target}\" POST_BUILD\n    COMMAND ${ARGN}\n    VERBATIM\n  )\nendfunction()\n\nfunction(target_symlink target src dst)\n  info(\"${target}: symlink ${src} -> ${dst}\")\n  # add_custom_command(\n  #   OUTPUT \"${dst}\"\n  #   COMMAND ${CMAKE_COMMAND} -E create_symlink \"${src}\" \"${dst}\"\n  #   MAIN_DEPENDENCY \"${target}\"\n  #   VERBATIM\n  #   )\n  # add_custom_command(\n  #   TARGET \"${target}\" POST_BUILD\n  #   COMMAND ${CMAKE_COMMAND} -E create_symlink \"${src}\" \"${dst}\"\n  #   VERBATIM\n  #   )\n  # #target_sources(${target} PRIVATE \"${dst}\")\n  target_command(\"${target}\" \"${CMAKE_COMMAND}\" -E create_symlink \"${src}\" \"${dst}\")\nendfunction()\n\nfunction(target_copy target src dst)\n  info(\"${target}: copy ${src} -> ${dst}\")\n  target_command(\"${target}\" \"${CMAKE_COMMAND}\" -E copy \"${src}\" \"${dst}\")\nendfunction()\n\n# Converts \"Foo Bar\" to a snake case identifier like foo_bar\nfunction(snakecase name VAR)\n  string(MAKE_C_IDENTIFIER \"${name}\" \"${VAR}\")\n  string(TOLOWER \"${${VAR}}\" \"${VAR}\")\n  return(PROPAGATE \"${VAR}\")\nendfunction()\n\ninclude(FindPackageHandleStandardArgs)\nmacro(handle_standard_args lib)\n  # handle the QUIETLY and REQUIRED arguments and set ${lib}_FOUND to TRUE if\n  # all listed variables are TRUE\n  if (NOT DEFINED ${lib}_INCLUDE_DIR)\n    if (DEFINED ${lib}_INCLUDE_DIRS)\n      set(${lib}_INCLUDE_DIR ${${lib}_INCLUDE_DIRS})\n    endif()\n  endif()\n  if (NOT DEFINED ${lib}_LIBRARIES)\n    if (DEFINED ${lib}_LIBRARY)\n      set(${lib}_LIBRARIES ${${lib}_LIBRARY})\n    endif()\n  endif()\n  FIND_PACKAGE_HANDLE_STANDARD_ARGS(${lib}\n    REQUIRED_VARS ${lib}_LIBRARIES ${lib}_INCLUDE_DIR\n    VERSION_VAR ${lib}_VERSION_STRING)\n  if (NOT DEFINED ${lib}_LIBRARY)\n    set(${lib}_LIBRARY ${${lib}_LIBRARIES})\n  endif()\n  if (NOT DEFINED ${lib}_INCLUDE_DIRS)\n    set(${lib}_INCLUDE_DIRS ${${lib}_INCLUDE_DIR})\n  endif()\n  mark_as_advanced(${lib}_INCLUDE_DIR ${lib}_LIBRARY)\n  if (NOT ${lib}_FOUND)\n    message(FATAL_ERROR \"Can't find ${lib} library\")\n  endif()\nendmacro()\n\nmacro(add_package_for_k2 LIB)\n  handle_standard_args(${LIB})\n  if (NOT DEFINED ${LIB}_INCLUDE_DIRS)\n    message(FATAL_ERROR \"${LIB}_INCLUDE_DIRS not defined\")\n  endif()\n  if (NOT DEFINED ${LIB}_LIBRARIES)\n    message(FATAL_ERROR \"${LIB}_LIBRARIES not defined\")\n  endif()\n  list(APPEND K2_INCLUDE_DIRS ${${LIB}_INCLUDE_DIRS})\n  list(APPEND K2_LIBRARIES ${${LIB}_LIBRARIES})\n  #return(PROPAGATE K2_INCLUDE_DIRS K2_LIBRARIES)\nendmacro()\n\nmacro(find_package_for_k2 name var)\n  find_package(\"${name}\" REQUIRED)\n  add_package_for_k2(${var})\nendmacro()\n\nmacro(find_include_dir VAR ROOT header)\n  find_path(${VAR}\n    ${header}\n    PATH_SUFFIXES ${ARGN}\n    PATHS \"${ROOT}\" ENV ${ROOT} REQUIRED)\nendmacro()\n\nmessage(STATUS \"CMAKE_CXX_FLAGS: \" ${CMAKE_CXX_FLAGS})\nmessage(STATUS \"CMAKE_OBJC_FLAGS: \" ${CMAKE_OBJC_FLAGS})\n\n#\n# fmod\n#\nset(FMOD_ROOT \"${noh_SOURCE_DIR}/lib/fmodex/api/core\" CACHE STRING \"FMOD SDK core API directory\")\nfind_include_dir(FMOD_INCLUDE_DIR \"${FMOD_ROOT}\"\n  fmod.h\n  inc)\nif(WIN32)\n  if(CMAKE_SIZEOF_VOID_P EQUAL 8)\n    find_library(FMOD_LIBRARY\n      NAMES fmod_vc\n      NAMES_PER_DIR\n      PATH_SUFFIXES lib/x64\n      PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\n  else()\n    find_library(FMOD_LIBRARY\n      NAMES fmod_vc\n      NAMES_PER_DIR\n      PATH_SUFFIXES lib/x86\n      PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\n  endif()\nelse()\n  find_library(FMOD_LIBRARY\n    NAMES fmod_vc fmod\n    NAMES_PER_DIR\n    PATH_SUFFIXES lib lib/x86 lib/x86_64 lib/x64\n    PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\nendif()\nadd_package_for_k2(FMOD)\n# get the directory of the found library\nget_filename_component(FMOD_LIBRARY_DIR ${FMOD_LIBRARY} DIRECTORY)\n# construct the path to the dll\nif(WIN32)\n  set(FMOD_DLL_PATH \"${FMOD_LIBRARY_DIR}/fmod.dll\")\nelseif(APPLE)\n  set(FMOD_DLL_PATH \"${FMOD_LIBRARY_DIR}/libfmod.dylib\")\nelse()\n  set(FMOD_DLL_PATH \"${FMOD_LIBRARY_DIR}/libfmod.so\")\nendif()\n\n#\n# SpeedTree\n#\nset(SPEEDTREE_ROOT \"${noh_SOURCE_DIR}/lib/SpeedTree\")\nfind_include_dir(SPEEDTREE_INCLUDE_DIR \"${SPEEDTREE_ROOT}\"\n  SpeedTreeRT.h\n  include)\nset(SPEEDTREE_LIBRARIES SpeedTree)\nlist(APPEND CMAKE_MODULE_PATH \"${SPEEDTREE_ROOT}/cmake\")\ninclude(SpeedTree)\nadd_package_for_k2(SPEEDTREE)\n\nif(APPLE)\n  # brew install fswatch\n  set(FSWATCH_ROOT /opt/homebrew/opt/fswatch CACHE STRING \"Path to fswatch directory\")\n  find_include_dir(FSWATCH_INCLUDE_DIR\n    \"${FSWATCH_ROOT}\"\n    libfswatch/c/libfswatch.h\n    include)\n  find_library(FSWATCH_LIBRARY REQUIRED\n    NAMES fswatch\n    NAMES_PER_DIR\n    PATH_SUFFIXES lib\n    PATHS \"${FSWATCH_ROOT}\" ENV FSWATCH_ROOT)\n  list(APPEND K2_INCLUDE_DIRS \"${noh_SOURCE_DIR}/lib/fswatch/include\")\n  add_package_for_k2(FSWATCH)\nendif()\n\n# brew install speex\nfind_package_for_k2(Speex SPEEX)\n# brew install speexdsp\nfind_package_for_k2(SpeexDSP SPEEXDSP)\n# brew install openssl@1.1\nif(APPLE)\n  # Fix debugger crash in OpenSSL 3 (by using OpenSSL 1.1 instead):\n  # https://github.com/openssl/openssl/issues/20753\n  set(OPENSSL_ROOT_DIR /opt/homebrew/opt/openssl@1.1)\nendif()\nfind_package_for_k2(OpenSSL OPENSSL)\n# brew install giflib\nfind_package_for_k2(GIF GIF)\nfind_package_for_k2(PNG PNG)\nfind_package_for_k2(CURL CURL)\nfind_package_for_k2(ZLIB ZLIB)\nif(APPLE)\n  # find_package(JPEG) doesn't seem to locate homebrew jpeg, and there's\n  # no way to specify a root directory like JPEG_ROOT_DIR. Just hardcode\n  # to homebrew for now.\n  set(JPEG_LIBRARY /opt/homebrew/opt/libjpeg/lib/libjpeg.dylib)\n  set(JPEG_INCLUDE_DIR /opt/homebrew/opt/libjpeg/include)\nendif()\nfind_package_for_k2(JPEG JPEG)\nfind_package_for_k2(LibXml2 LIBXML2)\nfind_package_for_k2(Freetype FREETYPE)\nlist(APPEND K2_INCLUDE_DIRS \"${noh_SOURCE_DIR}/lib/libpng/include\")\nif(WIN32)\n  find_package(OpenGL REQUIRED)\n  list(APPEND K2_LIBRARIES ${OPENGL_LIBRARIES})\nelse()\n  find_package_for_k2(OpenGL OPENGL)\nendif()\nif(UNIX)\n  find_package_for_k2(Curses CURSES)\nendif()\nif(LINUX)\n  find_package_for_k2(Xrandr XRANDR)\nendif()\n\nif(CMAKE_SIZEOF_VOID_P EQUAL 8)\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_64)\nendif()\n\nif(BUILD_STATIC)\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_LIB)\n  list(APPEND HON_SHARED_PUBLIC_DEFINITIONS -DGAME_SHARED_LIB)\nelse()\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_DLL)\n  list(APPEND HON_SHARED_PUBLIC_DEFINITIONS -DGAME_SHARED_DLL)\nendif()\n\nlist(APPEND K2_INCLUDE_DIRS_PUBLIC \"${noh_SOURCE_DIR}/lib/k2public\")\n\n#========================================\n# k2\n#========================================\nset(K2_LIBRARY k2)\nset(K2_LIBRARY_LIB \"${K2_LIBRARY}\")\nset(K2_LIBRARY_DLL \"${BIN_DIR}/${K2_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(K2_LIBRARY_LIB \"${LIB_DIR}/${K2_LIBRARY}${LIB_EXT}\")\nendif()\n\nif(APPLE)\n  list(APPEND K2_LIBRARIES\n    \"-framework Foundation\"\n    \"-framework AppKit\"\n    \"-framework CoreAudio\"\n    \"-framework IOKit\")\nelseif(LINUX)\n  list(APPEND K2_LIBRARIES\n    X11)\nelseif(WIN32)\n  list(APPEND K2_LIBRARIES\n    wsock32\n    ws2_32\n    psapi\n    iphlpapi\n    wbemuuid)\nendif()\n\nset(K2_SOURCES\n  #  src/k2/md6.cpp\n  src/k2/blue_noise.h\n  src/k2/c_accountmanager.cpp\n  src/k2/c_accountmanager.h\n  src/k2/c_action.cpp\n  src/k2/c_action.h\n  src/k2/c_actionregistry.cpp\n  src/k2/c_actionregistry.h\n  src/k2/c_alias.cpp\n  src/k2/c_alias.h\n  src/k2/c_anim.cpp\n  src/k2/c_anim.h\n  src/k2/c_animatedimage.cpp\n  src/k2/c_animatedimage.h\n  src/k2/c_archive.cpp\n  src/k2/c_archive.h\n  src/k2/c_avatar.cpp\n  src/k2/c_avatar.h\n  src/k2/c_axis.h\n  src/k2/c_beamemitter.cpp\n  src/k2/c_beamemitter.h\n  src/k2/c_billboardemitter.cpp\n  src/k2/c_billboardemitter.h\n  src/k2/c_bind.h\n  src/k2/c_bitmap.cpp\n  src/k2/c_bitmap.h\n  src/k2/c_bitmapresource.cpp\n  src/k2/c_bitmapresource.h\n  src/k2/c_blockpool.h\n  src/k2/c_bone.cpp\n  src/k2/c_bone.h\n  src/k2/c_boundingbox.h\n  src/k2/c_boundingcone.cpp\n  src/k2/c_boundingcone.h\n  src/k2/c_brush.cpp\n  src/k2/c_brush.h\n  src/k2/c_buffer.cpp\n  src/k2/c_buffer.h\n  src/k2/c_button.cpp\n  src/k2/c_button.h\n  src/k2/c_buttoncatcher.cpp\n  src/k2/c_buttoncatcher.h\n  src/k2/c_bytemanager.cpp\n  src/k2/c_bytemanager.h\n  src/k2/c_camera.cpp\n  src/k2/c_camera.h\n  src/k2/c_chatmanager.cpp\n  src/k2/c_chatmanager.h\n  src/k2/c_checksumtable.cpp\n  src/k2/c_checksumtable.h\n  src/k2/c_clientconnection.cpp\n  src/k2/c_clientconnection.h\n  src/k2/c_clientgamelib.cpp\n  src/k2/c_clientgamelib.h\n  src/k2/c_clientlogin.cpp\n  src/k2/c_clientlogin.h\n  src/k2/c_clientsnapshot.cpp\n  src/k2/c_clientsnapshot.h\n  src/k2/c_cliffdefinitionresource.cpp\n  src/k2/c_cliffdefinitionresource.h\n  src/k2/c_cliffsetlist.cpp\n  src/k2/c_cliffsetlist.h\n  src/k2/c_cliffvariationmap.cpp\n  src/k2/c_cliffvariationmap.h\n  src/k2/c_clip.cpp\n  src/k2/c_clip.h\n  src/k2/c_cmd.cpp\n  src/k2/c_cmd.h\n  src/k2/c_cmdprecache.cpp\n  src/k2/c_cmdprecache.h\n  src/k2/c_combobox.cpp\n  src/k2/c_combobox.h\n  src/k2/c_combobox_listbox.cpp\n  src/k2/c_combobox_listbox.h\n  src/k2/c_compressedfile.cpp\n  src/k2/c_compressedfile.h\n  src/k2/c_console.cpp\n  src/k2/c_console.h\n  src/k2/c_consoleelement.cpp\n  src/k2/c_consoleelement.h\n  src/k2/c_consoleregistry.cpp\n  src/k2/c_consoleregistry.h\n  src/k2/c_controlleremitter.cpp\n  src/k2/c_controlleremitter.h\n  src/k2/c_convexhull.cpp\n  src/k2/c_convexhull.h\n  src/k2/c_convexpolygon.cpp\n  src/k2/c_convexpolygon.h\n  src/k2/c_convexpolygon2.cpp\n  src/k2/c_convexpolygon2.h\n  src/k2/c_convexpolyhedron.cpp\n  src/k2/c_convexpolyhedron.h\n  src/k2/c_cursor.cpp\n  src/k2/c_cursor.h\n  src/k2/c_cvar.cpp\n  src/k2/c_cvar.h\n  src/k2/c_cvararray.cpp\n  src/k2/c_cvararray.h\n  src/k2/c_cvarlabel.cpp\n  src/k2/c_cvarlabel.h\n  src/k2/c_cvarreference.cpp\n  src/k2/c_cvarreference.h\n  src/k2/c_date.cpp\n  src/k2/c_date.h\n  src/k2/c_debrisemitter.cpp\n  src/k2/c_debrisemitter.h\n  src/k2/c_DebugRenderer.cpp\n  src/k2/c_DebugRenderer.h\n  src/k2/c_draw2d.cpp\n  src/k2/c_draw2d.h\n  src/k2/c_edge.cpp\n  src/k2/c_edge.h\n  src/k2/c_effect.cpp\n  src/k2/c_effect.h\n  src/k2/c_effectpanel.cpp\n  src/k2/c_effectpanel.h\n  src/k2/c_effectthread.cpp\n  src/k2/c_effectthread.h\n  src/k2/c_entitysnapshot.cpp\n  src/k2/c_entitysnapshot.h\n  src/k2/c_eventcmd.cpp\n  src/k2/c_eventcmd.h\n  src/k2/c_eventcmdregistry.cpp\n  src/k2/c_eventcmdregistry.h\n  src/k2/c_eventmanager.cpp\n  src/k2/c_eventmanager.h\n  src/k2/c_eventscript.cpp\n  src/k2/c_eventscript.h\n  src/k2/c_exception.cpp\n  src/k2/c_exception.h\n  # src/k2/c_fastunzip.cpp\n  # src/k2/c_fastunzip.h\n  src/k2/c_file.cpp\n  src/k2/c_file.h\n  src/k2/c_filearchive.cpp\n  src/k2/c_filearchive.h\n  src/k2/c_filebuffer.cpp\n  src/k2/c_filebuffer.h\n  src/k2/c_filechangecallback.cpp\n  src/k2/c_filechangecallback.h\n  src/k2/c_filedisk.cpp\n  src/k2/c_filedisk.h\n  src/k2/c_filehandle.cpp\n  src/k2/c_filehandle.h\n  src/k2/c_filehttp.cpp\n  src/k2/c_filehttp.h\n  src/k2/c_filemanager.cpp\n  src/k2/c_filemanager.h\n  src/k2/c_filestream.cpp\n  src/k2/c_filestream.h\n  src/k2/c_floater.cpp\n  src/k2/c_floater.h\n  src/k2/c_foliagedensitymap.h\n  src/k2/c_fontface.cpp\n  src/k2/c_fontface.h\n  src/k2/c_fontmap.cpp\n  src/k2/c_fontmap.h\n  src/k2/c_frame.cpp\n  src/k2/c_frame.h\n  # src/k2/c_frame_border.cpp\n  # src/k2/c_frame_border.h\n  src/k2/c_freetype.cpp\n  src/k2/c_freetype.h\n  src/k2/c_frustum.cpp\n  src/k2/c_frustum.h\n  src/k2/c_function.cpp\n  src/k2/c_function.h\n  src/k2/c_gamebind.cpp\n  src/k2/c_gamebind.h\n  src/k2/c_gate.h\n  src/k2/c_groundspriteemitter.cpp\n  src/k2/c_groundspriteemitter.h\n  src/k2/c_heap.cpp\n  src/k2/c_heap.h\n  # src/k2/c_heapfactory.cpp\n  # src/k2/c_heapfactory.h\n  src/k2/c_heightmap.cpp\n  src/k2/c_heightmap.h\n  src/k2/c_host.cpp\n  src/k2/c_host.h\n  src/k2/c_hostclient.cpp\n  src/k2/c_hostclient.h\n  src/k2/c_hostinterface.cpp\n  src/k2/c_hostinterface.h\n  src/k2/c_hostserver.cpp\n  src/k2/c_hostserver.h\n  src/k2/c_httpmanager.cpp\n  src/k2/c_httpmanager.h\n  src/k2/c_httprequest.cpp\n  src/k2/c_httprequest.h\n  src/k2/c_image.cpp\n  src/k2/c_image.h\n  src/k2/c_input.cpp\n  src/k2/c_input.h\n  src/k2/c_inputstate.h\n  src/k2/c_interface.cpp\n  src/k2/c_interface.h\n  src/k2/c_interfaceresource.cpp\n  src/k2/c_interfaceresource.h\n  src/k2/c_k2model.cpp\n  src/k2/c_k2model.h\n  src/k2/c_label.cpp\n  src/k2/c_label.h\n  src/k2/c_lerps.cpp\n  src/k2/c_lerps.h\n  src/k2/c_lightemitter.cpp\n  src/k2/c_lightemitter.h\n  src/k2/c_listbox.cpp\n  src/k2/c_listbox.h\n  src/k2/c_listbox_scrollbar.cpp\n  src/k2/c_listbox_scrollbar.h\n  src/k2/c_listitem.cpp\n  src/k2/c_listitem.h\n  # src/k2/c_locale.cpp\n  # src/k2/c_locale.h\n  src/k2/c_material.cpp\n  src/k2/c_material.h\n  src/k2/c_materialbrush.cpp\n  src/k2/c_materialbrush.h\n  src/k2/c_materiallist.cpp\n  src/k2/c_materiallist.h\n  src/k2/c_materialparameter.cpp\n  src/k2/c_materialparameter.h\n  # src/k2/c_matrix3x3.cpp\n  src/k2/c_matrix3x3.h\n  src/k2/c_matrix4x3.h\n  src/k2/c_memmanager.cpp\n  src/k2/c_memmanager.h\n  src/k2/c_menu.cpp\n  src/k2/c_menu.h\n  src/k2/c_menu_listbox.cpp\n  src/k2/c_menu_listbox.h\n  src/k2/c_mesh.cpp\n  src/k2/c_mesh.h\n  src/k2/c_meshemitter.cpp\n  src/k2/c_meshemitter.h\n  src/k2/c_minimap.cpp\n  src/k2/c_minimap.h\n  src/k2/c_mmapunzip.cpp\n  src/k2/c_mmapunzip.h\n  src/k2/c_model.cpp\n  src/k2/c_model.h\n  src/k2/c_modelallocatorregistry.cpp\n  src/k2/c_modelallocatorregistry.h\n  src/k2/c_modelemitter.cpp\n  src/k2/c_modelemitter.h\n  src/k2/c_modelpanel.cpp\n  src/k2/c_modelpanel.h\n  src/k2/c_modifier.h\n  src/k2/c_movie.h\n  src/k2/c_movie_linux.cpp\n  # src/k2/c_movie_win32.cpp\n  src/k2/c_navgridUnits.cpp\n  src/k2/c_navgridUnits.h\n  src/k2/c_navgridZ.cpp\n  src/k2/c_navgridZ.h\n  src/k2/c_navigationgraph.cpp\n  src/k2/c_navigationgraph.h\n  src/k2/c_navigationmap.cpp\n  src/k2/c_navigationmap.h\n  src/k2/c_netdriver.h\n  src/k2/c_netstats.cpp\n  src/k2/c_netstats.h\n  src/k2/c_networkresourcemanager.cpp\n  src/k2/c_networkresourcemanager.h\n  src/k2/c_occluder.cpp\n  src/k2/c_occluder.h\n  src/k2/c_occlusionmap.cpp\n  src/k2/c_occlusionmap.h\n  src/k2/c_optionsmanager.cpp\n  src/k2/c_optionsmanager.h\n  src/k2/c_orbiter.cpp\n  src/k2/c_orbiter.h\n  src/k2/c_orbiteremitter.cpp\n  src/k2/c_orbiteremitter.h\n  src/k2/c_orthofrustum.cpp\n  src/k2/c_orthofrustum.h\n  src/k2/c_packet.cpp\n  src/k2/c_packet.h\n  src/k2/c_panel.cpp\n  src/k2/c_panel.h\n  src/k2/c_particlepool.cpp\n  src/k2/c_particlepool.h\n  src/k2/c_particlesystem.cpp\n  src/k2/c_particlesystem.h\n  src/k2/c_path.cpp\n  src/k2/c_path.h\n  src/k2/c_phpdata.cpp\n  src/k2/c_phpdata.h\n  src/k2/c_piegraph.cpp\n  src/k2/c_piegraph.h\n  src/k2/c_pixelshader.cpp\n  src/k2/c_pixelshader.h\n  src/k2/c_plane.cpp\n  src/k2/c_plane.h\n  src/k2/c_plane2.cpp\n  src/k2/c_plane2.h\n  src/k2/c_pool.h\n  src/k2/c_posteffect.cpp\n  src/k2/c_posteffect.h\n  src/k2/c_precipemitter.cpp\n  src/k2/c_precipemitter.h\n  src/k2/c_priorityqueue.h\n  src/k2/c_profilemanager.cpp\n  src/k2/c_profilemanager.h\n  src/k2/c_profilenode.cpp\n  src/k2/c_profilenode.h\n  src/k2/c_profilesample.cpp\n  src/k2/c_profilesample.h\n  src/k2/c_ramplist.cpp\n  src/k2/c_ramplist.h\n  src/k2/c_rampresource.cpp\n  src/k2/c_rampresource.h\n  src/k2/c_range.h\n  src/k2/c_rasterbuffer.cpp\n  src/k2/c_rasterbuffer.h\n  src/k2/c_rect.h\n  src/k2/c_recyclepool.h\n  src/k2/c_referencecounter.h\n  src/k2/c_referencerecyclepool.h\n  src/k2/c_reliablepacket.cpp\n  src/k2/c_reliablepacket.h\n  src/k2/c_resourcemanager.cpp\n  src/k2/c_resourcemanager.h\n  src/k2/c_resourcereference.cpp\n  src/k2/c_resourcereference.h\n  src/k2/c_resourceinfo.cpp\n  src/k2/c_resourceinfo.h\n  src/k2/c_resultgate.h\n  src/k2/c_resultsegment.h\n  src/k2/c_sample.cpp\n  src/k2/c_sample.h\n  src/k2/c_sceneentity.cpp\n  src/k2/c_sceneentity.h\n  src/k2/c_sceneentitymodifier.cpp\n  src/k2/c_sceneentitymodifier.h\n  src/k2/c_scenelight.h\n  src/k2/c_scenemanager.cpp\n  src/k2/c_scenemanager.h\n  src/k2/c_sceneobject.h\n  src/k2/c_scenestats.cpp\n  src/k2/c_scenestats.h\n  src/k2/c_script.cpp\n  src/k2/c_script.h\n  src/k2/c_scriptthread.cpp\n  src/k2/c_scriptthread.h\n  src/k2/c_scrollbar.cpp\n  src/k2/c_scrollbar.h\n  src/k2/c_scrollbar_button.cpp\n  src/k2/c_scrollbar_button.h\n  src/k2/c_scrollbar_slider.cpp\n  src/k2/c_scrollbar_slider.h\n  src/k2/c_searchgate.h\n  src/k2/c_searchgateR.h\n  src/k2/c_searchnode.cpp\n  src/k2/c_searchnode.h\n  src/k2/c_serverchatconnection.cpp\n  src/k2/c_serverchatconnection.h\n  src/k2/c_servergamelib.cpp\n  src/k2/c_servergamelib.h\n  src/k2/c_servermanager.cpp\n  src/k2/c_servermanager.h\n  src/k2/c_simpleemitter.cpp\n  src/k2/c_simpleemitter.h\n  src/k2/c_simpleparticle.cpp\n  src/k2/c_simpleparticle.h\n  src/k2/c_skeleton.cpp\n  src/k2/c_skeleton.h\n  src/k2/c_skeletonbonepool.cpp\n  src/k2/c_skeletonbonepool.h\n  src/k2/c_skeletonemitter.cpp\n  src/k2/c_skeletonemitter.h\n  src/k2/c_skin.cpp\n  src/k2/c_skin.h\n  src/k2/c_slider.cpp\n  src/k2/c_slider.h\n  src/k2/c_slider_handle.cpp\n  src/k2/c_slider_handle.h\n  src/k2/c_snapshot.cpp\n  src/k2/c_snapshot.h\n  src/k2/c_snaptarget.cpp\n  src/k2/c_snaptarget.h\n  src/k2/c_socket.cpp\n  src/k2/c_socket.h\n  src/k2/c_soundemitter.cpp\n  src/k2/c_soundemitter.h\n  src/k2/c_soundmanager.cpp\n  src/k2/c_soundmanager.h\n  src/k2/c_sphere.h\n  src/k2/c_stateblock.cpp\n  src/k2/c_stateblock.h\n  src/k2/c_statestring.cpp\n  src/k2/c_statestring.h\n  src/k2/c_stringtable.cpp\n  src/k2/c_stringtable.h\n  src/k2/c_swatch.cpp\n  src/k2/c_swatch.h\n  src/k2/c_system.h\n  # src/k2/c_system_linux.cpp\n  # src/k2/c_system_osx.mm\n  # src/k2/c_system_posix.cpp\n  # src/k2/c_system_win32.cpp\n  src/k2/c_table.cpp\n  src/k2/c_table.h\n  src/k2/c_table_scrollbar.cpp\n  src/k2/c_table_scrollbar.h\n  src/k2/c_temporalproperty.h\n  src/k2/c_temporalpropertyrange.h\n  src/k2/c_temporalrange.h\n  src/k2/c_terrainemitter.cpp\n  src/k2/c_terrainemitter.h\n  src/k2/c_texelalphamap.cpp\n  src/k2/c_texelalphamap.h\n  src/k2/c_texelocclusionmap.cpp\n  src/k2/c_texelocclusionmap.h\n  src/k2/c_textbox.cpp\n  src/k2/c_textbox.h\n  src/k2/c_textbuffer.cpp\n  src/k2/c_textbuffer.h\n  src/k2/c_textbuffer_scrollbar.cpp\n  src/k2/c_textbuffer_scrollbar.h\n  src/k2/c_texture.cpp\n  src/k2/c_texture.h\n  src/k2/c_texturelist.cpp\n  src/k2/c_texturelist.h\n  src/k2/c_tilecliffmap.cpp\n  src/k2/c_tilecliffmap.h\n  src/k2/c_tilefoliagemap.cpp\n  src/k2/c_tilefoliagemap.h\n  src/k2/c_tilematerialmap.cpp\n  src/k2/c_tilematerialmap.h\n  src/k2/c_tilenormalmap.cpp\n  src/k2/c_tilenormalmap.h\n  src/k2/c_tilerampmap.cpp\n  src/k2/c_tilerampmap.h\n  src/k2/c_tilesplitmap.cpp\n  src/k2/c_tilesplitmap.h\n  src/k2/c_tilevisionmap.cpp\n  src/k2/c_tilevisionmap.h\n  src/k2/c_timermanager.cpp\n  src/k2/c_timermanager.h\n  src/k2/c_traceremitter.cpp\n  src/k2/c_traceremitter.h\n  src/k2/c_tracker.cpp\n  src/k2/c_tracker.h\n  src/k2/c_trackeremitter.cpp\n  src/k2/c_trackeremitter.h\n  src/k2/c_trailemitter.cpp\n  src/k2/c_trailemitter.h\n  # src/k2/c_transmitflags.cpp\n  # src/k2/c_transmitflags.h\n  src/k2/c_treemodel.cpp\n  src/k2/c_treemodel.h\n  src/k2/c_twopointemitter.cpp\n  src/k2/c_twopointemitter.h\n  src/k2/c_twopointtrailemitter.cpp\n  src/k2/c_twopointtrailemitter.h\n  src/k2/c_uicmd.cpp\n  src/k2/c_uicmd.h\n  src/k2/c_uicmdregistry.cpp\n  src/k2/c_uicmdregistry.h\n  src/k2/c_uiform.cpp\n  src/k2/c_uiform.h\n  src/k2/c_uimanager.cpp\n  src/k2/c_uimanager.h\n  src/k2/c_uiscript.cpp\n  src/k2/c_uiscript.h\n  src/k2/c_uiscripttoken.cpp\n  src/k2/c_uiscripttoken.h\n  src/k2/c_uitextureregistry.cpp\n  src/k2/c_uitextureregistry.h\n  src/k2/c_uitrigger.cpp\n  src/k2/c_uitrigger.h\n  src/k2/c_uitriggerregistry.cpp\n  src/k2/c_uitriggerregistry.h\n  # src/k2/c_uixmlparser.cpp\n  # src/k2/c_uixmlparser.h\n  src/k2/c_unzip.cpp\n  src/k2/c_unzip.h\n  src/k2/c_updater.cpp\n  src/k2/c_updater.h\n  src/k2/c_upgrades.cpp\n  src/k2/c_upgrades.h\n  src/k2/c_vec.h\n  src/k2/c_vec2.h\n  src/k2/c_vec3.h\n  src/k2/c_vec4.h\n  src/k2/c_vertexblockermap.cpp\n  src/k2/c_vertexblockermap.h\n  src/k2/c_vertexcameraheightmap.cpp\n  src/k2/c_vertexcameraheightmap.h\n  src/k2/c_vertexcliffmap.cpp\n  src/k2/c_vertexcliffmap.h\n  src/k2/c_vertexcolormap.cpp\n  src/k2/c_vertexcolormap.h\n  src/k2/c_vertexfoliagemap.cpp\n  src/k2/c_vertexfoliagemap.h\n  src/k2/c_vertexnormalmap.cpp\n  src/k2/c_vertexnormalmap.h\n  src/k2/c_vertexshader.cpp\n  src/k2/c_vertexshader.h\n  src/k2/c_vertextangentmap.cpp\n  src/k2/c_vertextangentmap.h\n  src/k2/c_vid.cpp\n  src/k2/c_vid.h\n  src/k2/c_voicemanager.cpp\n  src/k2/c_voicemanager.h\n  src/k2/c_voiceserver.cpp\n  src/k2/c_voiceserver.h\n  src/k2/c_voiceuser.cpp\n  src/k2/c_voiceuser.h\n  src/k2/c_webimage.cpp\n  src/k2/c_webimage.h\n  src/k2/c_webpanel.cpp\n  src/k2/c_webpanel.h\n  src/k2/c_widgetreference.cpp\n  src/k2/c_widgetreference.h\n  src/k2/c_widgetstate.cpp\n  src/k2/c_widgetstate.h\n  src/k2/c_widgetstyle.cpp\n  src/k2/c_widgetstyle.h\n  src/k2/c_widgettemplate.cpp\n  src/k2/c_widgettemplate.h\n  src/k2/c_world.cpp\n  src/k2/c_world.h\n  # src/k2/c_worldblock.cpp\n  # src/k2/c_worldblock.h\n  # src/k2/c_worldblockhandle.cpp\n  # src/k2/c_worldblockhandle.h\n  src/k2/c_worldentity.h\n  src/k2/c_worldentitylist.cpp\n  src/k2/c_worldentitylist.h\n  src/k2/c_worldlight.h\n  src/k2/c_worldlightlist.cpp\n  src/k2/c_worldlightlist.h\n  src/k2/c_worldoccluderlist.cpp\n  src/k2/c_worldoccluderlist.h\n  src/k2/c_worldsound.h\n  src/k2/c_worldsoundlist.cpp\n  src/k2/c_worldsoundlist.h\n  src/k2/c_worldtree.cpp\n  src/k2/c_worldtree.h\n  src/k2/c_worldtriggerlist.cpp\n  src/k2/c_worldtriggerlist.h\n  src/k2/c_xmldoc.cpp\n  src/k2/c_xmldoc.h\n  src/k2/c_xmlmanager.cpp\n  src/k2/c_xmlmanager.h\n  src/k2/c_xmlnode.cpp\n  src/k2/c_xmlnode.h\n  src/k2/c_xmlproc_anchor.cpp\n  src/k2/c_xmlproc_animatedimage.cpp\n  src/k2/c_xmlproc_brushmat.cpp\n  src/k2/c_xmlproc_button.cpp\n  src/k2/c_xmlproc_button.h\n  src/k2/c_xmlproc_buttoncatcher.cpp\n  src/k2/c_xmlproc_buttoncatcher.h\n  src/k2/c_xmlproc_combobox.cpp\n  src/k2/c_xmlproc_combobox.h\n  src/k2/c_xmlproc_cursor.cpp\n  src/k2/c_xmlproc_cvar.cpp\n  src/k2/c_xmlproc_cvarlabel.cpp\n  src/k2/c_xmlproc_cvarlabel.h\n  src/k2/c_xmlproc_dirlistitems.cpp\n  src/k2/c_xmlproc_effect.cpp\n  src/k2/c_xmlproc_effectpanel.cpp\n  src/k2/c_xmlproc_effectpanel.h\n  src/k2/c_xmlproc_floater.cpp\n  src/k2/c_xmlproc_floater.h\n  src/k2/c_xmlproc_fontface.cpp\n  src/k2/c_xmlproc_form.cpp\n  src/k2/c_xmlproc_frame.cpp\n  src/k2/c_xmlproc_frame.h\n  src/k2/c_xmlproc_if.cpp\n  src/k2/c_xmlproc_image.cpp\n  src/k2/c_xmlproc_include.cpp\n  src/k2/c_xmlproc_instance.cpp\n  src/k2/c_xmlproc_interface.cpp\n  src/k2/c_xmlproc_interface.h\n  src/k2/c_xmlproc_interfaceset.cpp\n  src/k2/c_xmlproc_interfaceset.h\n  src/k2/c_xmlproc_label.cpp\n  src/k2/c_xmlproc_label.h\n  src/k2/c_xmlproc_listbox.cpp\n  src/k2/c_xmlproc_listbox.h\n  src/k2/c_xmlproc_listitem.cpp\n  src/k2/c_xmlproc_listitem.h\n  src/k2/c_xmlproc_material.cpp\n  src/k2/c_xmlproc_materiallist.cpp\n  src/k2/c_xmlproc_menu.cpp\n  src/k2/c_xmlproc_menu.h\n  src/k2/c_xmlproc_minimap.cpp\n  src/k2/c_xmlproc_minimap.h\n  src/k2/c_xmlproc_model.cpp\n  src/k2/c_xmlproc_modelpanel.cpp\n  src/k2/c_xmlproc_modelpanel.h\n  src/k2/c_xmlproc_panel.cpp\n  src/k2/c_xmlproc_panel.h\n  src/k2/c_xmlproc_piegraph.cpp\n  src/k2/c_xmlproc_piegraph.h\n  src/k2/c_xmlproc_posteffect.cpp\n  src/k2/c_xmlproc_resourcelist.cpp\n  src/k2/c_xmlproc_resourcelist.h\n  src/k2/c_xmlproc_scrollbar.cpp\n  src/k2/c_xmlproc_scrollbar.h\n  src/k2/c_xmlproc_slider.cpp\n  src/k2/c_xmlproc_slider.h\n  src/k2/c_xmlproc_snaptarget.cpp\n  src/k2/c_xmlproc_snaptarget.h\n  src/k2/c_xmlproc_style.cpp\n  src/k2/c_xmlproc_swatch.cpp\n  src/k2/c_xmlproc_swatch.h\n  src/k2/c_xmlproc_table.cpp\n  src/k2/c_xmlproc_table.h\n  src/k2/c_xmlproc_template.cpp\n  src/k2/c_xmlproc_template.h\n  src/k2/c_xmlproc_textbox.cpp\n  src/k2/c_xmlproc_textbox.h\n  src/k2/c_xmlproc_textbuffer.cpp\n  src/k2/c_xmlproc_textbuffer.h\n  src/k2/c_xmlproc_texturelist.cpp\n  src/k2/c_xmlproc_trigger.cpp\n  src/k2/c_xmlproc_webimage.cpp\n  src/k2/c_xmlproc_webpanel.cpp\n  src/k2/c_xmlproc_webpanel.h\n  src/k2/c_xmlproc_widgetstate.cpp\n  src/k2/c_xmlproc_widgetstate.h\n  src/k2/c_xmlproc_world.cpp\n  src/k2/c_xmlproc_worldentitylist.cpp\n  src/k2/c_xmlproc_worldlightlist.cpp\n  src/k2/c_xmlproc_worldoccluderlist.cpp\n  src/k2/c_xmlproc_worldsoundlist.cpp\n  src/k2/c_xmlproc_worldtriggerlist.cpp\n  src/k2/c_xmlprocroot.cpp\n  src/k2/c_xmlprocroot.h\n  src/k2/c_zip.cpp\n  src/k2/c_zip.h\n  src/k2/c_zipfile.cpp\n  src/k2/c_zipfile.h\n  src/k2/client_api.h\n  # src/k2/dllmain.cpp\n  src/k2/evaluator.cpp\n  src/k2/evaluator.h\n  src/k2/host_commands.cpp\n  src/k2/i_baseinput.cpp\n  src/k2/i_baseinput.h\n  src/k2/i_dragwidget.cpp\n  src/k2/i_dragwidget.h\n  src/k2/i_effectcmd.cpp\n  src/k2/i_effectcmd.h\n  src/k2/i_effectinstance.cpp\n  src/k2/i_effectinstance.h\n  src/k2/i_emitter.cpp\n  src/k2/i_emitter.h\n  src/k2/i_entitycomponent.h\n  src/k2/i_inputwidget.h\n  src/k2/i_listwidget.cpp\n  src/k2/i_listwidget.h\n  src/k2/i_model.cpp\n  src/k2/i_model.h\n  src/k2/i_modelallocator.cpp\n  src/k2/i_modelallocator.h\n  src/k2/i_resource.cpp\n  src/k2/i_resource.h\n  src/k2/i_resourcelibrary.cpp\n  src/k2/i_resourcelibrary.h\n  src/k2/i_snapshot.cpp\n  src/k2/i_snapshot.h\n  src/k2/i_tag.cpp\n  src/k2/i_tag.h\n  src/k2/i_widget.cpp\n  src/k2/i_widget.h\n  src/k2/i_worldcomponent.cpp\n  src/k2/i_worldcomponent.h\n  src/k2/i_xmlproc_tag.h\n  src/k2/i_xmlproc_widget.h\n  src/k2/i_xmlprocessor.h\n  src/k2/inotify-syscalls.h\n  src/k2/inotify.h\n  src/k2/intersection.cpp\n  src/k2/intersection.h\n  src/k2/k2_api.h\n  src/k2/k2_common.cpp\n  src/k2/k2_common.h\n  src/k2/k2_constants.h\n  src/k2/k2_endian.h\n  src/k2/k2_mathlib.cpp\n  src/k2/k2_mathlib.h\n  src/k2/k2_protocol.h\n  src/k2/k2_randlib.cpp\n  src/k2/k2_randlib.h\n  src/k2/k2_secure_crt.h\n  src/k2/k2_singleton.h\n  src/k2/k2_stl.h\n  src/k2/k2_strings.h\n  src/k2/k2_types.h\n  src/k2/k2_unicode.h\n  src/k2/k2_utils.cpp\n  src/k2/k2_utils.h\n  src/k2/math_inlines.h\n  src/k2/md5.cpp\n  src/k2/md5.h\n  src/k2/md6.cpp\n  src/k2/md6.h\n  src/k2/MersenneTwister.cpp\n  src/k2/MersenneTwister.h\n  src/k2/parser.cpp\n  src/k2/parser.h\n  src/k2/s_foliagetile.h\n  src/k2/s_foliagevertex.h\n  src/k2/s_tile.h\n  src/k2/s_traceinfo.h\n  src/k2/s_x11info.h\n  src/k2/script_commands.cpp\n  src/k2/server_api.h\n  # src/k2/shared_api.cpp\n  src/k2/stringutils.cpp\n  src/k2/stringutils.h\n  src/k2/tchar_linux.h\n  src/k2/util_inlines.h\n  src/k2/xtoa.cpp\n  src/k2/xtoa.h\n\n  src/k2/MicroAllocator.cpp\n  src/k2/MicroAllocator.h\n\n  src/k2/MemoryTracker.h\n  src/k2/MemoryTrackerBinding.cpp\n  # src/k2/MemoryTrackerDLL.cpp\n\n  src/k2/srp.h\n  src/k2/srp.cpp\n  src/k2/c_srp.h\n  src/k2/c_srp.cpp\n  )\n\nif(WIN32)\n  list(APPEND K2_SOURCES\n    src/k2/MemoryTrackerDLL.cpp\n    src/k2/c_system_win32.cpp\n    src/k2/c_netdriver_win32.cpp\n    )\nelse()\n  list(APPEND K2_SOURCES\n    src/k2/c_system_posix.cpp\n    src/k2/c_netdriver_linux.cpp\n    )\n  if(APPLE)\n    list(APPEND K2_SOURCES src/k2/c_system_osx.mm)\n  elseif(LINUX)\n    list(APPEND K2_SOURCES src/k2/c_system_linux.cpp)\n  endif()\nendif()\n\nadd_library(${K2_LIBRARY} SHARED ${K2_SOURCES})\napp_configure_lib(${K2_LIBRARY})\ntarget_compile_definitions(${K2_LIBRARY} PRIVATE K2_EXPORTS)\ntarget_compile_definitions(${K2_LIBRARY} PUBLIC ${K2_PUBLIC_DEFINITIONS})\ntarget_precompile_headers(${K2_LIBRARY} PRIVATE src/k2/k2_common.h)\ntarget_link_libraries(${K2_LIBRARY} ${K2_LIBRARIES})\ntarget_include_directories(${K2_LIBRARY} PRIVATE ${K2_INCLUDE_DIRS})\ntarget_include_directories(${K2_LIBRARY} PUBLIC ${K2_INCLUDE_DIRS_PUBLIC})\n# copy the fmod DLL to each content directory, along with the build directory.\ntarget_copy(${K2_LIBRARY} \"${FMOD_DLL_PATH}\" \"${BIN_DIR}\")\nforeach(game ${NOH_GAMES})\n  target_copy(${K2_LIBRARY} \"${FMOD_DLL_PATH}\" \"${${game}_CONTENT_DIR}\")\nendforeach()\n\n#========================================\n# vid_gl2_c\n#========================================\nset(VID_GL2_C_SOURCES\n  src/vid_gl2/SOIL/SOIL.c\n  src/vid_gl2/SOIL/image_DXT.c\n  src/vid_gl2/SOIL/image_helper.c\n  src/vid_gl2/SOIL/stb_image_aug.c\n  )\nadd_library(vid_gl2_c STATIC ${VID_GL2_C_SOURCES})\nlist(APPEND VID_GL2_LIBRARIES vid_gl2_c)\n\n#========================================\n# vid_gl2\n#========================================\nset(VID_GL2_LIBRARY vid_gl2)\nset(VID_GL2_LIBRARY_LIB \"${VID_GL2_LIBRARY}\")\nset(VID_GL2_LIBRARY_DLL \"${BIN_DIR}/${VID_GL2_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(VID_GL2_LIBRARY_LIB \"${LIB_DIR}/${VID_GL2_LIBRARY}${LIB_EXT}\")\nendif()\n\n# vid_gl2 definitions\nlist(APPEND VID_GL2_LIBRARY_DEFINITIONS\n  GLEW_STATIC\n  GL_SILENCE_DEPRECATION\n  )\n\n# vid_gl2 dependencies\nlist(APPEND VID_GL2_LIBRARY_DEPENDENCIES\n  ${K2_LIBRARY}\n  )\n\n# vid_gl2 libraries\nlist(APPEND VID_GL2_LIBRARIES\n  \"${K2_LIBRARY}\"\n  ${OPENGL_LIBRARIES}\n  )\n\n# vid_gl2 sources\nlist(APPEND VID_GL2_SOURCES\n  src/vid_gl2/GLEW/glew.cpp\n  src/vid_gl2/GLEW/glew.h\n  src/vid_gl2/GLEW/glxew.h\n  src/vid_gl2/GLEW/wglew.h\n  #  src/vid_gl2/SOIL/SOIL.c\n  src/vid_gl2/SOIL/SOIL.h\n  #  src/vid_gl2/SOIL/image_DXT.c\n  src/vid_gl2/SOIL/image_DXT.h\n  #  src/vid_gl2/SOIL/image_helper.c\n  src/vid_gl2/SOIL/image_helper.h\n  #  src/vid_gl2/SOIL/stb_image_aug.c\n  src/vid_gl2/SOIL/stb_image_aug.h\n  src/vid_gl2/SOIL/stbi_DDS_aug.h\n  src/vid_gl2/SOIL/stbi_DDS_aug_c.h\n  src/vid_gl2/c_billboardrenderer.cpp\n  src/vid_gl2/c_billboardrenderer.h\n  src/vid_gl2/c_bonelist.h\n  src/vid_gl2/c_boxrenderer.cpp\n  src/vid_gl2/c_boxrenderer.h\n  src/vid_gl2/c_effecttrianglerenderer.cpp\n  src/vid_gl2/c_effecttrianglerenderer.h\n  src/vid_gl2/c_fogofwar.cpp\n  src/vid_gl2/c_fogofwar.h\n  src/vid_gl2/c_foliagerenderer.cpp\n  src/vid_gl2/c_foliagerenderer.h\n  src/vid_gl2/c_gfx2d.cpp\n  src/vid_gl2/c_gfx2d.h\n  src/vid_gl2/c_gfx3d.cpp\n  src/vid_gl2/c_gfx3d.h\n  src/vid_gl2/c_gfxinit.cpp\n  src/vid_gl2/c_gfxinit.h\n  src/vid_gl2/c_gfxmaterials.cpp\n  src/vid_gl2/c_gfxmaterials.h\n  src/vid_gl2/c_gfxmodels.cpp\n  src/vid_gl2/c_gfxmodels.h\n  src/vid_gl2/c_gfxshaders.cpp\n  src/vid_gl2/c_gfxshaders.h\n  src/vid_gl2/c_gfxterrain.cpp\n  src/vid_gl2/c_gfxterrain.h\n  src/vid_gl2/c_gfxtextures.cpp\n  src/vid_gl2/c_gfxtextures.h\n  src/vid_gl2/c_gfxutils.cpp\n  src/vid_gl2/c_gfxutils.h\n  src/vid_gl2/c_glslpreprocessor.cpp\n  src/vid_gl2/c_glslpreprocessor.h\n  src/vid_gl2/c_linerenderer.cpp\n  src/vid_gl2/c_linerenderer.h\n  src/vid_gl2/c_meshrenderer.cpp\n  src/vid_gl2/c_meshrenderer.h\n  src/vid_gl2/c_pointrenderer.cpp\n  src/vid_gl2/c_pointrenderer.h\n  src/vid_gl2/c_postbuffer.cpp\n  src/vid_gl2/c_postbuffer.h\n  src/vid_gl2/c_procedural.cpp\n  src/vid_gl2/c_procedural.h\n  src/vid_gl2/c_proceduralregistry.cpp\n  src/vid_gl2/c_proceduralregistry.h\n  src/vid_gl2/c_renderlist.cpp\n  src/vid_gl2/c_renderlist.h\n  src/vid_gl2/c_scenebuffer.cpp\n  src/vid_gl2/c_scenebuffer.h\n  src/vid_gl2/c_scenepolyrenderer.cpp\n  src/vid_gl2/c_scenepolyrenderer.h\n  src/vid_gl2/c_shaderpreprocessor.cpp\n  src/vid_gl2/c_shaderpreprocessor.h\n  src/vid_gl2/c_shaderregistry.cpp\n  src/vid_gl2/c_shaderregistry.h\n  src/vid_gl2/c_shadersampler.cpp\n  src/vid_gl2/c_shadersampler.h\n  src/vid_gl2/c_shadersamplerregistry.cpp\n  src/vid_gl2/c_shadersamplerregistry.h\n  src/vid_gl2/c_shadervar.cpp\n  src/vid_gl2/c_shadervar.h\n  src/vid_gl2/c_shadervarregistry.cpp\n  src/vid_gl2/c_shadervarregistry.h\n  src/vid_gl2/c_shadowmap.cpp\n  src/vid_gl2/c_shadowmap.h\n  src/vid_gl2/c_skyrenderer.cpp\n  src/vid_gl2/c_skyrenderer.h\n  src/vid_gl2/c_terrainrenderer.cpp\n  src/vid_gl2/c_terrainrenderer.h\n  src/vid_gl2/c_texturearchive.cpp\n  src/vid_gl2/c_texturearchive.h\n  src/vid_gl2/c_texturecache.cpp\n  src/vid_gl2/c_texturecache.h\n  src/vid_gl2/c_treebillboardrenderer.cpp\n  src/vid_gl2/c_treebillboardrenderer.h\n  src/vid_gl2/c_treebranchrenderer.cpp\n  src/vid_gl2/c_treebranchrenderer.h\n  src/vid_gl2/c_treefrondrenderer.cpp\n  src/vid_gl2/c_treefrondrenderer.h\n  src/vid_gl2/c_treeleafrenderer.cpp\n  src/vid_gl2/c_treeleafrenderer.h\n  src/vid_gl2/c_treemodeldef.cpp\n  src/vid_gl2/c_treemodeldef.h\n  src/vid_gl2/c_treescenemanager.cpp\n  src/vid_gl2/c_treescenemanager.h\n  src/vid_gl2/d3dx_shared.cpp\n  src/vid_gl2/d3dx_shared.h\n  #  src/vid_gl2/gl2_common.h\n  src/vid_gl2/gl2_foliage.cpp\n  src/vid_gl2/gl2_foliage.h\n  src/vid_gl2/gl2_main.cpp\n  src/vid_gl2/gl2_os.h\n  #  src/vid_gl2/gl2_osx.mm\n  #  src/vid_gl2/gl2_linux.cpp\n  src/vid_gl2/gl2_procedurals.cpp\n  src/vid_gl2/gl2_shadersamplers.cpp\n  src/vid_gl2/gl2_shadervars.cpp\n  #  src/vid_gl2/gl2_win32.cpp\n  src/vid_gl2/i_debugrenderer.cpp\n  src/vid_gl2/i_debugrenderer.h\n  src/vid_gl2/i_effectrenderer.cpp\n  src/vid_gl2/i_effectrenderer.h\n  src/vid_gl2/i_renderer.cpp\n  src/vid_gl2/i_renderer.h\n  #  src/vid_gl2/libXNVCtrl/NVCtrl.c\n  #  src/vid_gl2/libXNVCtrl/NVCtrl.h\n  #  src/vid_gl2/libXNVCtrl/NVCtrlLib.h\n  #  src/vid_gl2/libXNVCtrl/nv_control.h\n  #  src/vid_gl2/ogl_mac.cpp\n  src/vid_gl2/vid_common.cpp\n  #  src/vid_gl2/vid_common.h\n  )\nif(WIN32)\n  list(APPEND VID_GL2_SOURCES src/vid_gl2/gl2_win32.cpp)\nelseif(LINUX)\n  list(APPEND VID_GL2_SOURCES src/vid_gl2/gl2_linux.cpp)\nelseif(APPLE)\n  list(APPEND VID_GL2_SOURCES src/vid_gl2/gl2_osx.mm)\nendif()\n\nadd_library(${VID_GL2_LIBRARY} MODULE ${VID_GL2_SOURCES})\napp_configure_lib(${VID_GL2_LIBRARY})\ntarget_precompile_headers(${VID_GL2_LIBRARY} PRIVATE src/vid_gl2/vid_common.h)\ntarget_compile_definitions(${VID_GL2_LIBRARY} PRIVATE ${VID_GL2_LIBRARY_DEFINITIONS})\ntarget_link_libraries(${VID_GL2_LIBRARY} ${VID_GL2_LIBRARIES})\nadd_dependencies(${VID_GL2_LIBRARY} ${VID_GL2_LIBRARY_DEPENDENCIES})\n\n#========================================\n# hon_shared\n#========================================\nset(HON_SHARED_LIBRARY hon_shared)\nset(HON_SHARED_LIBRARY_LIB \"${HON_SHARED_LIBRARY}\")\nset(HON_SHARED_LIBRARY_DLL \"${BIN_DIR}/${HON_SHARED_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(HON_SHARED_LIBRARY_LIB \"${LIB_DIR}/${HON_SHARED_LIBRARY}${LIB_EXT}\")\nendif()\n\nset(HON_SHARED_SOURCES\n  src/hon_shared/c_abilityattributedefinition.h\n  src/hon_shared/c_abilitydefinition.h\n  src/hon_shared/c_affectordefinition.h\n  src/hon_shared/c_asAttacking.cpp\n  src/hon_shared/c_asAttacking.h\n  src/hon_shared/c_ascasting.cpp\n  src/hon_shared/c_asCasting.h\n  src/hon_shared/c_asMoving.cpp\n  src/hon_shared/c_asMoving.h\n  src/hon_shared/c_auradefinition.cpp\n  src/hon_shared/c_auradefinition.h\n  src/hon_shared/c_bability.cpp\n  src/hon_shared/c_bability.h\n  src/hon_shared/c_baggressivewander.cpp\n  src/hon_shared/c_baggressivewander.h\n  src/hon_shared/c_baggro.cpp\n  src/hon_shared/c_baggro.h\n  src/hon_shared/c_bassist.cpp\n  src/hon_shared/c_bassist.h\n  src/hon_shared/c_battack.cpp\n  src/hon_shared/c_battack.h\n  src/hon_shared/c_battackfollow.cpp\n  src/hon_shared/c_battackfollow.h\n  src/hon_shared/c_battackmove.cpp\n  src/hon_shared/c_battackmove.h\n  src/hon_shared/c_bdoubleactivateability.cpp\n  src/hon_shared/c_bdoubleactivateability.h\n  src/hon_shared/c_bdropitem.cpp\n  src/hon_shared/c_bdropitem.h\n  src/hon_shared/c_bevent.cpp\n  src/hon_shared/c_bevent.h\n  src/hon_shared/c_bfollow.cpp\n  src/hon_shared/c_bfollow.h\n  src/hon_shared/c_bfollowguard.cpp\n  src/hon_shared/c_bfollowguard.h\n  src/hon_shared/c_bgiveitem.cpp\n  src/hon_shared/c_bgiveitem.h\n  src/hon_shared/c_bguard.cpp\n  src/hon_shared/c_bguard.h\n  src/hon_shared/c_bguardfollow.cpp\n  src/hon_shared/c_bguardfollow.h\n  src/hon_shared/c_bhold.cpp\n  src/hon_shared/c_bhold.h\n  src/hon_shared/c_bmove.cpp\n  src/hon_shared/c_bmove.h\n  src/hon_shared/c_brain.cpp\n  src/hon_shared/c_brain.h\n  src/hon_shared/c_bsentry.cpp\n  src/hon_shared/c_bsentry.h\n  src/hon_shared/c_bstop.cpp\n  src/hon_shared/c_bstop.h\n  src/hon_shared/c_btouch.cpp\n  src/hon_shared/c_btouch.h\n  src/hon_shared/c_buildingdefinition.h\n  src/hon_shared/c_bwander.cpp\n  src/hon_shared/c_bwander.h\n  src/hon_shared/c_combatevent.cpp\n  src/hon_shared/c_combatevent.h\n  src/hon_shared/c_creepdefinition.h\n  src/hon_shared/c_critterdefinition.h\n  src/hon_shared/c_damageevent.cpp\n  src/hon_shared/c_damageevent.h\n  src/hon_shared/c_entitycamera.cpp\n  src/hon_shared/c_entitycamera.h\n  src/hon_shared/c_entitychest.cpp\n  src/hon_shared/c_entitychest.h\n  src/hon_shared/c_entitycreepspawner.cpp\n  src/hon_shared/c_entitycreepspawner.h\n  src/hon_shared/c_entitycritterspawner.cpp\n  src/hon_shared/c_entitycritterspawner.h\n  src/hon_shared/c_entitydefinitionresource.cpp\n  src/hon_shared/c_entitydefinitionresource.h\n  src/hon_shared/c_entityeffect.cpp\n  src/hon_shared/c_entityeffect.h\n  src/hon_shared/c_entityevent.h\n  src/hon_shared/c_entitykongorcontroller.cpp\n  src/hon_shared/c_entitykongorcontroller.h\n  src/hon_shared/c_entitykongorspawner.cpp\n  src/hon_shared/c_entitykongorspawner.h\n  src/hon_shared/c_entitylanenode.cpp\n  src/hon_shared/c_entitylanenode.h\n  src/hon_shared/c_entityneutralcampcontroller.cpp\n  src/hon_shared/c_entityneutralcampcontroller.h\n  src/hon_shared/c_entityneutralcampspawner.cpp\n  src/hon_shared/c_entityneutralcampspawner.h\n  #  src/hon_shared/c_entitynpccontroller.cpp\n  #  src/hon_shared/c_entitynpccontroller.h\n  src/hon_shared/c_entitypowerupspawner.cpp\n  src/hon_shared/c_entitypowerupspawner.h\n  src/hon_shared/c_entityregistry.cpp\n  src/hon_shared/c_entityregistry.h\n  src/hon_shared/c_entitystate.h\n  src/hon_shared/c_eventdirectory.cpp\n  src/hon_shared/c_eventdirectory.h\n  src/hon_shared/c_gadgetdefinition.h\n  src/hon_shared/c_gamedefinition.h\n  src/hon_shared/c_gameevent.cpp\n  src/hon_shared/c_gameevent.h\n  src/hon_shared/c_gameinfo.cpp\n  src/hon_shared/c_gameinfo.h\n  src/hon_shared/c_gamelogparser.cpp\n  src/hon_shared/c_gamelogparser.h\n  src/hon_shared/c_gamemechanics.cpp\n  src/hon_shared/c_gamemechanics.h\n  src/hon_shared/c_gamemechanicsresource.cpp\n  src/hon_shared/c_gamemechanicsresource.h\n  src/hon_shared/c_gamestats.cpp\n  src/hon_shared/c_gamestats.h\n  src/hon_shared/c_herodefinition.h\n  src/hon_shared/c_itemdefinition.h\n  src/hon_shared/c_lane.cpp\n  src/hon_shared/c_lane.h\n  src/hon_shared/c_lightstatic.cpp\n  src/hon_shared/c_lightstatic.h\n  src/hon_shared/c_linearaffector.cpp\n  src/hon_shared/c_linearaffector.h\n  src/hon_shared/c_linearaffectordefinition.h\n  src/hon_shared/c_neutraldefinition.h\n  src/hon_shared/c_orderdefinition.h\n  #  src/hon_shared/c_petdefinition.cpp\n  #  src/hon_shared/c_petdefinition.h\n  src/hon_shared/c_player.cpp\n  src/hon_shared/c_player.h\n  src/hon_shared/c_playeraccountstats.cpp\n  src/hon_shared/c_playeraccountstats.h\n  src/hon_shared/c_powerupdefinition.h\n  src/hon_shared/c_projectiledefinition.h\n  src/hon_shared/c_propdynamic.cpp\n  src/hon_shared/c_propdynamic.h\n  src/hon_shared/c_propscenery.cpp\n  src/hon_shared/c_propscenery.h\n  src/hon_shared/c_proptree.cpp\n  src/hon_shared/c_proptree.h\n  #  src/hon_shared/c_propwater.cpp\n  #  src/hon_shared/c_propwater.h\n  src/hon_shared/c_replayinfo.cpp\n  src/hon_shared/c_replayinfo.h\n  src/hon_shared/c_replaymanager.cpp\n  src/hon_shared/c_replaymanager.h\n  src/hon_shared/c_scriptdirectory.cpp\n  src/hon_shared/c_scriptdirectory.h\n  src/hon_shared/c_scriptthread.cpp\n  src/hon_shared/c_scriptthread.h\n  #  src/hon_shared/c_serverinfo.cpp\n  #  src/hon_shared/c_serverinfo.h\n  src/hon_shared/c_shopdefinition.h\n  src/hon_shared/c_shopinfo.cpp\n  src/hon_shared/c_shopinfo.h\n  src/hon_shared/c_shopiteminfo.cpp\n  src/hon_shared/c_shopiteminfo.h\n  src/hon_shared/c_statedefinition.h\n  src/hon_shared/c_statenetaccumdefinition.h\n  src/hon_shared/c_teaminfo.cpp\n  src/hon_shared/c_teaminfo.h\n  src/hon_shared/c_triggermarker.cpp\n  src/hon_shared/c_triggermarker.h\n  src/hon_shared/c_triggerspawnpoint.cpp\n  src/hon_shared/c_triggerspawnpoint.h\n  src/hon_shared/c_visibilitymap.cpp\n  src/hon_shared/c_visibilitymap.h\n  src/hon_shared/c_xmlproc_ability.cpp\n  src/hon_shared/c_xmlproc_affector.cpp\n  src/hon_shared/c_xmlproc_building.cpp\n  src/hon_shared/c_xmlproc_combatactions.cpp\n  src/hon_shared/c_xmlproc_creep.cpp\n  src/hon_shared/c_xmlproc_critter.cpp\n  src/hon_shared/c_xmlproc_gadget.cpp\n  src/hon_shared/c_xmlproc_game.cpp\n  src/hon_shared/c_xmlproc_hero.cpp\n  src/hon_shared/c_xmlproc_item.cpp\n  #  src/hon_shared/c_xmlproc_itemdef.cpp\n  src/hon_shared/c_xmlproc_linearaffector.cpp\n  src/hon_shared/c_xmlproc_neutral.cpp\n  src/hon_shared/c_xmlproc_order.cpp\n  src/hon_shared/c_xmlproc_pet.cpp\n  src/hon_shared/c_xmlproc_powerup.cpp\n  src/hon_shared/c_xmlproc_projectile.cpp\n  src/hon_shared/c_xmlproc_shop.cpp\n  src/hon_shared/c_xmlproc_state.cpp\n  src/hon_shared/combat_actions.h\n  src/hon_shared/game_shared_api.h\n  src/hon_shared/game_shared_common.cpp\n  src/hon_shared/game_shared_common.h\n  src/hon_shared/game_shared_constants.h\n  src/hon_shared/game_shared_cvars.cpp\n  src/hon_shared/game_shared_cvars.h\n  src/hon_shared/game_shared_entities.cpp\n  src/hon_shared/game_shared_entities.h\n  src/hon_shared/game_shared_protocol.h\n  src/hon_shared/game_shared_states.h\n  src/hon_shared/game_shared_types.h\n  src/hon_shared/i_areaaffector.cpp\n  src/hon_shared/i_areaaffector.h\n  src/hon_shared/i_ActionState.h\n  src/hon_shared/i_baseentityallocator.h\n  src/hon_shared/i_behavior.cpp\n  src/hon_shared/i_behavior.h\n  src/hon_shared/i_bitentity.cpp\n  src/hon_shared/i_bitentity.h\n  src/hon_shared/i_buildingentity.cpp\n  src/hon_shared/i_buildingentity.h\n  src/hon_shared/i_combataction.cpp\n  src/hon_shared/i_combataction.h\n  src/hon_shared/i_creepentity.cpp\n  src/hon_shared/i_creepentity.h\n  src/hon_shared/i_critterentity.cpp\n  src/hon_shared/i_critterentity.h\n  src/hon_shared/i_entityability.cpp\n  src/hon_shared/i_entityability.h\n  src/hon_shared/i_entityabilityattribute.cpp\n  src/hon_shared/i_entityabilityattribute.h\n  src/hon_shared/i_entitydefinition.cpp\n  src/hon_shared/i_entitydefinition.h\n  src/hon_shared/i_entitydirectory.cpp\n  src/hon_shared/i_entitydirectory.h\n  src/hon_shared/i_entityitem.cpp\n  src/hon_shared/i_entityitem.h\n  src/hon_shared/i_entitystate.cpp\n  src/hon_shared/i_entitystate.h\n  src/hon_shared/i_entitystatenetaccum.cpp\n  src/hon_shared/i_entitystatenetaccum.h\n  src/hon_shared/i_entitytool.cpp\n  src/hon_shared/i_entitytool.h\n  src/hon_shared/i_gadgetentity.cpp\n  src/hon_shared/i_gadgetentity.h\n  src/hon_shared/i_game.cpp\n  src/hon_shared/i_game.h\n  src/hon_shared/i_gameentity.cpp\n  src/hon_shared/i_gameentity.h\n  src/hon_shared/i_heroentity.cpp\n  src/hon_shared/i_heroentity.h\n  src/hon_shared/i_light.cpp\n  src/hon_shared/i_light.h\n  src/hon_shared/i_neutralentity.cpp\n  src/hon_shared/i_neutralentity.h\n  src/hon_shared/i_orderentity.cpp\n  src/hon_shared/i_orderentity.h\n  src/hon_shared/i_petentity.cpp\n  src/hon_shared/i_petentity.h\n  src/hon_shared/i_powerupentity.cpp\n  src/hon_shared/i_powerupentity.h\n  src/hon_shared/i_projectile.cpp\n  src/hon_shared/i_projectile.h\n  src/hon_shared/i_propentity.cpp\n  src/hon_shared/i_propentity.h\n  src/hon_shared/i_shopentity.cpp\n  src/hon_shared/i_shopentity.h\n  src/hon_shared/i_slavedefinition.cpp\n  src/hon_shared/i_slavedefinition.h\n  src/hon_shared/i_slaveentity.cpp\n  src/hon_shared/i_slaveentity.h\n  #  src/hon_shared/i_temporalstate.cpp\n  #  src/hon_shared/i_temporalstate.h\n  src/hon_shared/i_tooldefinition.cpp\n  src/hon_shared/i_tooldefinition.h\n  src/hon_shared/i_unitdefinition.cpp\n  src/hon_shared/i_unitdefinition.h\n  src/hon_shared/i_unitentity.cpp\n  src/hon_shared/i_unitentity.h\n  src/hon_shared/i_visualentity.cpp\n  src/hon_shared/i_visualentity.h\n  src/hon_shared/i_waypoint.cpp\n  src/hon_shared/i_waypoint.h\n  )\n\nadd_library(${HON_SHARED_LIBRARY} SHARED ${HON_SHARED_SOURCES})\napp_configure_lib(${HON_SHARED_LIBRARY})\ntarget_compile_definitions(${HON_SHARED_LIBRARY} PRIVATE GAME_SHARED_EXPORTS)\ntarget_compile_definitions(${HON_SHARED_LIBRARY} PUBLIC ${HON_SHARED_PUBLIC_DEFINITIONS})\ntarget_precompile_headers(${HON_SHARED_LIBRARY} PRIVATE src/hon_shared/game_shared_common.h)\ntarget_link_libraries(${HON_SHARED_LIBRARY}\n  ${HON_SHARED_LIBRARIES}\n  \"${K2_LIBRARY}\"\n  )\n\n#========================================\n# hon_client\n#========================================\nset(HON_CLIENT_LIBRARY hon_client)\nset(HON_CLIENT_LIBRARY_LIB \"${HON_CLIENT_LIBRARY}\")\nset(HON_CLIENT_LIBRARY_DLL \"${BIN_DIR}/${HON_CLIENT_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(HON_CLIENT_LIBRARY_LIB \"${LIB_DIR}/${HON_CLIENT_LIBRARY}${LIB_EXT}\")\nendif()\n\n# hon_client sources\nset(HON_CLIENT_SOURCES\n  src/hon_client/c_clientcommander.cpp\n  src/hon_client/c_clientcommander.h\n  src/hon_client/c_cliententity.cpp\n  src/hon_client/c_cliententity.h\n  src/hon_client/c_cliententitydirectory.cpp\n  src/hon_client/c_cliententitydirectory.h\n  src/hon_client/c_gameclient.cpp\n  src/hon_client/c_gameclient.h\n  src/hon_client/c_gameinterfacemanager.cpp\n  src/hon_client/c_gameinterfacemanager.h\n  src/hon_client/game_client_actions.cpp\n  src/hon_client/game_client_commands.cpp\n  src/hon_client/game_client_common.cpp\n  src/hon_client/game_client_common.h\n  src/hon_client/game_client_main.cpp\n  )\n\nadd_library(${HON_CLIENT_LIBRARY} MODULE ${HON_CLIENT_SOURCES})\napp_configure_lib(${HON_CLIENT_LIBRARY})\ntarget_compile_definitions(${HON_CLIENT_LIBRARY} PRIVATE GAME_CLIENT_EXPORTS)\ntarget_precompile_headers(${HON_CLIENT_LIBRARY} PRIVATE src/hon_client/game_client_common.h)\ntarget_link_libraries(${HON_CLIENT_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n#========================================\n# hon_server\n#========================================\nset(HON_SERVER_LIBRARY hon_server)\nset(HON_SERVER_LIBRARY_LIB \"${HON_SERVER_LIBRARY}\")\nset(HON_SERVER_LIBRARY_DLL \"${BIN_DIR}/${HON_SERVER_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(HON_SERVER_LIBRARY_LIB \"${LIB_DIR}/${HON_SERVER_LIBRARY}${LIB_EXT}\")\nendif()\n\n# hon_server sources\nset(HON_SERVER_SOURCES\n  #  src/hon_server/c_game_server_commands.cpp\n  src/hon_server/c_gamelog.cpp\n  src/hon_server/c_gamelog.h\n  src/hon_server/c_gamelogevent.h\n  src/hon_server/c_gameserver.cpp\n  src/hon_server/c_gameserver.h\n  #  src/hon_server/c_serverentity.cpp\n  #  src/hon_server/c_serverentity.h\n  src/hon_server/c_serverentitydirectory.cpp\n  src/hon_server/c_serverentitydirectory.h\n  #  src/hon_server/c_serverstatstracker.cpp\n  #  src/hon_server/c_serverstatstracker.h\n  #  src/hon_server/c_svent_player.cpp\n  #  src/hon_server/c_svent_player.h\n  src/hon_server/c_triggermanager.cpp\n  src/hon_server/c_triggermanager.h\n  src/hon_server/game_server_commands.cpp\n  src/hon_server/game_server_common.cpp\n  src/hon_server/game_server_common.h\n  src/hon_server/game_server_main.cpp\n  )\n\nadd_library(${HON_SERVER_LIBRARY} MODULE ${HON_SERVER_SOURCES})\napp_configure_lib(${HON_SERVER_LIBRARY})\ntarget_compile_definitions(${HON_SERVER_LIBRARY} PRIVATE GAME_SERVER_EXPORTS)\ntarget_precompile_headers(${HON_SERVER_LIBRARY} PRIVATE src/hon_server/game_server_common.h)\ntarget_link_libraries(${HON_SERVER_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n#========================================\n# modelviewer\n#========================================\nset(MODELVIEWER_LIBRARY modelviewer_client)\nset(MODELVIEWER_LIBRARY_LIB \"${MODELVIEWER_LIBRARY}\")\nset(MODELVIEWER_LIBRARY_DLL \"${BIN_DIR}/${MODELVIEWER_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(MODELVIEWER_LIBRARY_LIB \"${LIB_DIR}/${MODELVIEWER_LIBRARY}${LIB_EXT}\")\nendif()\nset(MODELVIEWER_GAME_NAME \"K2\")\n\n# modelviewer sources\nset(MODELVIEWER_SOURCES\n  src/modelviewer/mv_main.cpp\n  src/modelviewer/mv_common.cpp\n  src/modelviewer/mv_common.h\n  src/modelviewer/mv.h\n  )\n\nadd_library(${MODELVIEWER_LIBRARY} MODULE ${MODELVIEWER_SOURCES})\napp_configure_lib(${MODELVIEWER_LIBRARY})\ntarget_compile_definitions(${MODELVIEWER_LIBRARY} PRIVATE MODELVIEWER_EXPORTS)\ntarget_precompile_headers(${MODELVIEWER_LIBRARY} PRIVATE src/modelviewer/mv_common.h)\ntarget_link_libraries(${MODELVIEWER_LIBRARY}\n  \"${K2_LIBRARY}\"\n  )\n\n#========================================\n# editor\n#========================================\nset(EDITOR_LIBRARY editor_client)\nset(EDITOR_LIBRARY_LIB \"${EDITOR_LIBRARY}\")\nset(EDITOR_LIBRARY_DLL \"${BIN_DIR}/${EDITOR_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(EDITOR_LIBRARY_LIB \"${LIB_DIR}/${EDITOR_LIBRARY}${LIB_EXT}\")\nendif()\n\n# editor sources\nset(EDITOR_SOURCES\n  src/editor/c_blockertool.cpp\n  src/editor/c_clifftool.cpp\n  src/editor/c_deformtool.cpp\n  src/editor/c_editor.cpp\n  src/editor/c_entitytool.cpp\n  src/editor/c_foliagetool.cpp\n  src/editor/c_lightmaptool.cpp\n  src/editor/c_lighttool.cpp\n  src/editor/c_occludertool.cpp\n  src/editor/c_painttool.cpp\n  src/editor/c_soundtool.cpp\n  #  src/editor/c_spawntool.cpp\n  #  src/editor/c_stamptool.cpp\n  src/editor/c_toolbox.cpp\n  src/editor/c_treedefinitionresource.cpp\n  #  src/editor/c_treetool.cpp\n  src/editor/c_watertool.cpp\n  src/editor/c_xmlproc_brushlistitems.cpp\n  src/editor/c_xmlproc_cliff.cpp\n  src/editor/c_xmlproc_skylistitems.cpp\n  src/editor/c_xmlproc_toollistitems.cpp\n  src/editor/c_xmlproc_tree.cpp\n  src/editor/editor_common.cpp\n  src/editor/editor_main.cpp\n  )\n\nadd_library(${EDITOR_LIBRARY} MODULE ${EDITOR_SOURCES})\napp_configure_lib(${EDITOR_LIBRARY})\napp_configure_game_settings(${EDITOR_LIBRARY} \"${HON_GAME_NAME}\" \"Editor\")\ntarget_compile_definitions(${EDITOR_LIBRARY} PRIVATE EDITOR_EXPORTS)\ntarget_precompile_headers(${EDITOR_LIBRARY} PRIVATE src/editor/editor_common.h)\ntarget_link_libraries(${EDITOR_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n\n#========================================\n# bet_client\n#========================================\nset(BET_CLIENT_LIBRARY bet_client)\nset(BET_CLIENT_LIBRARY_LIB \"${BET_CLIENT_LIBRARY}\")\nset(BET_CLIENT_LIBRARY_DLL \"${BIN_DIR}/${BET_CLIENT_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(BET_CLIENT_LIBRARY_LIB \"${LIB_DIR}/${BET_CLIENT_LIBRARY}${LIB_EXT}\")\nendif()\n\n# bet_client sources\nset(BET_CLIENT_SOURCES\n  #  src/bet_client/c_clientcommander.cpp\n  #  src/bet_client/c_clientcommander.h\n  #  src/bet_client/c_cliententity.cpp\n  #  src/bet_client/c_cliententity.h\n  #  src/bet_client/c_cliententitydirectory.cpp\n  #  src/bet_client/c_cliententitydirectory.h\n  src/bet_client/c_gameclient.cpp\n  src/bet_client/c_gameclient.h\n  #  src/bet_client/c_gameinterfacemanager.cpp\n  #  src/bet_client/c_gameinterfacemanager.h\n  #  src/bet_client/game_client_actions.cpp\n  #  src/bet_client/game_client_commands.cpp\n  #  src/bet_client/game_client_common.cpp\n  #  src/bet_client/game_client_common.h\n  src/bet_client/game_client_main.cpp\n  src/bet_client/bet_client_common.cpp\n  src/bet_client/bet_client_common.h\n  )\n\nadd_library(${BET_CLIENT_LIBRARY} MODULE ${BET_CLIENT_SOURCES})\napp_configure_lib(${BET_CLIENT_LIBRARY})\ntarget_compile_definitions(${BET_CLIENT_LIBRARY} PRIVATE GAME_CLIENT_EXPORTS)\ntarget_precompile_headers(${BET_CLIENT_LIBRARY} PRIVATE src/bet_client/bet_client_common.h)\ntarget_link_libraries(${BET_CLIENT_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n#========================================\n# shell\n#========================================\nlist(APPEND SHELL_SOURCES\n  src/shell/shell_common.cpp\n  src/shell/misc_cmds.cpp\n  )\nif(APPLE)\n  list(APPEND SHELL_SOURCES src/shell/main_osx.mm)\nelseif(LINUX)\n  list(APPEND SHELL_SOURCES src/shell/main_linux.cpp)\nelseif(WIN32)\n  list(APPEND SHELL_SOURCES src/shell/main_win32.cpp)\nendif()\n\nadd_library(shell INTERFACE ${SHELL_SOURCES})\ntarget_include_directories(shell INTERFACE src/shell)\n#list(APPEND SHELL_MAIN $<TARGET_OBJECTS:shell>)\nlist(APPEND SHELL_MAIN ${SHELL_SOURCES})\n\n#========================================\n# K2_ModelViewer\n#========================================\nset(K2_MODELVIEWER_EXE K2_ModelViewer)\nset(K2_MODELVIEWER_MODS game editor modelviewer)\n\nlist(APPEND K2_MODELVIEWER_DEPENDENCIES\n  ${K2_LIBRARY}\n  ${VID_GL2_LIBRARY}\n  ${MODELVIEWER_LIBRARY}\n  )\nlist(APPEND K2_MODELVIEWER_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND K2_MODELVIEWER_LIBRARIES\n  ${K2_LIBRARY}\n  shell\n  )\n\nadd_executable(${K2_MODELVIEWER_EXE} ${EXE_TYPE} ${K2_MODELVIEWER_SOURCES})\nadd_dependencies(${K2_MODELVIEWER_EXE} ${K2_MODELVIEWER_DEPENDENCIES})\ntarget_link_libraries(${K2_MODELVIEWER_EXE} ${K2_MODELVIEWER_LIBRARIES})\ntarget_include_directories(${K2_MODELVIEWER_EXE} PRIVATE \"src/Heroes of Newerth_shell\")\ntarget_precompile_headers(${K2_MODELVIEWER_EXE} PRIVATE \"src/Heroes of Newerth_shell/shell_common.h\")\napp_configure_game_settings(${K2_MODELVIEWER_EXE} \"K2\" \"Model Viewer\")\napp_configure_exe(${K2_MODELVIEWER_EXE} \"K2 Model Viewer\" \"${HON_ICON}\" \"${HON_CONTENT_DIR}\" ${K2_MODELVIEWER_MODS})\n\n#========================================\n# NoH\n#========================================\nset(NOH_EXE NoH)\nset(NOH_MODS hon game)\n\nlist(APPEND NOH_DEPENDENCIES\n  ${K2_LIBRARY}\n  ${VID_GL2_LIBRARY}\n  ${HON_CLIENT_LIBRARY}\n  ${HON_SERVER_LIBRARY}\n  )\n\nlist(APPEND NOH_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND NOH_LIBRARIES\n  ${K2_LIBRARY}\n  shell\n  )\n\nadd_executable(${NOH_EXE} ${EXE_TYPE} ${NOH_SOURCES})\nadd_dependencies(${NOH_EXE} ${NOH_DEPENDENCIES})\ntarget_link_libraries(${NOH_EXE} ${NOH_LIBRARIES})\ntarget_include_directories(${NOH_EXE} PRIVATE \"src/Heroes of Newerth_shell\")\ntarget_precompile_headers(${NOH_EXE} PRIVATE \"src/Heroes of Newerth_shell/shell_common.h\")\napp_configure_game_settings(${NOH_EXE} \"${HON_GAME_NAME}\" \"\")\napp_configure_exe(${NOH_EXE} \"NoH\" \"${HON_ICON}\" \"${HON_CONTENT_DIR}\" ${NOH_MODS})\n\n#========================================\n# NoH_Editor\n#========================================\nset(NOH_EDITOR_EXE NoH_Editor)\nset(NOH_EDITOR_MODS ${NOH_MODS} editor)\n\nlist(APPEND NOH_EDITOR_DEPENDENCIES\n  ${NOH_DEPENDENCIES}\n  ${EDITOR_LIBRARY}\n  )\n\nlist(APPEND NOH_EDITOR_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND NOH_EDITOR_LIBRARIES\n  ${NOH_LIBRARIES}\n  shell\n  )\n\nadd_executable(${NOH_EDITOR_EXE} ${EXE_TYPE} ${NOH_EDITOR_SOURCES})\nadd_dependencies(${NOH_EDITOR_EXE} ${NOH_EDITOR_DEPENDENCIES})\ntarget_link_libraries(${NOH_EDITOR_EXE} ${NOH_EDITOR_LIBRARIES})\ntarget_include_directories(${NOH_EDITOR_EXE} PRIVATE \"src/Heroes of Newerth_shell\")\ntarget_precompile_headers(${NOH_EDITOR_EXE} PRIVATE \"src/Heroes of Newerth_shell/shell_common.h\")\napp_configure_game_settings(${NOH_EDITOR_EXE} \"NoH\" \"Editor\")\napp_configure_exe(${NOH_EDITOR_EXE} \"NoH Editor\" \"${HON_ICON}\" \"${HON_CONTENT_DIR}\" ${NOH_EDITOR_MODS})\n\n\n#========================================\n# BeT\n#========================================\nset(BET_EXE Beatopia)\nset(BET_MODS hon bet game)\n\nlist(APPEND BET_DEPENDENCIES\n  ${K2_LIBRARY}\n  ${VID_GL2_LIBRARY}\n  ${HON_CLIENT_LIBRARY}\n  ${HON_SERVER_LIBRARY}\n  ${BET_CLIENT_LIBRARY}\n  )\n\nlist(APPEND BET_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND BET_LIBRARIES\n  ${K2_LIBRARY}\n  shell\n  )\n\nadd_executable(${BET_EXE} ${EXE_TYPE} ${BET_SOURCES})\nadd_dependencies(${BET_EXE} ${BET_DEPENDENCIES})\ntarget_link_libraries(${BET_EXE} ${BET_LIBRARIES})\ntarget_include_directories(${BET_EXE} PRIVATE src/Beatopia_shell)\ntarget_precompile_headers(${BET_EXE} PRIVATE \"src/Beatopia_shell/shell_common.h\")\napp_configure_game_settings(${BET_EXE} \"${BET_GAME_NAME}\" \"\")\napp_configure_exe(${BET_EXE} \"BeT\" \"${HON_ICON}\" \"${BET_CONTENT_DIR}\" ${BET_MODS})\n\nif(K2_SYMLINK_MOD_DIRS_IN_BUILD_DIR)\n  # This doesn't quite work, because multiple games means we can't symlink the content dirs inside the build dir\n  foreach (mod base game modelviewer)\n    foreach (game HON)\n      target_symlink(${K2_LIBRARY}\n        \"${${game}_CONTENT_DIR}/${mod}\"\n        \"${CMAKE_BINARY_DIR}/${mod}\"\n        )\n    endforeach()\n  endforeach()\nendif()\n\n#\n# Installation\n#\n\n# Set default install prefix to ./install (inside the project source directory)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${noh_SOURCE_DIR}/install\" CACHE PATH \"Install path\" FORCE)\nendif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n\n# Bundles\nif(APPLE)\n  install(TARGETS ${NOH_APP}\n    BUNDLE DESTINATION . COMPONENT Runtime\n    RUNTIME DESTINATION bin COMPONENT Runtime\n    LIBRARY DESTINATION lib\n    ARCHIVE DESTINATION lib/static)\n\n  # Note Mac specific extension .app\n  set(APPS \"\\${CMAKE_INSTALL_PREFIX}/${NOH_APP}.app\")\n\n  # Directories to look for dependencies\n  set(DIRS ${CMAKE_BINARY_DIR})\n\n  install(CODE \"include(BundleUtilities)\n    fixup_bundle(\\\"${APPS}\\\" \\\"\\\" \\\"${DIRS}\\\")\")\n\n  set(CPACK_GENERATOR \"DRAGNDROP\")\n  include(CPack)\nendif()\n#install(TARGETS ${K2_LIBRARY}\n#  LIBRARY DESTINATION lib\n#  ARCHIVE DESTINATION lib/static)\n#install (FILES ${HEADERS} DESTINATION include)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/CMakeLists.txt	(date 1685007102048)
@@ -18,6 +18,9 @@
 endif()
 enable_language(C CXX)
 
+set(K2_NOVID FALSE CACHE BOOL "Whether to build without graphics dependencies (OpenGL, etc)")
+set(K2_NOSOUND FALSE CACHE BOOL "Whether to build without sound dependencies (FMOD)")
+
 # C++ 20
 set(CMAKE_CXX_STANDARD 20)
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
@@ -415,11 +418,13 @@
 find_package_for_k2(LibXml2 LIBXML2)
 find_package_for_k2(Freetype FREETYPE)
 list(APPEND K2_INCLUDE_DIRS "${noh_SOURCE_DIR}/lib/libpng/include")
-if(WIN32)
-  find_package(OpenGL REQUIRED)
-  list(APPEND K2_LIBRARIES ${OPENGL_LIBRARIES})
-else()
-  find_package_for_k2(OpenGL OPENGL)
+if(NOT K2_NOVID)
+  if(WIN32)
+    find_package(OpenGL REQUIRED)
+    list(APPEND K2_LIBRARIES ${OPENGL_LIBRARIES})
+  else()
+    find_package_for_k2(OpenGL OPENGL)
+  endif()
 endif()
 if(UNIX)
   find_package_for_k2(Curses CURSES)
@@ -1137,6 +1142,8 @@
   src/k2/i_resource.h
   src/k2/i_resourcelibrary.cpp
   src/k2/i_resourcelibrary.h
+  src/k2/i_resourcewatcher2.cpp
+  src/k2/i_resourcewatcher2.h
   src/k2/i_snapshot.cpp
   src/k2/i_snapshot.h
   src/k2/i_tag.cpp
@@ -1205,7 +1212,7 @@
   src/k2/srp.cpp
   src/k2/c_srp.h
   src/k2/c_srp.cpp
-  )
+  src/k2/i_resourcecommon.h)
 
 if(WIN32)
   list(APPEND K2_SOURCES
@@ -1242,6 +1249,7 @@
 #========================================
 # vid_gl2_c
 #========================================
+if(NOT K2_NOVID)
 set(VID_GL2_C_SOURCES
   src/vid_gl2/SOIL/SOIL.c
   src/vid_gl2/SOIL/image_DXT.c
@@ -1250,10 +1258,12 @@
   )
 add_library(vid_gl2_c STATIC ${VID_GL2_C_SOURCES})
 list(APPEND VID_GL2_LIBRARIES vid_gl2_c)
+endif() # if(NOT K2_NOVID)
 
 #========================================
 # vid_gl2
 #========================================
+if(NOT K2_NOVID)
 set(VID_GL2_LIBRARY vid_gl2)
 set(VID_GL2_LIBRARY_LIB "${VID_GL2_LIBRARY}")
 set(VID_GL2_LIBRARY_DLL "${BIN_DIR}/${VID_GL2_LIBRARY}${DLL_EXT}")
@@ -1418,6 +1428,7 @@
 target_compile_definitions(${VID_GL2_LIBRARY} PRIVATE ${VID_GL2_LIBRARY_DEFINITIONS})
 target_link_libraries(${VID_GL2_LIBRARY} ${VID_GL2_LIBRARIES})
 add_dependencies(${VID_GL2_LIBRARY} ${VID_GL2_LIBRARY_DEPENDENCIES})
+endif() # if(NOT K2_NOVID)
 
 #========================================
 # hon_shared
@@ -1891,7 +1902,7 @@
   src/bet_client/game_client_main.cpp
   src/bet_client/bet_client_common.cpp
   src/bet_client/bet_client_common.h
-  )
+)
 
 add_library(${BET_CLIENT_LIBRARY} MODULE ${BET_CLIENT_SOURCES})
 app_configure_lib(${BET_CLIENT_LIBRARY})
Index: .idea/scopes/NoH.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"DependencyValidationManager\">\n  <scope name=\"NoH\" pattern=\"(file:src//*||file:Heroes of Newerth//*||file:lib/k2public//*||file:Beatopia//*)&amp;&amp;!file:src/aba_client//*&amp;&amp;!file:src/aba_server//*&amp;&amp;!file:src/aba_shared//*&amp;&amp;!file:src/Abaddon_shell//*&amp;&amp;!file:src/editor_x//*&amp;&amp;!file:src/game_client//*&amp;&amp;!file:src/game_server//*&amp;&amp;!file:src/game_shared//*&amp;&amp;!file:src/HoN.xcodeproj//*&amp;&amp;!file:src/Savage 2_shell//*&amp;&amp;!file:src/Abaddon.sln&amp;&amp;!file:src/Savage 2.sln&amp;&amp;!file:*.dylib&amp;&amp;!file:src/vid_d3d9//*&amp;&amp;!file:src/vid_d3d9f//*&amp;&amp;!file:src/vid_d3d9g//*&amp;&amp;!file:src/vid_gl2/GLEW//*&amp;&amp;!file:src/vid_gl2/libXNVCtrl//*&amp;&amp;!file:src/vid_gl2/SOIL//*\" />\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/scopes/NoH.xml b/.idea/scopes/NoH.xml
--- a/.idea/scopes/NoH.xml	(revision e3c9bb89b8e507c9b2c995b605006e3a0a1199c1)
+++ b/.idea/scopes/NoH.xml	(date 1684983011642)
@@ -1,3 +1,3 @@
 <component name="DependencyValidationManager">
-  <scope name="NoH" pattern="(file:src//*||file:Heroes of Newerth//*||file:lib/k2public//*||file:Beatopia//*)&amp;&amp;!file:src/aba_client//*&amp;&amp;!file:src/aba_server//*&amp;&amp;!file:src/aba_shared//*&amp;&amp;!file:src/Abaddon_shell//*&amp;&amp;!file:src/editor_x//*&amp;&amp;!file:src/game_client//*&amp;&amp;!file:src/game_server//*&amp;&amp;!file:src/game_shared//*&amp;&amp;!file:src/HoN.xcodeproj//*&amp;&amp;!file:src/Savage 2_shell//*&amp;&amp;!file:src/Abaddon.sln&amp;&amp;!file:src/Savage 2.sln&amp;&amp;!file:*.dylib&amp;&amp;!file:src/vid_d3d9//*&amp;&amp;!file:src/vid_d3d9f//*&amp;&amp;!file:src/vid_d3d9g//*&amp;&amp;!file:src/vid_gl2/GLEW//*&amp;&amp;!file:src/vid_gl2/libXNVCtrl//*&amp;&amp;!file:src/vid_gl2/SOIL//*" />
+  <scope name="NoH" pattern="(file:src//*||file:Heroes of Newerth//*||file:lib/k2public//*||file:Beatopia//*)&amp;&amp;!file:src/aba_client//*&amp;&amp;!file:src/aba_server//*&amp;&amp;!file:src/aba_shared//*&amp;&amp;!file:src/Abaddon_shell//*&amp;&amp;!file:src/editor_x//*&amp;&amp;!file:src/game_client//*&amp;&amp;!file:src/game_server//*&amp;&amp;!file:src/game_shared//*&amp;&amp;!file:src/HoN.xcodeproj//*&amp;&amp;!file:src/Savage 2_shell//*&amp;&amp;!file:src/Abaddon.sln&amp;&amp;!file:src/Savage 2.sln&amp;&amp;!file:*.dylib&amp;&amp;!file:src/vid_d3d9//*&amp;&amp;!file:src/vid_d3d9f//*&amp;&amp;!file:src/vid_d3d9g//*&amp;&amp;!file:src/vid_gl2/GLEW//*&amp;&amp;!file:src/vid_gl2/libXNVCtrl//*&amp;&amp;!file:src/vid_gl2/SOIL//*&amp;&amp;!file[noh]:src/k2/k2.vcproj" />
 </component>
\ No newline at end of file
