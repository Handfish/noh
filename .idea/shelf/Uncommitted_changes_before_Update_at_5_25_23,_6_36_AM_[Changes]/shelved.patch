Index: src/k2/xtoa.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// xtoa.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"xtoa.h\"\n#include \"stringutils.h\"\n\n#include <iostream>\n#include <iomanip>\n\nusing std::ios;\nusing std::setw;\nusing std::setprecision;\nusing std::streamsize;\n//=============================================================================\n\n/*====================\n  FormatInt\n ====================*/\nvoid    FormatInt(ULONGLONG ull, int flags, size_t width, int base, char sign, string &sStr)\n{\n    // Determine sign character, unless it's\n    // already been determined negative\n    if (sign == 0)\n    {\n        if (flags & FMT_SIGN)\n            sign = '+';\n        else if (flags & FMT_PADSIGN)\n            sign = ' ';\n    }\n\n    // Set up Delimeter\n    int dspacing(0);\n    char dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        switch (base)\n        {\n        case 2:\n            dchar = ' ';\n            dspacing = 8;\n            break;\n\n        case 10:\n            dchar = ',';\n            dspacing = 3;\n        }\n    }\n\n    // Build the string of digits\n    ULONGLONG n(base);\n    int d(1);\n    do\n    {\n        TCHAR c = TCHAR((ull % n) / (n / base));\n        c += (c > 9) ? ((c > 35) ? ('A' - 36) : ('a' - 10)) : '0';\n        sStr += c;\n        ull -= ull % n;\n        if (dchar != 0 && ull != 0 && d == dspacing)\n        {\n            sStr += dchar;\n            d = 0;\n        }\n        ++d;\n        n *= base;\n    }\n    while (ull);\n\n    int padcount(0);\n\n    // Prefixes\n    char prefix[3] = { 0, 0, 0 };\n    if (!(flags & FMT_NOPREFIX))\n    {\n        if (base == 2)\n        {\n            prefix[0] = 'b';\n            padcount -= 1;\n        }\n        else if (base == 8)\n        {\n            prefix[0] = '0';\n            padcount -= 1;\n        }\n        else if (base == 16)\n        {\n            //backwards, the string will be reversed\n            prefix[0] = 'x';\n            prefix[1] = '0';\n            padcount -= 2;\n        }\n    }\n\n    // Prefix is included before non-zero padding\n    if (prefix[0] && !(flags & FMT_PADZERO))\n    {\n        sStr += prefix;\n        padcount = 0;\n    }\n\n    padcount += int(width) - int(sStr.length()) - ((sign == 0) ? 0 : 1);\n\n    // If padding is space, add sign before padding\n    if (!(flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    // Padding\n    char padchar(' ');\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = '0';\n    if (padcount < 0)\n        padcount = 0;\n    string padding(padcount, padchar);\n    // special case to delimit leading zeros\n    if (dchar != 0 && padchar == '0')\n    {\n        for (size_t z(0); z < padding.length(); ++z)\n        {\n            if (z == padding.length() - 1)\n                dchar = ' ';    // last delimiter always looks better as a blank\n\n            if (d == dspacing + 1)\n            {\n                padding[z] = dchar;\n                d = 0;\n            }\n            ++d;\n        }\n    }\n    if (!(flags & FMT_ALIGNLEFT))\n        sStr += padding;\n\n    // Add prefix after zero padding\n    if (prefix[0] && (flags & FMT_PADZERO))\n        sStr += prefix;\n\n    // If padding is 0, add sign after the padding\n    if ((flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    reverse(sStr.begin(), sStr.end());\n\n    // Left aligned padding\n    if ((flags & FMT_ALIGNLEFT) && padchar != '0')\n        sStr += padding;\n}\n\nvoid    FormatInt(ULONGLONG ull, int flags, size_t width, int base, wchar_t sign, wstring &sStr)\n{\n    // Determine sign character, unless it's\n    // already been determined negative\n    if (sign == 0)\n    {\n        if (flags & FMT_SIGN)\n            sign = L'+';\n        else if (flags & FMT_PADSIGN)\n            sign = L' ';\n    }\n\n    // Set up Delimeter\n    int dspacing(0);\n    wchar_t dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        switch (base)\n        {\n        case 2:\n            dchar = L' ';\n            dspacing = 8;\n            break;\n\n        case 10:\n            dchar = L',';\n            dspacing = 3;\n        }\n    }\n\n    // Build the string of digits\n    ULONGLONG n(base);\n    int d(1);\n    do\n    {\n        TCHAR c = TCHAR((ull % n) / (n / base));\n        c += (c > 9) ? ((c > 35) ? (L'A' - 36) : (L'a' - 10)) : L'0';\n        sStr += c;\n        ull -= ull % n;\n        if (dchar != 0 && ull != 0 && d == dspacing)\n        {\n            sStr += dchar;\n            d = 0;\n        }\n        ++d;\n        n *= base;\n    }\n    while (ull);\n\n    int padcount(0);\n\n    // Prefixes\n    wchar_t prefix[3] = { 0, 0, 0 };\n    if (!(flags & FMT_NOPREFIX))\n    {\n        if (base == 2)\n        {\n            prefix[0] = L'b';\n            padcount -= 1;\n        }\n        else if (base == 8)\n        {\n            prefix[0] = L'0';\n            padcount -= 1;\n        }\n        else if (base == 16)\n        {\n            //backwards, the string will be reversed\n            prefix[0] = L'x';\n            prefix[1] = L'0';\n            padcount -= 2;\n        }\n    }\n\n    // Prefix is included before non-zero padding\n    if (prefix[0] && !(flags & FMT_PADZERO))\n    {\n        sStr += prefix;\n        padcount = 0;\n    }\n\n    padcount += int(width) - int(sStr.length()) - ((sign == 0) ? 0 : 1);\n\n    // If padding is space, add sign before padding\n    if (!(flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    // Padding\n    wchar_t padchar(L' ');\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = L'0';\n    if (padcount < 0)\n        padcount = 0;\n    wstring padding(padcount, padchar);\n    // special case to delimit leading zeros\n    if (dchar != 0 && padchar == L'0')\n    {\n        for (size_t z(0); z < padding.length(); ++z)\n        {\n            if (z == padding.length() - 1)\n                dchar = L' ';   // last delimiter always looks better as a blank\n\n            if (d == dspacing + 1)\n            {\n                padding[z] = dchar;\n                d = 0;\n            }\n            ++d;\n        }\n    }\n    if (!(flags & FMT_ALIGNLEFT))\n        sStr += padding;\n\n    // Add prefix after zero padding\n    if (prefix[0] && (flags & FMT_PADZERO))\n        sStr += prefix;\n\n    // If padding is 0, add sign after the padding\n    if ((flags & FMT_PADZERO) && sign != 0)\n        sStr += sign;\n\n    reverse(sStr.begin(), sStr.end());\n\n    // Left aligned padding\n    if ((flags & FMT_ALIGNLEFT) && padchar != L'0')\n        sStr += padding;\n}\n\n\n/*====================\n  FormatFloat\n ====================*/\nvoid    FormatFloat(double d, int flags, size_t width, int precision, string &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!precision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? '-' : 0), sStr);\n        return;\n    }\n#endif\n    // Determine sign character\n    char sign(0);\n    if (d < 0)\n    {\n        sign = '-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = '+';\n        else if (flags & FMT_PADSIGN)\n            sign = ' ';\n    }\n\n    if (_isnan(d))\n    {\n        sStr += \"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += \"#INF\";\n        return;\n    }\n\n    char szBuffer[256];\n    int iDec;\n    int iSign;\n\n#if defined(_WIN32)\n    _fcvt_s(szBuffer, 256, d, precision, &iDec, &iSign);\n#else\n    strncpy(szBuffer, fcvt(d, precision, &iDec, &iSign), 256);\n#endif\n\n    // Set up Delimeter\n    int dspacing(0);\n    char dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = ',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -precision)\n            iDec = -precision;\n\n        sStr += '0';\n        if (precision > 0)\n            sStr += '.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += '0';\n        for (char *sz(szBuffer); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (char *sz(szBuffer); *sz; ++sz, ++i)\n        {\n            if (i == iDec && precision > 0)\n                sStr += '.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    char padchar(' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((precision > 0) ? 1 : 0) - precision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = '0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        string padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == '0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\nvoid    FormatFloat(double d, int flags, size_t width, int precision, wstring &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!precision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);\n        return;\n    }\n#endif\n    if (_isnan(d))\n    {\n        sStr += L\"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += L\"#INF\";\n        return;\n    }\n\n    // Determine sign character\n    wchar_t sign(0);\n    if (d < 0)\n    {\n        sign = L'-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = L'+';\n        else if (flags & FMT_PADSIGN)\n            sign = L' ';\n    }\n\n    char szBuffer[256];\n    wchar_t szBufferW[256];\n    int iDec;\n    int iSign;\n\n#ifdef _WIN32\n    _fcvt_s(szBuffer, 256, d, precision, &iDec, &iSign);\n#else\n    strncpy(szBuffer, fcvt(d, precision, &iDec, &iSign), 256);\n#endif\n    SingleToWide(szBufferW, szBuffer, 256);\n\n    // Set up Delimeter\n    int dspacing(0);\n    wchar_t dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = L',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -precision)\n            iDec = -precision;\n\n        sStr += L'0';\n        if (precision > 0)\n            sStr += L'.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += L'0';\n        for (wchar_t *sz(szBufferW); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)\n        {\n            if (i == iDec && precision > 0)\n                sStr += L'.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    wchar_t padchar(L' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((precision > 0) ? 1 : 0) - precision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = L'0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        wstring padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == L'0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\nvoid    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, string &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!iMaxPrecision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? '-' : 0), sStr);\n        return;\n    }\n#endif\n    // Determine sign character\n    char sign(0);\n    if (d < 0)\n    {\n        sign = '-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = '+';\n        else if (flags & FMT_PADSIGN)\n            sign = ' ';\n    }\n\n    if (_isnan(d))\n    {\n        sStr += \"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += \"#INF\";\n        return;\n    }\n\n    char szBuffer[256];\n    int iDec;\n    int iSign;\n\n#ifdef _WIN32\n    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);\n#else\n    strncpy(szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);\n#endif\n\n    int iLength(int(strlen(szBuffer)));\n\n    // Trim trailing zeros up to min precision\n    while (iLength > iDec && szBuffer[iLength - 1] == '0' && iMaxPrecision > iMinPrecision)\n    {\n        --iLength;\n        --iMaxPrecision;\n    }\n\n    szBuffer[iLength] = '\\0';\n\n    // Set up Delimeter\n    int dspacing(0);\n    char dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = ',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -iMaxPrecision)\n            iDec = -iMaxPrecision;\n\n        sStr += '0';\n        if (iMaxPrecision > 0)\n            sStr += '.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += '0';\n        for (char *sz(szBuffer); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (char *sz(szBuffer); *sz; ++sz, ++i)\n        {\n            if (i == iDec && iMaxPrecision > 0)\n                sStr += '.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    char padchar(' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = '0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        string padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == '0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\nvoid    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, wstring &sStr)\n{\n#if defined(__APPLE__)\n    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way\n    if (!iMaxPrecision)\n    {\n        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);\n        return;\n    }\n#endif\n    // Determine sign character\n    wchar_t sign(0);\n    if (d < 0)\n    {\n        sign = L'-';\n    }\n    else\n    {\n        if (flags & FMT_SIGN)\n            sign = L'+';\n        else if (flags & FMT_PADSIGN)\n            sign = L' ';\n    }\n\n    if (_isnan(d))\n    {\n        sStr += L\"#NAN\";\n        return;\n    }\n\n    if (!_finite(d))\n    {\n        sStr += L\"#INF\";\n        return;\n    }\n\n    char szBuffer[256];\n    wchar_t szBufferW[256];\n    int iDec;\n    int iSign;\n\n#ifdef _WIN32\n    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);\n#else\n    strncpy((char*)szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);\n#endif\n    SingleToWide(szBufferW, szBuffer, 256);\n\n    int iLength(int(wcslen(szBufferW)));\n\n    // Trim trailing zeros up to min precision\n    while (iLength > iDec && szBufferW[iLength - 1] == L'0' && iMaxPrecision > iMinPrecision)\n    {\n        --iLength;\n        --iMaxPrecision;\n    }\n\n    szBufferW[iLength] = L'\\0';\n\n    // Set up Delimeter\n    int dspacing(0);\n    wchar_t dchar(0);\n    if (flags & FMT_DELIMIT)\n    {\n        dchar = L',';\n        dspacing = 3;\n    }\n\n    // Build the string of digits\n    if (iDec <= 0)\n    {\n        if (iDec < -iMaxPrecision)\n            iDec = -iMaxPrecision;\n\n        sStr += L'0';\n        if (iMaxPrecision > 0)\n            sStr += L'.';\n        for (int i(iDec); i < 0; ++i)\n            sStr += L'0';\n        for (wchar_t *sz(szBufferW); *sz; ++sz)\n            sStr += *sz;\n    }\n    else\n    {\n        int i(0);\n\n        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)\n        {\n            if (i == iDec && iMaxPrecision > 0)\n                sStr += L'.';\n            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)\n                sStr += dchar;\n            sStr += *sz;\n        }\n    }\n\n    // Create padding\n    wchar_t padchar(L' ');\n    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);\n    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))\n        padchar = L'0';\n    if (padcount < 0)\n        padcount = 0;\n\n    // Assemble the parts\n    if (padcount > 0)\n    {\n        wstring padding(padcount, padchar);\n\n        if (sign != 0)\n        {\n            if (flags & FMT_ALIGNLEFT)\n            {\n                sStr = sign + sStr + padding;\n            }\n            else\n            {\n                if (padchar == L'0')\n                    sStr = sign + padding + sStr;\n                else\n                    sStr = padding + sign + sStr;\n            }\n        }\n        else\n        {\n            if (flags & FMT_ALIGNLEFT)\n                sStr = sStr + padding;\n            else\n                sStr = padding + sStr;\n        }\n    }\n    else\n    {\n        if (sign != 0)\n            sStr = sign + sStr;\n    }\n}\n\n\n/*====================\n  XtoA\n ====================*/\nwstring XtoW(const CVec2f &vec, int flags, int width, int precision)\n{\n    wstring sX, sY;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n\n    wstring str(sX + L\" \" + sY);\n\n    return XtoW(str, flags, width);\n}\n\nwstring XtoW(const CVec3f &vec, int flags, int width, int precision)\n{\n    wstring sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    wstring str(sX + L\" \" + sY + L\" \" + sZ);\n\n    return XtoW(str, flags, width);\n}\n\nwstring XtoW(const CVec3<double> &vec, int flags, int width, int precision)\n{\n    wstring sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    wstring str(sX + L\" \" + sY + L\" \" + sZ);\n\n    return XtoW(str, flags, width);\n}\n\nwstring XtoW(const CVec4f &v4, int flags, int width, int precision)\n{\n    wstring sX, sY, sZ, sW;\n\n    FormatFloat(v4.x, flags, 0, precision, sX);\n    FormatFloat(v4.y, flags, 0, precision, sY);\n    FormatFloat(v4.z, flags, 0, precision, sZ);\n    FormatFloat(v4.w, flags, 0, precision, sW);\n\n    wstring str(sX + L\" \" + sY + L\" \" + sZ + L\" \" + sW);\n\n    return XtoW(str, flags, width);\n}\n\nstring  XtoS(const CVec2f &vec, int flags, int width, int precision)\n{\n    string sX, sY;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n\n    string str(sX + \" \" + sY);\n\n    return XtoS(str, flags, width);\n}\n\nstring  XtoS(const CVec3f &vec, int flags, int width, int precision)\n{\n    string sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    string str(sX + \" \" + sY + \" \" + sZ);\n\n    return XtoS(str, flags, width);\n}\n\nstring  XtoS(const CVec3<double> &vec, int flags, int width, int precision)\n{\n    string sX, sY, sZ;\n\n    FormatFloat(vec.x, flags, 0, precision, sX);\n    FormatFloat(vec.y, flags, 0, precision, sY);\n    FormatFloat(vec.z, flags, 0, precision, sZ);\n\n    string str(sX + \" \" + sY + \" \" + sZ);\n\n    return XtoS(str, flags, width);\n}\n\nstring  XtoS(const CVec4f &v4, int flags, int width, int precision)\n{\n    string sX, sY, sZ, sW;\n\n    FormatFloat(v4.x, flags, 0, precision, sX);\n    FormatFloat(v4.y, flags, 0, precision, sY);\n    FormatFloat(v4.z, flags, 0, precision, sZ);\n    FormatFloat(v4.w, flags, 0, precision, sW);\n\n    string str(sX + \" \" + sY + \" \" + sZ + \" \" + sW);\n\n    return XtoS(str, flags, width);\n}\n\nwstring XtoW(const wstring &s, int flags, size_t width)\n{\n    if (s.length() >= width)\n        return s;\n\n    if (flags & FMT_ALIGNLEFT)\n        return s + wstring(width - s.length(), L' ');\n    else\n        return wstring(width - s.length(), L' ') + s;\n}\n\nstring XtoS(const string &s, int flags, size_t width)\n{\n    if (s.length() >= width)\n        return s;\n\n    if (flags & FMT_ALIGNLEFT)\n        return s + string(width - s.length(), ' ');\n    else\n        return string(width - s.length(), ' ') + s;\n}\n\n\n/*====================\n  AtoX\n ====================*/\nCVec2f& AtoX(const tstring &s, CVec2f &v2)\n{\n    const tsvector &vComponents = TokenizeString(s, _T(' '));\n    float   x, y;\n    if (vComponents.size() < 2)\n    {\n        x = y = 0.0f;\n    }\n    else\n    {\n        AtoX(vComponents[0], x);\n        AtoX(vComponents[1], y);\n    }\n    v2.Set(x, y);\n    return v2;\n}\n\nCVec3f& AtoX(const tstring &s, CVec3f &v3)\n{\n    const tsvector &vComponents = TokenizeString(s, _T(' '));\n    float   x, y, z;\n    if (vComponents.size() < 3)\n    {\n        x = y = z = 0.0f;\n    }\n    else\n    {\n        AtoX(vComponents[0], x);\n        AtoX(vComponents[1], y);\n        AtoX(vComponents[2], z);\n    }\n    v3.Set(x, y, z);\n    return v3;\n}\n\nCVec4f& AtoX(const tstring &s, CVec4f &v4)\n{\n    const tsvector &vComponents = TokenizeString(s, _T(' '));\n    float   x, y, z, w;\n    if (vComponents.size() < 4)\n    {\n        x = y = z = w = 0.0f;\n    }\n    else\n    {\n        AtoX(vComponents[0], x);\n        AtoX(vComponents[1], y);\n        AtoX(vComponents[2], z);\n        AtoX(vComponents[3], w);\n    }\n    v4.Set(x, y, z, w);\n    return v4;\n}\n\n\n/*====================\n  AtoV2\n ====================*/\nK2_API CVec2f   AtoV2(const tstring &s)\n{\n    CVec2f vRet;\n\n    _STSCANF_S_BEGIN(s.c_str(), _T(\"%f %f\"))\n        &vRet.x, &vRet.y\n    _STSCANF_S_END;\n\n    return vRet;\n}\n\n\n/*====================\n  AtoV3\n ====================*/\nK2_API CVec3f   AtoV3(const tstring &s)\n{\n    CVec3f vRet;\n\n    int iFields(_STSCANF_S_BEGIN(s.c_str(), _T(\"%f %f %f\"))\n        &vRet.x, &vRet.y, &vRet.z\n    _STSCANF_S_END);\n\n    if (iFields == 1)\n        vRet.z = vRet.y = vRet.x;\n\n    return vRet;\n}\n\n\n/*====================\n  AtoV4\n ====================*/\nCVec4f  AtoV4(const tstring &s)\n{\n    CVec4f vRet;\n\n    _STSCANF_S_BEGIN(s.c_str(), _T(\"%f %f %f %f\"))\n        &vRet.x, &vRet.y, &vRet.z, &vRet.w\n    _STSCANF_S_END;\n\n    return vRet;\n}\n\n\n/*====================\n  PtoI\n  ====================*/\nint     PtoI(const tstring &s)\n{\n    if (s[s.length() - 1] != _T('%'))\n        return 0;\n\n    int iRet(AtoI(s.substr(0, s.length() - 1)));\n    CLAMP(iRet, 0, 100);\n    return iRet;\n}\n\n\n/*====================\n  PtoF\n  ====================*/\nfloat   PtoF(const tstring &s)\n{\n    if (s[s.length() - 1] != _T('%'))\n        return 0.0f;\n\n    float fRet(AtoF(s.substr(0, s.length() - 1)));\n    return fRet;\n}\n\n\n/*====================\n  P2toF\n  ====================*/\nfloat   P2toF(const tstring &s)\n{\n    if (s[s.length() - 1] != _T('@'))\n        return 0.0f;\n\n    float fRet(AtoF(s.substr(0, s.length() - 1)));\n    return fRet;\n}\n\n\n/*====================\n  BytesToHexString\n  ====================*/\ntstring         BytesToHexString(const byte* pData, size_t uiLen)\n{\n    // https://stackoverflow.com/questions/14050452/how-to-convert-byte-array-to-hex-string-in-visual-c\n    std::stringstream ss;\n    ss << std::hex;\n\n    for( size_t i(0) ; i < uiLen; ++i ) {\n        ss << std::setw(2) << std::setfill('0') << (int)pData[i];\n    }\n\n    return StringToTString(ss.str());\n}\n\n/*====================\n  HexStringToBytes\n  ====================*/\nvector<byte>    HexStringToBytes(const tstring& sData)\n{\n    // https://stackoverflow.com/questions/17261798/converting-a-hex-string-to-a-byte-array\n    std::stringstream ss;\n    ss << TStringToUTF8(sData);\n\n    std::vector<byte> resBytes;\n    size_t count = 0;\n    const auto len = sData.size();\n    while(ss.good() && count < len)\n    {\n        unsigned short num;\n        char hexNum[2];\n        ss.read(hexNum, 2);\n        sscanf(hexNum, \"%2hX\", &num);\n        assert(num >= 0 && num <= 255);\n        resBytes.push_back(static_cast<byte>(num));\n        count += 2;\n    }\n    return resBytes;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/xtoa.cpp b/src/k2/xtoa.cpp
--- a/src/k2/xtoa.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/xtoa.cpp	(date 1685007426848)
@@ -280,6 +280,144 @@
 }
 
 
+void    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, wstring &sStr)
+{
+#if defined(__APPLE__)
+    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way
+    if (iMaxPrecision <= 0)
+    {
+        FormatInt(ULONGLONG(d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
+        return;
+    }
+#endif
+    // Determine sign character
+    wchar_t sign(0);
+    if (d < 0)
+    {
+        sign = L'-';
+    }
+    else
+    {
+        if (flags & FMT_SIGN)
+            sign = L'+';
+        else if (flags & FMT_PADSIGN)
+            sign = L' ';
+    }
+
+    if (_isnan(d))
+    {
+        sStr += L"#NAN";
+        return;
+    }
+
+    if (!_finite(d))
+    {
+        sStr += L"#INF";
+        return;
+    }
+
+    char szBuffer[256];
+    wchar_t szBufferW[256];
+    int iDec;
+    int iSign;
+
+#ifdef _WIN32
+    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);
+#else
+    strncpy((char*)szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);
+#endif
+    SingleToWide(szBufferW, szBuffer, 256);
+
+    int iLength(int(wcslen(szBufferW)));
+
+    // Trim trailing zeros up to min precision
+    while (iLength > iDec && szBufferW[iLength - 1] == L'0' && iMaxPrecision > iMinPrecision)
+    {
+        --iLength;
+        --iMaxPrecision;
+    }
+
+    szBufferW[iLength] = L'\0';
+
+    // Set up Delimeter
+    int dspacing(0);
+    wchar_t dchar(0);
+    if (flags & FMT_DELIMIT)
+    {
+        dchar = L',';
+        dspacing = 3;
+    }
+
+    // Build the string of digits
+    if (iDec <= 0)
+    {
+        if (iDec < -iMaxPrecision)
+            iDec = -iMaxPrecision;
+
+        sStr += L'0';
+        if (iMaxPrecision > 0)
+            sStr += L'.';
+        for (int i(iDec); i < 0; ++i)
+            sStr += L'0';
+        for (wchar_t *sz(szBufferW); *sz; ++sz)
+            sStr += *sz;
+    }
+    else
+    {
+        int i(0);
+
+        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)
+        {
+            if (i == iDec && iMaxPrecision > 0)
+                sStr += L'.';
+            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)
+                sStr += dchar;
+            sStr += *sz;
+        }
+    }
+
+    // Create padding
+    wchar_t padchar(L' ');
+    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);
+    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))
+        padchar = L'0';
+    if (padcount < 0)
+        padcount = 0;
+
+    // Assemble the parts
+    if (padcount > 0)
+    {
+        wstring padding(padcount, padchar);
+
+        if (sign != 0)
+        {
+            if (flags & FMT_ALIGNLEFT)
+            {
+                sStr = sign + sStr + padding;
+            }
+            else
+            {
+                if (padchar == L'0')
+                    sStr = sign + padding + sStr;
+                else
+                    sStr = padding + sign + sStr;
+            }
+        }
+        else
+        {
+            if (flags & FMT_ALIGNLEFT)
+                sStr = sStr + padding;
+            else
+                sStr = padding + sStr;
+        }
+    }
+    else
+    {
+        if (sign != 0)
+            sStr = sign + sStr;
+    }
+}
+
 /*====================
   FormatFloat
  ====================*/
@@ -414,7 +552,7 @@
     // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way
     if (!precision)
     {
-        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
+        FormatInt(ULONGLONG(d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
         return;
     }
 #endif
@@ -670,144 +808,6 @@
             sStr = sign + sStr;
     }
 }
-
-void    FormatFloat(double d, int flags, size_t width, int iMinPrecision, int iMaxPrecision, wstring &sStr)
-{
-#if defined(__APPLE__)
-    // fcvt is buggy when ndigit = 0, so lets just convert this to an int and format it that way
-    if (!iMaxPrecision)
-    {
-        FormatInt((d < 0 ? -d : d), flags, width, 10, (d < 0 ? L'-' : 0), sStr);
-        return;
-    }
-#endif
-    // Determine sign character
-    wchar_t sign(0);
-    if (d < 0)
-    {
-        sign = L'-';
-    }
-    else
-    {
-        if (flags & FMT_SIGN)
-            sign = L'+';
-        else if (flags & FMT_PADSIGN)
-            sign = L' ';
-    }
-
-    if (_isnan(d))
-    {
-        sStr += L"#NAN";
-        return;
-    }
-
-    if (!_finite(d))
-    {
-        sStr += L"#INF";
-        return;
-    }
-
-    char szBuffer[256];
-    wchar_t szBufferW[256];
-    int iDec;
-    int iSign;
-
-#ifdef _WIN32
-    _fcvt_s(szBuffer, 256, d, iMaxPrecision, &iDec, &iSign);
-#else
-    strncpy((char*)szBuffer, fcvt(d, iMaxPrecision, &iDec, &iSign), 256);
-#endif
-    SingleToWide(szBufferW, szBuffer, 256);
-
-    int iLength(int(wcslen(szBufferW)));
-
-    // Trim trailing zeros up to min precision
-    while (iLength > iDec && szBufferW[iLength - 1] == L'0' && iMaxPrecision > iMinPrecision)
-    {
-        --iLength;
-        --iMaxPrecision;
-    }
-
-    szBufferW[iLength] = L'\0';
-
-    // Set up Delimeter
-    int dspacing(0);
-    wchar_t dchar(0);
-    if (flags & FMT_DELIMIT)
-    {
-        dchar = L',';
-        dspacing = 3;
-    }
-
-    // Build the string of digits
-    if (iDec <= 0)
-    {
-        if (iDec < -iMaxPrecision)
-            iDec = -iMaxPrecision;
-
-        sStr += L'0';
-        if (iMaxPrecision > 0)
-            sStr += L'.';
-        for (int i(iDec); i < 0; ++i)
-            sStr += L'0';
-        for (wchar_t *sz(szBufferW); *sz; ++sz)
-            sStr += *sz;
-    }
-    else
-    {
-        int i(0);
-
-        for (wchar_t *sz(szBufferW); *sz; ++sz, ++i)
-        {
-            if (i == iDec && iMaxPrecision > 0)
-                sStr += L'.';
-            if (dchar != 0 && i > 0 && i < iDec && (iDec - i) % dspacing == 0)
-                sStr += dchar;
-            sStr += *sz;
-        }
-    }
-
-    // Create padding
-    wchar_t padchar(L' ');
-    int padcount(int(width) - ((sign == 0) ? 0 : 1) - (MAX(iDec, 1)) - ((iMaxPrecision > 0) ? 1 : 0) - iMaxPrecision);
-    if (flags & FMT_PADZERO && !(flags & FMT_ALIGNLEFT))
-        padchar = L'0';
-    if (padcount < 0)
-        padcount = 0;
-
-    // Assemble the parts
-    if (padcount > 0)
-    {
-        wstring padding(padcount, padchar);
-
-        if (sign != 0)
-        {
-            if (flags & FMT_ALIGNLEFT)
-            {
-                sStr = sign + sStr + padding;
-            }
-            else
-            {
-                if (padchar == L'0')
-                    sStr = sign + padding + sStr;
-                else
-                    sStr = padding + sign + sStr;
-            }
-        }
-        else
-        {
-            if (flags & FMT_ALIGNLEFT)
-                sStr = sStr + padding;
-            else
-                sStr = padding + sStr;
-        }
-    }
-    else
-    {
-        if (sign != 0)
-            sStr = sign + sStr;
-    }
-}
 
 
 /*====================
Index: src/shell/main_osx.mm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2008 S2 Games\n// main_osx.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers  \n//=============================================================================\n#ifndef __APPLE__\n#error main_osx.mm can only be compiled for OS X\n#endif\n\n#include \"shell_common.h\"\n#include \"../k2/c_vid.h\"\n\n#include <Cocoa/Cocoa.h>\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\n\n@interface AppDelegate : NSObject<NSApplicationDelegate>\n{\n    BOOL    m_bMinimized;\n}\n- (void)applicationWillFinishLaunching:(NSNotification*)aNotification;\n- (void)applicationDidFinishLaunching:(NSNotification*)aNotification;\n- (void)applicationDidBecomeActive:(NSNotification*)aNotification;\n- (void)applicationDidResignActive:(NSNotification*)aNotification;\n- (void)applicationWillHide:(NSNotification*)aNotification;\n- (void)applicationDidUnhide:(NSNotification *)aNotification;\n- (BOOL)validateMenuItem:(NSMenuItem*)item;\n- (void)toggleFullscreen:(id)sender;\n- (void)minimize:(id)sender;\n- (void)quit:(id)sender;\n@end\n//=============================================================================\n\n\n@implementation AppDelegate\n- (void)applicationWillFinishLaunching:(NSNotification*)aNotification\n{\n    // ensure the menu won't freeze: https://stackoverflow.com/questions/34469718/top-left-menu-bar-is-frozen-when-main-window-shows-up\n    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\n    // set up the menu\n    NSMenu *pMainMenu = [[NSMenu alloc] init];\n    NSMenu *pMenu = [[NSMenu alloc] initWithTitle:@(GAME_TITLE)];\n    // about (standard entry)\n    [pMenu addItemWithTitle:@(\"About \" GAME_TITLE) action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@\"\"];\n    [pMenu addItem:[NSMenuItem separatorItem]];\n    // editor/modelviewer\n    NSMenuItem *pMenuItem;\n    // toggle fullscreen\n    pMenuItem = (NSMenuItem*)[[NSMenuItem alloc] initWithTitle:@\"Toggle Fullscreen\" action:@selector(toggleFullscreen:) keyEquivalent:@\"f\"];\n    [pMenu addItem:pMenuItem];\n    // minimize\n    pMenuItem = (NSMenuItem*)[[NSMenuItem alloc] initWithTitle:@\"Minimize\" action:@selector(minimize:) keyEquivalent:@\"m\"];\n    [pMenu addItem:pMenuItem];\n    // hide/show (standard entries)\n    [pMenu addItemWithTitle:@(\"Hide \" GAME_TITLE) action:@selector(hide:) keyEquivalent:@\"h\"];\n    pMenuItem = (NSMenuItem*)[pMenu addItemWithTitle:@\"Hide Others\" action:@selector(hideOtherApplications:) keyEquivalent:@\"h\"];\n    [pMenuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];\n    [pMenu addItemWithTitle:@\"Show All\" action:@selector(unhideAllApplications:) keyEquivalent:@\"\"];\n    // quit\n    [pMenu addItem:[NSMenuItem separatorItem]];\n    pMenuItem = (NSMenuItem*)[pMenu addItemWithTitle:@(\"Quit \" GAME_TITLE) action:@selector(quit:) keyEquivalent:@\"q\"];\n    [pMenuItem setKeyEquivalentModifierMask:(NSEventModifierFlagCommand)];\n    // add to menu bar\n    pMenuItem = [[NSMenuItem alloc] initWithTitle:@\"\" action:nil keyEquivalent:@\"\"];\n    [pMenuItem setSubmenu:pMenu];\n    [pMainMenu addItem:pMenuItem];\n    #if TKTK\n    // private method that we need to call to set this to be the main/\"apple\" menu\n    [NSApp performSelector:NSSelectorFromString(@\"setAppleMenu:\") withObject:pMenu];\n    #else\n    [NSApp setMainMenu:pMainMenu];\n    #endif\n}\n\n- (void)applicationDidFinishLaunching:(NSNotification*)aNotification\n{\n    // ensure the menu won't freeze: https://stackoverflow.com/questions/34469718/top-left-menu-bar-is-frozen-when-main-window-shows-up\n    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\n    [[[NSApplication sharedApplication] mainWindow] makeKeyAndOrderFront:self];\n    // bring the window to the front\n    #if 1\n    int processID = [[NSProcessInfo processInfo] processIdentifier];\n    NSRunningApplication* app = [NSRunningApplication runningApplicationWithProcessIdentifier: processID];\n    [app activateWithOptions: NSApplicationActivateAllWindows | NSApplicationActivateIgnoringOtherApps];\n    #elif 0\n    Console.Execute(_T(\"BringActiveWindowToFront\"));\n    #endif\n\n    K2System.Init(_T(GAME_TITLE), VERSION_STRING, BUILD_INFO_STRING, BUILDNUMBER, BUILD_OS, BUILD_OS_INFO, BUILD_ARCH, MASTER_SERVER_ADDRESS);\n\n    try\n    {\n        Host.Init(_T(GAME_MODS));\n        Host.Execute();\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_T(\"Unhandled exception - \"), NO_THROW);\n        K2System.Error(ex.GetMsg());\n    }\n    \n    Host.Shutdown();\n    exit(0);\n}\n\n- (void)applicationDidBecomeActive:(NSNotification*)aNotification\n{\n    K2System.SetFocus(true);\n}\n\n- (void)applicationDidResignActive:(NSNotification*)aNotification\n{\n    K2System.SetFocus(false);\n}\n\n- (void)applicationWillHide:(NSNotification*)aNotification\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win respondsToSelector:NSSelectorFromString(@\"willHide:\")])\n            [win performSelector:NSSelectorFromString(@\"willHide:\") withObject:aNotification];\n    }\n}\n\n- (void)applicationDidUnhide:(NSNotification *)aNotification\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win respondsToSelector:NSSelectorFromString(@\"didUnhide:\")])\n            [win performSelector:NSSelectorFromString(@\"didUnhide:\") withObject:aNotification];\n    }\n}\n\n\n- (BOOL)validateMenuItem:(NSMenuItem*)item\n{\n    BOOL enable = [self respondsToSelector:[item action]];\n    \n    if (([item action] == @selector(launchEditor:) || [item action] == @selector(launchModelviewer:))\n        && (Host.HasClient() || Host.HasServer()))\n        enable = NO;\n    \n    return enable;\n}\n\n- (void)toggleFullscreen:(id)sender\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win && [win isMiniaturized])\n        [win deminiaturize:nil];\n    vid_fullscreen = !vid_fullscreen;\n    Console.Execute(_T(\"VidReset\"));\n}\n\n- (void)minimize:(id)sender\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win isMiniaturized])\n            [win deminiaturize:nil];\n        else\n            [win miniaturize:nil];\n    }\n}\n\n- (void)quit:(id)sender\n{\n    Console.Execute(_T(\"Quit\"));\n}\n@end\n\n\nstatic void signal_handler_quit(int signal, siginfo_t* info, void* context)\n{\n    static bool quit_handled = false;\n    if (!quit_handled)\n    {\n        quit_handled = true;\n        Console.Execute(_T(\"quit\"));\n    }\n}\n\n\nint main(int argc, char *argv[])\n{\n    struct sigaction act {};\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_SIGINFO;\n    act.sa_sigaction = signal_handler_quit;\n    sigaction(SIGHUP, &act, nullptr);\n    sigaction(SIGINT, &act, nullptr);\n    sigaction(SIGQUIT, &act, nullptr);\n    sigaction(SIGTERM, &act, nullptr);\n    signal(SIGPIPE, SIG_IGN);\n    // not handling fatal signals, as apple's default crash logging is sufficient\n    \n    // transform it to a gui application & bring it to the front\n    ProcessSerialNumber psn = { 0, kCurrentProcess };\n    TransformProcessType(&psn, kProcessTransformToForegroundApplication);\n#if TKTK  // SetFrontProcess is deprecated\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n    SetFrontProcess(&psn);\n#pragma clang diagnostic pop\n#else\n    int processID = [[NSProcessInfo processInfo] processIdentifier];\n    NSRunningApplication* app = [NSRunningApplication runningApplicationWithProcessIdentifier: processID];\n    [app activateWithOptions: NSApplicationActivateAllWindows];\n#endif\n    \n    #if TKTK\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n    [NSApplication sharedApplication];\n    [NSApp setDelegate:[[AppDelegate alloc] init]];\n    [NSApp run];\n    [pool release];\n    #else\n    @autoreleasepool {\n        NSApplication *pApplication = [NSApplication sharedApplication];\n        AppDelegate *delegate = [AppDelegate new];\n        [pApplication setDelegate:delegate];\n        [pApplication run];\n    }\n    #endif\n    \n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/shell/main_osx.mm b/src/shell/main_osx.mm
--- a/src/shell/main_osx.mm	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/shell/main_osx.mm	(date 1685007426838)
@@ -234,3 +234,108 @@
     
     return 0;
 }
+
+
+/*====================
+  FtoA(CGFloat)
+  ====================*/
+tstring  FtoA(CGFloat f, int flags = FMT_NONE, int width = 0, int minPrecision = 0, int maxPrecision = XTOA_DEFAULT_FLOAT_PRECISION)
+{
+    tstring s;
+    FormatFloat(f, flags, width, minPrecision, maxPrecision, s);
+    return s;
+}
+
+/*====================
+  CConsoleStream::operator<<(const NSString*)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const NSString* it)
+{
+    self << [it UTF8String];
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGPoint&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGPoint& pt)
+{
+    self << _T("");
+    self << _T("x=") << FtoA(pt.x);
+    self << _T(", ");
+    self << _T("y=") << FtoA(pt.y);
+    self << _T("");
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGSize&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGSize& it)
+{
+    self << NSStringFromSize(it);
+//    self << _T("width=") << FtoA(it.width);
+//    self << _T(", ");
+//    self << _T("height=") << FtoA(it.height);
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGRect&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGRect& it)
+{
+    self << NSStringFromRect(it);
+    // self << it.origin << _T(", ") << it.size;
+    return self;
+}
+
+/*====================
+  GetWindowFrame
+  ====================*/
+NSRect GetWindowFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [window frame];
+}
+
+/*====================
+  GetWindowFrameForContent
+  ====================*/
+NSRect GetWindowContentFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [window contentRectForFrameRect:[window frame]];
+}
+
+/*====================
+  GetTitlebarHeight
+  ====================*/
+CGFloat GetTitlebarHeight(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return GetWindowFrame(window).size.height - GetWindowContentFrame(window).size.height;
+}
+
+/*====================
+  GetScreenVisibleFrame
+  ====================*/
+NSRect GetScreenVisibleFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [[window screen] visibleFrame];
+}
+
+CMD(WindowOuterRect)
+{
+    Console.Std << GetWindowFrame() << newl;
+    return true;
+}
+
+CMD(WindowInnerRect)
+{
+    Console.Std << GetWindowContentFrame() << newl;
+    return true;
+}
+
+CMD(ScreenVisibleRect)
+{
+    Console.Std << GetScreenVisibleFrame() << newl;
+    return true;
+}
\ No newline at end of file
Index: src/k2/c_anim.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_anim.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_anim.h\"\n#include \"c_skeleton.h\"\n#include \"c_k2model.h\"\n#include \"c_clip.h\"\n#include \"c_model.h\"\n#include \"c_resourcemanager.h\"\n//=============================================================================\n\n/*====================\n  CAnim::~CAnim\n  ====================*/\nCAnim::~CAnim()\n{\n    K2_DELETE_ARRAY(m_ppMotions);\n\n    g_ResourceManager.RemoveResourceWatcher(this, m_hClip);\n}\n\n\n/*====================\n  CAnim::CAnim\n  ====================*/\nCAnim::CAnim\n(\n    CK2Model *pModel,\n    uint uiIndex,\n    tstring sName,\n    const tstring &sClip,\n    int iStartFrame,\n    int iNumFrames,\n    int iLoopbackFrame,\n    bool bLoop,\n    float fFps,\n    int iNumLoopFrames,\n    int iBlendTime,\n    bool bLock,\n    int iMinStartFrame,\n    int iMaxStartFrame,\n    uint uiIgnoreFlags\n) :\nIResourceWatcher(),\nm_uiIndex(uiIndex),\nm_sName(std::move(sName)),\nm_ppMotions(nullptr),\nm_iStartFrame(iStartFrame),\nm_iNumFrames(iNumFrames),\nm_iLoopbackFrame(iLoopbackFrame),\nm_bLoop(bLoop),\nm_fFps(fFps),\nm_iMSperFrame(MAX(INT_FLOOR(1000.0f / fFps), 1)),\nm_iNumLoopFrames(iNumLoopFrames),\nm_uiBlendTime(iBlendTime),\nm_bLock(bLock),\nm_iMinStartFrame(iMinStartFrame),\nm_iMaxStartFrame(iMaxStartFrame),\nm_pModel(pModel),\nm_iStartFrameDef(iStartFrame),\nm_iNumFramesDef(iNumFrames),\nm_iLoopbackFrameDef(iLoopbackFrame),\nm_iMinStartFrameDef(iMinStartFrame),\nm_iMaxStartFrameDef(iMaxStartFrame)\n{\n    m_hClip = g_ResourceManager.Register(sClip, RES_CLIP, uiIgnoreFlags);\n\n    g_ResourceManager.AddResourceWatcher(this, m_hClip);\n\n    CAnim::Rebuild(m_hClip);\n}\n\n\n/*====================\n  CAnim::CheckEvents\n\n  Check for events in the range [time0, time1)\n  ====================*/\nvoid    CAnim::CheckEvents(CSkeleton *pSkeleton, int iTime0, int iTime1, int iChannel)\n{\n    if (m_vFrameEvents.empty() || iTime0 >= iTime1)\n        return;\n\n    if (m_bLoop)\n    {\n        int iLoopTime(m_iNumFrames * m_iMSperFrame);\n        int iLoopLength(m_iNumLoopFrames * m_iMSperFrame);\n\n        int iStartLoop(MAX((iTime0 - iLoopTime < 0) ? 0 : (iTime0 - iLoopTime) / iLoopLength + 1, 0));\n        int iEndLoop(MAX((iTime1 - iLoopTime < 0) ? 1 : (iTime1 - iLoopTime) / iLoopLength + 2, 0));\n\n        if (iEndLoop - iStartLoop > 2)\n        {\n            iStartLoop = iEndLoop - 2;\n            //Console.Warn << \"Large number of loops in CAnim::CheckEvents\" << newl;\n        }\n\n        for (int iLoop(iStartLoop); iLoop < iEndLoop; ++iLoop)\n        {\n            if (iLoop == 0)\n            {\n                for (vector<SAnimEvent>::iterator it(m_vFrameEvents.begin()); it != m_vFrameEvents.end(); ++it)\n                {\n                    int iFrameTime(it->iFrame * m_iMSperFrame);\n\n                    if (iFrameTime >= iTime0 && iFrameTime < iTime1)\n                        pSkeleton->AddEvent(it->sCommand, iFrameTime - iTime1);\n                }\n            }\n            else\n            {\n                // Calculate time0 and time1 relative to the current loop\n                int iLocalTime0((iTime0 - iLoopTime) - iLoopLength * (iLoop - 1));\n                int iLocalTime1((iTime1 - iLoopTime) - iLoopLength * (iLoop - 1));\n\n                for (vector<SAnimEvent>::iterator it(m_vFrameEvents.begin()); it != m_vFrameEvents.end(); ++it)\n                {\n                    if (it->iFrame < (m_iLoopbackFrame - m_iStartFrame))\n                        continue;\n\n                    int iFrameTime((it->iFrame - (m_iLoopbackFrame - m_iStartFrame)) * m_iMSperFrame);\n\n                    if (iFrameTime >= iLocalTime0 && iFrameTime < iLocalTime1)\n                        pSkeleton->AddEvent(it->sCommand, iFrameTime - iLocalTime1);\n                }\n            }\n        }\n    }\n    else\n    {\n        for (vector<SAnimEvent>::iterator it(m_vFrameEvents.begin()); it != m_vFrameEvents.end(); ++it)\n        {\n            int iFrameTime(it->iFrame * m_iMSperFrame);\n\n            if (iFrameTime >= iTime0 && iFrameTime < iTime1)\n                pSkeleton->AddEvent(it->sCommand, iFrameTime - iTime1);\n        }\n    }\n}\n\n\n/*====================\n  CAnim::AddFrameEvent\n  ====================*/\nvoid    CAnim::AddFrameEvent(int iFrame, const tstring &sCommand)\n{\n    m_vFrameEvents.push_back(SAnimEvent(iFrame, sCommand));\n}\n\n\n/*====================\n  CAnim::AddStartEvent\n  ====================*/\nvoid    CAnim::AddStartEvent(const tstring &sCommand)\n{\n    m_vStartEvents.push_back(sCommand);\n}\n\n\n/*====================\n  CAnim::AddEndEvent\n  ====================*/\nvoid    CAnim::AddEndEvent(const tstring &sCommand)\n{\n    m_vEndEvents.push_back(sCommand);\n}\n\n\n/*====================\n  CAnim::Rebuild\n  ====================*/\nvoid    CAnim::Rebuild(ResHandle hResource)\n{\n    PROFILE(\"CAnim::Rebuild\");\n\n    if (m_ppMotions)\n    {\n        K2_DELETE_ARRAY(m_ppMotions);\n        m_ppMotions = nullptr;\n    }\n\n    m_iStartFrame = m_iStartFrameDef;\n    m_iNumFrames = m_iNumFramesDef;\n    m_iLoopbackFrame = m_iLoopbackFrameDef;\n    m_iMinStartFrame = m_iMinStartFrameDef;\n    m_iMaxStartFrame = m_iMaxStartFrameDef;\n\n    // Set up pointers to bone motions\n    if (m_pModel->GetNumBones() > 0)\n        m_ppMotions = K2_NEW_ARRAY(ctx_Models,  SBoneMotion*, m_pModel->GetNumBones());\n\n    CClip *pClip(g_ResourceManager.GetClip(m_hClip));\n    if (pClip == nullptr)\n    {\n        for (uint n(0); n < m_pModel->GetNumBones(); ++n)\n            m_ppMotions[n] = nullptr;\n\n        // Fix up the frames\n        m_iStartFrame = 0;\n        m_iNumFrames = 1;\n        return;\n    }\n\n    for (uint n(0); n < m_pModel->GetNumBones(); ++n)\n        m_ppMotions[n] = nullptr;\n\n    for (int i = 0; i < pClip->GetNumMotions(); ++i)\n    {\n        // Assign the bone to this motion\n        uint uiBone(m_pModel->GetBoneIndex(pClip->GetBoneMotion(i)->sBoneName));\n\n        if (uiBone != INVALID_BONE)\n            m_ppMotions[uiBone] = pClip->GetBoneMotion(i);\n    }\n\n    // Fix up the frames\n    if (m_iStartFrame == 0 && m_iNumFrames == 0)\n        m_iNumFrames = pClip->GetNumFrames();\n    else if (m_iNumFrames == -1)\n        m_iNumFrames = pClip->GetNumFrames() - m_iStartFrame;\n    else if (m_iStartFrame + m_iNumFrames > pClip->GetNumFrames())\n        m_iNumFrames = pClip->GetNumFrames() - m_iStartFrame;\n    \n    if (m_iNumFrames <= 0)\n        m_iNumFrames = 1;\n\n    if (m_bLoop)\n    {\n        if (m_iLoopbackFrame == -1)\n            m_iLoopbackFrame = m_iStartFrame + m_iNumFrames - 1;\n\n        m_iLoopbackFrame = CLAMP(m_iLoopbackFrame, m_iStartFrame, m_iStartFrame + m_iNumFrames - 1);\n        m_iNumLoopFrames = m_iStartFrame + m_iNumFrames - m_iLoopbackFrame;\n    }\n\n    if (m_iMinStartFrame == -1)\n        m_iMinStartFrame = m_iStartFrame + m_iNumFrames - 1;\n\n    m_iMinStartFrame = CLAMP(m_iMinStartFrame, m_iStartFrame, m_iStartFrame + m_iNumFrames - 1);\n\n    if (m_iMaxStartFrame == -1)\n        m_iMaxStartFrame = m_iStartFrame + m_iNumFrames - 1;\n\n    m_iMaxStartFrame = CLAMP(m_iMaxStartFrame, m_iMinStartFrame, m_iStartFrame + m_iNumFrames - 1);\n}\n\n\n/*====================\n  CAnim::ComputeAnimFrame\n\n  computes loframe, hiframe, and lerp amounts based on a CAnim structure and a given time\n  non looping animations will freeze on their last frame\n  looping animations will loop back to the loopbackframe specified in the anim struct\n  time is specified in milliseconds\n  ====================*/\nbool    CAnim::ComputeAnimFrame(int iTime, int &iLoFrame, int &iHiFrame, float &fLerpAmt, uint uiForceLength)\n{\n    int iMsPerFrame(m_iMSperFrame);\n    if (uiForceLength != 0)\n        iMsPerFrame = uiForceLength / m_iNumFrames;\n    if (iMsPerFrame == 0)\n        iMsPerFrame = 1;\n\n    if (iTime < 0)\n    {\n        iLoFrame = 0;\n        iHiFrame = 1;\n        fLerpAmt = 0.0f;\n\n        return true;\n    }\n\n    int iFrame(iTime / iMsPerFrame);\n\n    if (iFrame >= m_iNumFrames - 1)\n    {\n        if (!m_bLoop)\n        {\n            iLoFrame = m_iStartFrame + m_iNumFrames - 1;\n            iHiFrame = m_iStartFrame + m_iNumFrames - 1;\n            fLerpAmt = 0.0f;\n            return false;\n        }\n        else\n        {\n            iLoFrame = ((iFrame - (m_iLoopbackFrame - m_iStartFrame)) % m_iNumLoopFrames) + m_iLoopbackFrame;\n            iHiFrame = ((iFrame - (m_iLoopbackFrame - m_iStartFrame) + 1) % m_iNumLoopFrames) + m_iLoopbackFrame;\n\n            int iTimeLo(iFrame * iMsPerFrame);\n            fLerpAmt = (iTime - iTimeLo) / float(iMsPerFrame);\n\n            return true;\n        }\n    }\n\n    iLoFrame = (iFrame % m_iNumFrames) + m_iStartFrame;\n    iHiFrame = ((iFrame + 1) % m_iNumFrames) + m_iStartFrame;\n\n    int iTimeLo(iFrame * iMsPerFrame);\n    fLerpAmt = (iTime - iTimeLo) / float(iMsPerFrame);\n\n    return true;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_anim.cpp b/src/k2/c_anim.cpp
--- a/src/k2/c_anim.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/c_anim.cpp	(date 1685009969569)
@@ -22,8 +22,6 @@
 CAnim::~CAnim()
 {
     K2_DELETE_ARRAY(m_ppMotions);
-
-    g_ResourceManager.RemoveResourceWatcher(this, m_hClip);
 }
 
 
Index: src/k2/c_effectthread.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2006 S2 Games\n// c_effectthread.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_effectthread.h\"\n#include \"i_effectcmd.h\"\n#include \"c_particlesystem.h\"\n#include \"c_effect.h\"\n#include \"c_skeleton.h\"\n#include \"c_model.h\"\n#include \"c_k2model.h\"\n#include \"c_mesh.h\"\n#include \"c_camera.h\"\n#include \"c_resourcemanager.h\"\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nCVAR_INTF   (efx_activeThreads,     0,      CVAR_READONLY | CVAR_DONTSAVE);\n//=============================================================================\n\n\n/*====================\n  CEffectThread::~CEffectThread\n  ====================*/\nCEffectThread::~CEffectThread()\n{\n    for (InstanceMap::iterator itInstance(m_mapInstances.begin()); itInstance != m_mapInstances.end(); ++itInstance)\n        K2_DELETE(itInstance->second);\n\n    // m_vCmdBuffer is only populated in the effect thread definition instance\n    for (EffectCmdBuffer::iterator itCmd(m_vCmdBuffer.begin()); itCmd != m_vCmdBuffer.end(); ++itCmd)\n        K2_DELETE(*itCmd);\n\n    g_ResourceManager.RemoveResourceWatcher(this, m_hEffect);\n\n    if (m_uiStartTime != 0xffffffff)\n        --efx_activeThreads;\n}\n\n\n/*====================\n  CEffectThread::CEffectThread\n\n  Allocated effect thread definition\n  ====================*/\nCEffectThread::CEffectThread(CEffect *pEffect) :\nm_pEffect(pEffect),\nm_hEffect(INVALID_RESOURCE),\nm_uiStartTime(0xffffffff),\nm_pvCmdBuffer(&m_vCmdBuffer),\nm_pSourceSkeleton(nullptr),\nm_pTargetSkeleton(nullptr)\n{\n    /*      DO NOT DO THIS -- the pEffect OWNS us, we are not dependent on it! \n    m_pEffect->AddResourceWatcher(this);\n    */\n\n    m_itCurrentCmd = m_vCmdBuffer.end();\n}\n\n\n/*====================\n  CEffectThread::CEffectThread\n  ====================*/\nCEffectThread::CEffectThread(uint uiStartTime, const CEffectThread &etSettings) :\nm_pEffect(etSettings.m_pEffect),\nm_hEffect(etSettings.m_pEffect->GetHandle()),\nm_uiStartTime(uiStartTime),\nm_uiLastUpdateTime(INVALID_TIME),\nm_uiWaitTime(0),\nm_pvCmdBuffer(&etSettings.m_vCmdBuffer),\nm_itStartCmd(etSettings.m_itCurrentCmd),\nm_itCurrentCmd(etSettings.m_itCurrentCmd),\n\nm_bActive(false),\nm_bExpire(false),\n\nm_pCamera(nullptr),\nm_v3CameraOffset(V3_ZERO),\nm_v3CameraAngleOffset(V3_ZERO),\n\nm_uiCameraShakeTime(0),\nm_uiCameraShakeDuration(0),\nm_fCameraShakeFrequency(0.0f),\nm_v3CameraShake(V3_ZERO),\n\nm_uiCameraKickTime(INVALID_TIME),\nm_fCameraKickHalfLife(0.0f),\nm_v3CameraKickAngles(V3_ZERO),\nm_v3CameraKickPosition(V3_ZERO),\n\nm_bActiveOverlay(false),\nm_uiOverlayStartTime(0),\nm_uiOverlayDuration(0),\nm_v4OverlayColor(V4_ZERO),\nm_hOverlayMaterial(INVALID_RESOURCE),\n\nm_pSourceSkeleton(nullptr),\nm_pSourceModel(nullptr),\nm_v3SourcePos(CVec3f(0.0f, 0.0f, 0.0f)),\nm_aSourceAxis(),\nm_fSourceScale(1.0f),\nm_fSourceEffectScale(1.0f),\nm_bSourceVisibility(true),\n\nm_pTargetSkeleton(nullptr),\nm_pTargetModel(nullptr),\nm_v3TargetPos(CVec3f(0.0f, 0.0f, 0.0f)),\nm_aTargetAxis(),\nm_fTargetScale(1.0f),\nm_fTargetEffectScale(1.0f),\nm_bTargetVisibility(true),\nm_bCustomVisibility(true),\n\nm_v3Color(1.0f, 1.0f, 1.0f)\n{\n    g_ResourceManager.AddResourceWatcher(this, m_hEffect);\n\n    ++efx_activeThreads;\n}\n\n\n/*====================\n  CEffectThread::Rebuild\n  ====================*/\nvoid    CEffectThread::Rebuild(ResHandle hResource)\n{\n    for (InstanceMap::iterator it(m_mapInstances.begin()); it != m_mapInstances.end(); ++it)\n        K2_DELETE(it->second);\n\n    m_mapInstances.clear();\n\n    assert(m_hEffect != INVALID_RESOURCE);\n    if (m_hEffect != INVALID_RESOURCE)\n        m_hEffect = hResource;\n\n    m_pEffect = g_ResourceManager.GetEffect(hResource);\n\n    if (!m_pEffect || !m_pEffect->GetEffectThread())\n    {\n        m_pvCmdBuffer = nullptr;\n        return;\n    }\n\n    const CEffectThread &etSettings(*m_pEffect->GetEffectThread());\n\n    m_pvCmdBuffer = &etSettings.m_vCmdBuffer;\n    m_itCurrentCmd = etSettings.m_itCurrentCmd;\n}\n\n\n/*====================\n  CEffectThread::AddCmd\n  ====================*/\nvoid    CEffectThread::AddCmd(IEffectCmd *pCmd)\n{\n    m_vCmdBuffer.push_back(pCmd);\n    m_itCurrentCmd = m_vCmdBuffer.begin();\n}\n\n\n/*====================\n  CEffectThread::Execute\n\n  true is returned if the thread finishes, otherwise false (on a pause or such)\n  ====================*/\nbool    CEffectThread::Execute(uint uiMilliseconds)\n{\n    if (!m_pvCmdBuffer)\n    {\n        // if the effect has been unregistered, then pause until it's been reloaded.\n        if (m_hEffect != INVALID_RESOURCE && g_ResourceManager.Get(m_hEffect) == nullptr)\n            return false;\n\n        return true;\n    }\n\n    if (m_uiLastUpdateTime == INVALID_TIME)\n    {\n        if (uiMilliseconds < m_uiStartTime)\n            return false;\n        else\n            m_uiLastUpdateTime = uiMilliseconds;\n    }\n\n    if (uiMilliseconds < m_uiLastUpdateTime)\n    {\n        if (GetEffect() != nullptr)\n            Console.Dev << _T(\"Rewinding effect \") << GetEffect()->GetPath() << _T(\" to \") << uiMilliseconds << _T(\" milliseconds\") << newl;\n        else\n            Console.Dev << _T(\"Rewinding unknown effect to \") << uiMilliseconds << _T(\" milliseconds\") << newl;\n\n        if (Rewind(uiMilliseconds))\n            return true;\n    }\n\n    uint uiDeltaTime(uiMilliseconds > m_uiLastUpdateTime ? uiMilliseconds - m_uiLastUpdateTime : 0);\n\n    if (m_uiWaitTime > 0)\n    {\n        if (uiDeltaTime > m_uiWaitTime)\n        {\n            uiDeltaTime -= m_uiWaitTime;\n            m_uiWaitTime = 0;\n        }\n        else if (uiDeltaTime > 0)\n        {\n            m_uiWaitTime -= uiDeltaTime;\n        }\n    }\n\n    if (m_uiWaitTime == 0)\n    {\n        if (m_itCurrentCmd == m_pvCmdBuffer->end())\n            return true;\n\n        while (m_itCurrentCmd != m_pvCmdBuffer->end() && (*m_itCurrentCmd)->Execute(this, uiMilliseconds))\n        {\n            ++m_itCurrentCmd;\n\n            if (m_uiWaitTime > 0)\n                break;\n        }\n    }\n\n    // Update camera effects\n    m_v3CameraOffset.Clear();\n    m_v3CameraAngleOffset.Clear();\n\n    UpdateCameraShake(uiMilliseconds);\n    UpdateCameraKick(uiMilliseconds);\n    UpdateOverlay(uiMilliseconds);\n\n    if (uiMilliseconds > m_uiLastUpdateTime)\n        m_uiLastUpdateTime = uiMilliseconds;\n\n    return (m_itCurrentCmd == m_pvCmdBuffer->end() && m_uiWaitTime == 0);\n}\n\n\n/*====================\n  CEffectThread::Cleanup\n\n  delete dead particle system instances\n  ====================*/\nvoid    CEffectThread::Cleanup()\n{\n    InstanceMap::iterator it(m_mapInstances.begin());\n    while (it != m_mapInstances.end())\n    {\n        if (it->second->IsDead())\n        {\n            K2_DELETE(it->second);\n            STL_ERASE(m_mapInstances, it);\n        }\n        else\n        {\n            ++it;\n        }\n    }\n}\n\n\n/*====================\n  CEffectThread::AddInstance\n  ====================*/\nvoid    CEffectThread::AddInstance(const tstring &sName, IEffectInstance *pParticleSystem)\n{\n    if (m_bExpire)\n    {\n        K2_DELETE(pParticleSystem);\n        return;\n    }\n\n    InstanceMap::iterator findit(m_mapInstances.find(sName));\n\n    if (findit != m_mapInstances.end())\n    {\n        K2_DELETE(findit->second);\n        m_mapInstances.erase(findit);\n    }\n\n    m_mapInstances[sName] = pParticleSystem;\n}\n\n\n/*====================\n  CEffectThread::GetInstance\n  ====================*/\nIEffectInstance*    CEffectThread::GetInstance(const tstring &sName)\n{\n    InstanceMap::iterator findit(m_mapInstances.find(sName));\n\n    if (findit != m_mapInstances.end())\n        return findit->second;\n    else\n        return nullptr;\n}\n\n\n/*====================\n  CEffectThread::GetBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetBonePosition(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime)\n{\n    if (pSkeleton)\n    {\n        uint uiBone(pSkeleton->GetBone(sBone));\n\n        if (uiBone != INVALID_BONE)\n            return pSkeleton->GetBonePose(uiBone, uiTime);\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetBoneAxisPos(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    try\n    {\n        if (pSkeleton)\n        {\n            uint uiBone(pSkeleton->GetBone(sBone));\n\n            if (uiBone != INVALID_BONE)\n            {\n                pSkeleton->GetBonePoseAxisPos(uiBone, uiTime, aOutAxis, v3OutPos);\n                return;\n            }\n        }\n\n        aOutAxis = CAxis(0.0f, 0.0f, 0.0f);\n        v3OutPos = CVec3f(0.0f, 0.0f, 0.0f);\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_T(\"CEffectThread::GetBoneAxisPos() - \"), NO_THROW);\n        return;\n    }\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionOnMesh(CModel *pModel, const tstring &sMesh)\n{\n    if (!pModel)\n        return CVec3f(0.0f, 0.0f, 0.0f);\n\n    IModel *pModelFile(pModel->GetModelFile());\n\n    if (pModelFile && pModelFile->GetType() == MODEL_K2)\n    {\n        CK2Model *pK2Model(static_cast<CK2Model *>(pModelFile));\n\n        CMesh *pMesh(pK2Model->GetMesh(sMesh));\n\n        if (!pMesh || pMesh->numFaces == 0)\n            return CVec3f(0.0f, 0.0f, 0.0f);\n\n        if (pMesh->numFaces == 1)\n        {\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n        else\n        {\n            // Determine cumulative area of the entire mesh\n            // and distribute in vFaceAreas for weighted random\n            // face picking\n            vector<float> &vFaceAreas(pMesh->GetFaceAreas());\n            float fCumArea(pMesh->GetCumArea());\n            if (fCumArea == 0.0f)\n            {\n                vFaceAreas.resize(pMesh->numFaces);\n\n                for (uint uiFace(0); uiFace != pMesh->numFaces; ++uiFace)\n                {\n                    vFaceAreas[uiFace] = fCumArea;\n                    fCumArea += M_AreaOfTriangle(\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][0]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][1]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][2]]));\n                }\n\n                pMesh->SetCumArea(fCumArea);\n            }\n\n            float   fRand(M_Randnum(0.0f, fCumArea));\n\n            // Binary search for the face we just picked\n            uint    ui0(0);\n            uint    ui1(pMesh->numFaces);\n            uint    ui((ui1 - ui0) >> 1);\n\n            while (ui != 0 && ui + 1 != ui1 && (vFaceAreas[ui] > fRand || vFaceAreas[ui + 1] < fRand))\n            {\n                if (vFaceAreas[ui] < fRand)\n                    ui0 = ui;\n                else\n                    ui1 = ui;\n\n                ui = (ui1 + ui0) >> 1;\n            }\n\n            if (ui == pMesh->numFaces)\n                return CVec3f(0.0f, 0.0f, 0.0f);\n\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionOnMesh(CModel *pModel, const tstring &sMesh, const CVec3f &v3Dir)\n{\n    if (!pModel)\n        return CVec3f(0.0f, 0.0f, 0.0f);\n\n    IModel *pModelFile(pModel->GetModelFile());\n\n    if (pModelFile && pModelFile->GetType() == MODEL_K2)\n    {\n        CK2Model *pK2Model(static_cast<CK2Model *>(pModelFile));\n\n        CMesh *pMesh(pK2Model->GetMesh(sMesh));\n\n        if (!pMesh || pMesh->numFaces == 0)\n            return CVec3f(0.0f, 0.0f, 0.0f);\n\n        if (pMesh->numFaces == 1)\n        {\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n        else\n        {\n            // Determine cumulative area of the entire mesh\n            // and distribute in vFaceAreas for weighted random\n            // face picking\n            vector<float> &vFaceAreas(pMesh->GetFaceAreas());\n            float fCumArea(pMesh->GetCumArea());\n            if (fCumArea == 0.0f)\n            {\n                vFaceAreas.resize(pMesh->numFaces);\n\n                for (uint uiFace(0); uiFace != pMesh->numFaces; ++uiFace)\n                {\n                    vFaceAreas[uiFace] = fCumArea;\n                    fCumArea += M_AreaOfTriangle(\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][0]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][1]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][2]]));\n                }\n\n                pMesh->SetCumArea(fCumArea);\n            }\n\n            float   fRand(M_Randnum(0.0f, fCumArea));\n\n            // Binary search for the face we just picked\n            uint    ui0(0);\n            uint    ui1(pMesh->numFaces);\n            uint    ui((ui1 - ui0) >> 1);\n\n            while (ui != 0 && ui + 1 != ui1 && (vFaceAreas[ui] > fRand || vFaceAreas[ui + 1] < fRand))\n            {\n                if (vFaceAreas[ui] < fRand)\n                    ui0 = ui;\n                else\n                    ui1 = ui;\n\n                ui = (ui1 + ui0) >> 1;\n            }\n\n            if (ui == pMesh->numFaces)\n                return CVec3f(numeric_limits<float>::infinity(), numeric_limits<float>::infinity(), numeric_limits<float>::infinity());\n\n            CPlane  plane\n            (\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]),\n                true\n            );\n\n            if (M_Randnum(0.0f, 1.0f) > DotProduct(plane.v3Normal, v3Dir))\n                return CVec3f(numeric_limits<float>::infinity(), numeric_limits<float>::infinity(), numeric_limits<float>::infinity());\n\n\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionWithNormalOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionWithNormalOnMesh(CModel *pModel, const tstring &sMesh, CVec3f &v3Normal)\n{\n    if (!pModel)\n    {\n        v3Normal = CVec3f(0.0f, 0.0f, 1.0f);\n        return CVec3f(0.0f, 0.0f, 0.0f);\n    }\n\n    IModel *pModelFile(pModel->GetModelFile());\n\n    if (pModelFile && pModelFile->GetType() == MODEL_K2)\n    {\n        CK2Model *pK2Model(static_cast<CK2Model *>(pModelFile));\n\n        CMesh *pMesh(pK2Model->GetMesh(sMesh));\n\n        if (!pMesh || pMesh->numFaces == 0)\n        {\n            v3Normal = CVec3f(0.0f, 0.0f, 1.0f);\n            return CVec3f(0.0f, 0.0f, 0.0f);\n        }\n\n        if (pMesh->numFaces == 1)\n        {\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]) - v30);\n\n            CPlane  plane\n            (\n                CVec3_cast(pMesh->verts[pMesh->faceList[0][0]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[0][1]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[0][2]]),\n                true\n            );\n            v3Normal = plane.v3Normal;\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n        else\n        {\n            // Determine cumulative area of the entire mesh\n            // and distribute in vFaceAreas for weighted random\n            // face picking\n            vector<float> &vFaceAreas(pMesh->GetFaceAreas());\n            float fCumArea(pMesh->GetCumArea());\n            if (fCumArea == 0.0f)\n            {\n                vFaceAreas.resize(pMesh->numFaces);\n\n                for (uint uiFace(0); uiFace != pMesh->numFaces; ++uiFace)\n                {\n                    vFaceAreas[uiFace] = fCumArea;\n                    fCumArea += M_AreaOfTriangle(\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][0]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][1]]),\n                            CVec3_cast(pMesh->verts[pMesh->faceList[uiFace][2]]));\n                }\n\n                pMesh->SetCumArea(fCumArea);\n            }\n\n            float   fRand(M_Randnum(0.0f, fCumArea));\n\n            // Binary search for the face we just picked\n            uint    ui0(0);\n            uint    ui1(pMesh->numFaces);\n            uint    ui((ui1 - ui0) >> 1);\n\n            while (ui != 0 && ui + 1 != ui1 && (vFaceAreas[ui] > fRand || vFaceAreas[ui + 1] < fRand))\n            {\n                if (vFaceAreas[ui] < fRand)\n                    ui0 = ui;\n                else\n                    ui1 = ui;\n\n                ui = (ui1 + ui0) >> 1;\n            }\n\n            if (ui == pMesh->numFaces)\n            {\n                v3Normal = CVec3f(0.0f, 0.0f, 1.0f);\n                return CVec3f(0.0f, 0.0f, 0.0f);\n            }\n\n            CPlane  plane\n            (\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]),\n                CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]),\n                true\n            );\n            v3Normal = plane.v3Normal;\n\n            float fA(M_Randnum(0.0f, 1.0f));\n            float fB(M_Randnum(0.0f, 1.0f));\n\n            if (fA + fB > 1.0f)\n            {\n                fA = 1.0f - fA;\n                fB = 1.0f - fB;\n            }\n\n            CVec3f  v30(CVec3_cast(pMesh->verts[pMesh->faceList[ui][0]]));\n            CVec3f  v3A(CVec3_cast(pMesh->verts[pMesh->faceList[ui][1]]) - v30);\n            CVec3f  v3B(CVec3_cast(pMesh->verts[pMesh->faceList[ui][2]]) - v30);\n\n            return v30 + v3A * fA + v3B * fB;\n        }\n    }\n\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetRandomPositionOnSkeleton\n  ====================*/\nCVec3f  CEffectThread::GetRandomPositionOnSkeleton(CSkeleton *pSkeleton)\n{\n    if (!pSkeleton || !pSkeleton->IsValid() || pSkeleton->GetModel() == INVALID_RESOURCE)\n        return CVec3f(numeric_limits<float>::infinity(), numeric_limits<float>::infinity(), numeric_limits<float>::infinity());\n\n    CModel *pModel(g_ResourceManager.GetModel(pSkeleton->GetModel()));\n    CK2Model *pK2Model(static_cast<CK2Model *>(pModel->GetModelFile()));\n\n    // Determine cumulative volume of the entire skeleton\n    // and distribute in vFaceAreas for weighted random\n    // face picking\n    float fCumVolume(0.0f);\n    vector<float>   vBoneVolumes(pSkeleton->GetNumBones());\n\n    for (uint uiBone(0); uiBone != pSkeleton->GetNumBones(); ++uiBone)\n    {\n        vBoneVolumes[uiBone] = fCumVolume;\n\n        CBone *pBone(pK2Model->GetBone(uiBone));\n        if (pBone == nullptr)\n        {\n            Console.Warn << _T(\"CEffectThread::GetRandomPositionOnSkeleton() - Invalid bone\") << newl;\n            continue;\n        }\n\n        if (pBone->GetName() == _T(\"Scene Root\") ||\n            pBone->GetName() == _T(\"Bip01\") ||\n            pBone->GetName()[0] == _T('_'))\n            continue;\n\n        uint uiParent(pBone->GetParentIndex());\n\n        if (uiParent != INVALID_BONE)\n        {\n            CVec3f  v3Start(pSkeleton->GetBoneState(uiBone)->tm_local.pos);\n            CVec3f  v3End(pSkeleton->GetBoneState(uiParent)->tm_local.pos);\n\n            float fLength(Length(v3End - v3Start));\n\n            fCumVolume += fLength * M_PI * (fLength/8) * (fLength/8);\n        }\n    }\n\n    float   fRand(M_Randnum(0.0f, fCumVolume));\n\n    // Binary search for the bone we just picked\n    uint    ui0(0);\n    uint    ui1(pSkeleton->GetNumBones());\n    uint    ui((ui1 - ui0) / 2);\n\n    while (ui != 0 && ui + 1 != ui1 && (vBoneVolumes[ui] > fRand || vBoneVolumes[ui + 1] < fRand))\n    {\n        if (vBoneVolumes[ui] < fRand)\n            ui0 = ui;\n        else\n            ui1 = ui;\n\n        ui = (ui1 + ui0) / 2;\n    }\n\n    if (ui == pSkeleton->GetNumBones())\n        return CVec3f(0.0f, 0.0f, 0.0f);\n\n    CBone *pBone(pK2Model->GetBone(ui));\n    uint uiParent(pBone->GetParentIndex());\n\n    SBoneState *pStart(pSkeleton->GetBoneState(ui));\n    SBoneState *pEnd(pSkeleton->GetBoneState(uiParent));\n\n    if (pStart == nullptr)\n    {\n        Console.Warn << _T(\"CEffectThread::GetRandomPositionOnSkeleton() - Accessing invalid start bone on model \") << pK2Model->GetName() << _T(\", accessing bone: \") << ui << _T(\", model bones: \") << pK2Model->GetNumBones() << _T(\", skeleton bones: \") << pSkeleton->GetNumBones() << newl;\n        return CVec3f(0.0f, 0.0f, 0.0f);\n    }\n\n    if (pEnd == nullptr)\n    {\n        Console.Warn << _T(\"CEffectThread::GetRandomPositionOnSkeleton() - Accessing invalid end bone on model \") << pK2Model->GetName() << _T(\", accessing bone: \") << uiParent << _T(\", model bones: \") << pK2Model->GetNumBones() << _T(\", skeleton bones: \") << pSkeleton->GetNumBones() << newl;\n        return CVec3f(0.0f, 0.0f, 0.0f);\n    }\n\n    CVec3f  v3Start(pSkeleton->GetBoneState(ui)->tm_local.pos);\n    CVec3f  v3End(pSkeleton->GetBoneState(uiParent)->tm_local.pos);\n\n    return CVec3f(LERP(M_Randnum(0.0f, 1.0f), v3Start, v3End));\n}\n\n\n/*====================\n  CEffectThread::GetBoneTransform\n  ====================*/\nmatrix43_t* CEffectThread::GetBoneTransform(CSkeleton *pSkeleton, const tstring &sBone)\n{\n    if (pSkeleton)\n    {\n        uint uiBone(pSkeleton->GetBone(sBone));\n\n        if (uiBone != INVALID_BONE)\n            return &pSkeleton->GetBoneState(pSkeleton->GetBone(sBone))->tm_local;\n    }\n\n    return nullptr;\n}\n\n\n/*====================\n  CEffectThread::GetVisibility\n  ====================*/\nbool    CEffectThread::GetVisibility(CSkeleton *pSkeleton, const tstring &sBone)\n{\n    if (pSkeleton)\n    {\n        uint uiBone(pSkeleton->GetBone(sBone));\n\n        if (uiBone != INVALID_BONE)\n            return pSkeleton->GetBoneState(pSkeleton->GetBone(sBone))->visibility != 0;\n    }\n\n    return false;\n}\n\n\n/*====================\n  CEffectThread::GetSourceBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetSourceBonePosition(const tstring &sBone, uint uiTime)\n{\n    return GetBonePosition(m_pSourceSkeleton, sBone, uiTime);\n}\n\n\n/*====================\n  CEffectThread::GetSourceBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetSourceBoneAxisPos(const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    GetBoneAxisPos(m_pSourceSkeleton, sBone, uiTime, aOutAxis, v3OutPos);\n}\n\n\n/*====================\n  CEffectThread::GetSourceMeshPosition\n  ====================*/\nCVec3f  CEffectThread::GetSourceMeshPosition(const tstring &sMesh)\n{\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionOnMesh(const tstring &sMesh)\n{\n    return GetRandomPositionOnMesh(m_pSourceModel, sMesh);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionOnMesh(const tstring &sMesh, const CVec3f &v3Dir)\n{\n    return GetRandomPositionOnMesh(m_pSourceModel, sMesh, v3Dir);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionWithNormalOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionWithNormalOnMesh(const tstring &sMesh, CVec3f &v3Normal)\n{\n    return GetRandomPositionWithNormalOnMesh(m_pSourceModel, sMesh, v3Normal);\n}\n\n\n/*====================\n  CEffectThread::GetSourceRandomPositionOnSkeleton\n  ====================*/\nCVec3f  CEffectThread::GetSourceRandomPositionOnSkeleton()\n{\n    return GetRandomPositionOnSkeleton(m_pSourceSkeleton);\n}\n\n\n/*====================\n  CEffectThread::GetSourceBoneTransform\n  ====================*/\nmatrix43_t* CEffectThread::GetSourceBoneTransform(const tstring &sBone)\n{\n    return GetBoneTransform(m_pSourceSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::GetSourceVisibility\n  ====================*/\nbool    CEffectThread::GetSourceVisibility(const tstring &sBone)\n{\n    return GetVisibility(m_pSourceSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::SourceTransformPosition\n  ====================*/\nCVec3f  CEffectThread::SourceTransformPosition(const CVec3f &v3Pos)\n{\n    return TransformPoint(v3Pos, m_aSourceAxis, m_v3SourcePos);\n}\n\n\n/*====================\n  CEffectThread::SourceTransformAxis\n  ====================*/\nCAxis   CEffectThread::SourceTransformAxis(const CAxis &aAxis)\n{\n    return CAxis(aAxis * m_aSourceAxis);\n}\n\n\n/*====================\n  CEffectThread::GetTargetBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetTargetBonePosition(const tstring &sBone, uint uiTime)\n{\n    return GetBonePosition(m_pTargetSkeleton, sBone, uiTime);\n}\n\n\n/*====================\n  CEffectThread::GetTargetBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetTargetBoneAxisPos(const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    GetBoneAxisPos(m_pTargetSkeleton, sBone, uiTime, aOutAxis, v3OutPos);\n}\n\n\n/*====================\n  CEffectThread::GetTargetMeshPosition\n  ====================*/\nCVec3f  CEffectThread::GetTargetMeshPosition(const tstring &sMesh)\n{\n    return CVec3f(0.0f, 0.0f, 0.0f);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionOnMesh(const tstring &sMesh)\n{\n    return GetRandomPositionOnMesh(m_pTargetModel, sMesh);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionOnMesh(const tstring &sMesh, const CVec3f &v3Dir)\n{\n    return GetRandomPositionOnMesh(m_pTargetModel, sMesh, v3Dir);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionWithNormalOnMesh\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionWithNormalOnMesh(const tstring &sMesh, CVec3f &v3Normal)\n{\n    return GetRandomPositionWithNormalOnMesh(m_pTargetModel, sMesh, v3Normal);\n}\n\n\n/*====================\n  CEffectThread::GetTargetRandomPositionOnSkeleton\n  ====================*/\nCVec3f  CEffectThread::GetTargetRandomPositionOnSkeleton()\n{\n    return GetRandomPositionOnSkeleton(m_pTargetSkeleton);\n}\n\n\n/*====================\n  CEffectThread::GetTargetBoneTransform\n  ====================*/\nmatrix43_t* CEffectThread::GetTargetBoneTransform(const tstring &sBone)\n{\n    return GetBoneTransform(m_pTargetSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::GetTargetVisibility\n  ====================*/\nbool    CEffectThread::GetTargetVisibility(const tstring &sBone)\n{\n    return GetVisibility(m_pTargetSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::TargetTransformPosition\n  ====================*/\nCVec3f  CEffectThread::TargetTransformPosition(const CVec3f &v3Pos)\n{\n    return TransformPoint(v3Pos, m_aTargetAxis, m_v3TargetPos);\n}\n\n\n/*====================\n  CEffectThread::TargetTransformAxis\n  ====================*/\nCAxis   CEffectThread::TargetTransformAxis(const CAxis &aAxis)\n{\n    return CAxis(aAxis * m_aTargetAxis);\n}\n\n\n/*====================\n  CEffectThread::GetCustomBonePosition\n  ====================*/\nCVec3f  CEffectThread::GetCustomBonePosition(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime)\n{\n    return GetBonePosition(pSkeleton, sBone, uiTime);\n}\n\n\n/*====================\n  CEffectThread::GetCustomVisibility\n  ====================*/\nbool    CEffectThread::GetCustomVisibility(CSkeleton *pSkeleton, const tstring &sBone)\n{\n    return GetVisibility(pSkeleton, sBone);\n}\n\n\n/*====================\n  CEffectThread::GetCustomBoneAxisPos\n  ====================*/\nvoid    CEffectThread::GetCustomBoneAxisPos(CSkeleton *pSkeleton, const tstring &sBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    GetBoneAxisPos(pSkeleton, sBone, uiTime, aOutAxis, v3OutPos);\n}\n\n\n/*====================\n  CEffectThread::IsDeferred\n  ====================*/\nbool    CEffectThread::IsDeferred()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetDeferred();\n}\n\n\n/*====================\n  CEffectThread::IsPersistent\n  ====================*/\nbool    CEffectThread::IsPersistent()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetPersistent();\n}\n\n\n/*====================\n  CEffectThread::IsPausable\n  ====================*/\nbool    CEffectThread::IsPausable()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetPausable();\n}\n\n\n/*====================\n  CEffectThread::GetUseEntityEffectScale\n  ====================*/\nbool    CEffectThread::GetUseEntityEffectScale()\n{\n    if (!m_pEffect)\n        return false;\n    return m_pEffect->GetUseEntityEffectScale();\n}\n\n/*====================\n  CEffectThread::StartCameraShake\n  ====================*/\nvoid    CEffectThread::StartCameraShake(uint uiMilliseconds, float fFalloffStart, float fFalloffEnd, float fFrequency, float fScale, uint uiDuration)\n{\n    if (m_bExpire)\n        return;\n\n    float fDistance(Distance(m_v3SourcePos, m_pCamera->GetOrigin()));\n\n    fScale *= CLAMP(ILERP(fDistance, fFalloffEnd, fFalloffStart), 0.0f, 1.0f);\n\n    // Only override an older shake if this one is stronger\n    if (m_uiCameraShakeTime + m_uiCameraShakeDuration > uiMilliseconds)\n    {\n        if (fScale == 0.0f ||\n            (fScale < m_v3CameraShake.x &&\n            fScale < m_v3CameraShake.y &&\n            fScale < m_v3CameraShake.z))\n            return;\n    }\n\n    m_uiCameraShakeTime = uiMilliseconds;\n    m_uiCameraShakeDuration = uiDuration;\n    m_fCameraShakeFrequency = fFrequency;\n    m_v3CameraShake = CVec3f(fScale, fScale, fScale);\n}\n\n\n/*====================\n  CEffectThread::UpdateCameraShake\n  ====================*/\nvoid    CEffectThread::UpdateCameraShake(uint uiMilliseconds)\n{\n    if (m_uiCameraShakeTime + m_uiCameraShakeDuration <= uiMilliseconds || m_uiCameraShakeTime > uiMilliseconds)\n        return;\n\n    float t(float(uiMilliseconds - m_uiCameraShakeTime) / m_uiCameraShakeDuration);\n\n    CVec3f v3Offset\n    (\n        M_Randnum(-m_v3CameraShake.x, m_v3CameraShake.x) * t,\n        M_Randnum(-m_v3CameraShake.y, m_v3CameraShake.y) * t,\n        M_Randnum(-m_v3CameraShake.z, m_v3CameraShake.z) * t\n    );\n    \n    v3Offset.SetLength(MAX(MAX(m_v3CameraShake.x, m_v3CameraShake.y), m_v3CameraShake.z) * t);\n\n    m_v3CameraOffset += v3Offset;\n}\n\n\n/*====================\n  CEffectThread::StartCameraKick\n  ====================*/\nvoid    CEffectThread::StartCameraKick(uint uiMilliseconds, const CRangef &rfPitch, float fTurn, const CRangef &rfBack, const CRangef &rfUp, const CRangef &rfRight, float fHalfLife)\n{\n    if (m_bExpire)\n        return;\n\n    m_uiCameraKickTime = uiMilliseconds;\n    m_fCameraKickHalfLife = fHalfLife;\n\n    float fRandTurn(M_Randnum(-fTurn, fTurn));\n    m_v3CameraKickAngles = CVec3f(rfPitch, -fRandTurn, fRandTurn);\n    m_v3CameraKickPosition = CVec3f(rfRight, rfUp, -rfBack);\n}\n\n\n/*====================\n  CEffectThread::UpdateCameraKick\n  ====================*/\nvoid    CEffectThread::UpdateCameraKick(uint uiMilliseconds)\n{\n    if (m_uiCameraKickTime == INVALID_TIME || m_uiCameraKickTime > uiMilliseconds)\n        return;\n\n    if (fabs(m_v3CameraKickAngles.x) < 0.01f && fabs(m_v3CameraKickAngles.y) < 0.01f && fabs(m_v3CameraKickAngles.z) < 0.01f &&\n        fabs(m_v3CameraKickPosition.x) < 0.01f && fabs(m_v3CameraKickPosition.y) < 0.01f && fabs(m_v3CameraKickPosition.z) < 0.01f)\n    {\n        m_uiCameraKickTime = INVALID_TIME;\n        return;\n    }\n\n    float fDeltaTime(MsToSec(uiMilliseconds - m_uiCameraKickTime));\n\n    if (fDeltaTime > 0.0f)\n    {\n        m_v3CameraKickAngles = DECAY(m_v3CameraKickAngles, V3_ZERO, m_fCameraKickHalfLife, fDeltaTime);\n        m_v3CameraKickPosition = DECAY(m_v3CameraKickPosition, V3_ZERO, m_fCameraKickHalfLife, fDeltaTime);\n    }\n\n    if (m_pCamera)\n    {\n        m_v3CameraAngleOffset += m_v3CameraKickAngles;\n        m_v3CameraOffset += m_v3CameraKickPosition;\n    }\n    else\n    {\n        m_v3CameraAngleOffset += m_v3CameraKickAngles;\n        m_v3CameraOffset += m_v3CameraKickPosition;\n    }\n\n    m_uiCameraKickTime = uiMilliseconds;\n}\n\n\n/*====================\n  CEffectThread::StartOverlay\n  ====================*/\nvoid    CEffectThread::StartOverlay(uint uiMilliseconds, const CTemporalPropertyv3 &tv3Color,\n                                  const CTemporalPropertyf &tfAlpha, ResHandle hMaterial, uint uiDuration)\n{\n    if (m_bExpire)\n        return;\n\n    m_bActiveOverlay = true;\n    m_uiOverlayStartTime = uiMilliseconds;\n    m_uiOverlayDuration = uiDuration;\n    m_tv3OverlayColor = tv3Color;\n    m_tfOverlayAlpha = tfAlpha;\n    m_hOverlayMaterial = hMaterial;\n}\n\n\n/*====================\n  CEffectThread::UpdateOverlay\n  ====================*/\nvoid    CEffectThread::UpdateOverlay(uint uiMilliseconds)\n{\n    if (m_uiOverlayStartTime + m_uiOverlayDuration <= uiMilliseconds)\n    {\n        m_bActiveOverlay = false;\n        return;\n    }\n\n    if (m_uiOverlayStartTime > uiMilliseconds)\n        return;\n\n    float fLerp(float(uiMilliseconds - m_uiOverlayStartTime) / m_uiOverlayDuration);\n    float fTime(MsToSec(uiMilliseconds - m_uiOverlayStartTime));\n    m_v4OverlayColor = CVec4f(m_tv3OverlayColor.Evaluate(fLerp, fTime), m_tfOverlayAlpha.Evaluate(fLerp, fTime));\n}\n\n\n/*====================\n  CEffectThread::StartCameraShake2\n  ====================*/\nvoid    CEffectThread::StartCameraShake2(uint uiMilliseconds, float fFalloffStart, float fFalloffEnd, float fFrequency, float fScale, uint uiDuration)\n{\n    if (m_bExpire)\n        return;\n\n    float fDistance(Distance(m_v3SourcePos, m_pCamera->GetCenter()));\n\n    fScale *= CLAMP(ILERP(fDistance, fFalloffEnd, fFalloffStart), 0.0f, 1.0f);\n\n    // Only override an older shake if this one is stronger\n    if (m_uiCameraShakeTime + m_uiCameraShakeDuration > uiMilliseconds)\n    {\n        if (fScale == 0.0f ||\n            (fScale < m_v3CameraShake.x &&\n            fScale < m_v3CameraShake.y &&\n            fScale < m_v3CameraShake.z))\n            return;\n    }\n\n    m_uiCameraShakeTime = uiMilliseconds;\n    m_uiCameraShakeDuration = uiDuration;\n    m_fCameraShakeFrequency = fFrequency;\n    m_v3CameraShake = CVec3f(fScale, fScale, fScale);\n}\n\n\n/*====================\n  CEffectThread::Rewind\n\n  Rewind the effect thread to a specific time.\n  Rewinding to before start time will kill the effect,\n  any other time will rebuild the effect and resimulate\n  to the specified time\n  ====================*/\nbool    CEffectThread::Rewind(uint uiMilliseconds)\n{\n    if (uiMilliseconds < m_uiStartTime)\n    {\n        m_itCurrentCmd = m_pvCmdBuffer->end();\n        return true;\n    }\n\n    // Delete all particle system instances\n    InstanceMap::iterator itEnd(m_mapInstances.end());\n    for (InstanceMap::iterator it(m_mapInstances.begin()); it != itEnd; ++it)\n        K2_DELETE(it->second);\n    m_mapInstances.clear();\n\n    m_uiLastUpdateTime = m_uiStartTime;\n    m_itCurrentCmd = m_itStartCmd;\n\n    return false;\n}\n\n\n/*====================\n  CEffectThread::Expire\n  ====================*/\nvoid    CEffectThread::Expire(uint uiMilliseconds)\n{\n    m_bExpire = true;\n\n    InstanceMap::iterator itEnd(m_mapInstances.end());\n    for (InstanceMap::iterator it(m_mapInstances.begin()); it != itEnd; ++it)\n        it->second->Expire(uiMilliseconds);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_effectthread.cpp b/src/k2/c_effectthread.cpp
--- a/src/k2/c_effectthread.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/c_effectthread.cpp	(date 1685007426852)
@@ -39,8 +39,6 @@
     for (EffectCmdBuffer::iterator itCmd(m_vCmdBuffer.begin()); itCmd != m_vCmdBuffer.end(); ++itCmd)
         K2_DELETE(*itCmd);
 
-    g_ResourceManager.RemoveResourceWatcher(this, m_hEffect);
-
     if (m_uiStartTime != 0xffffffff)
         --efx_activeThreads;
 }
Index: src/k2/i_resourcewatcher2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resourcewatcher2.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"i_resourcewatcher2.h\"\n//=============================================================================\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resourcewatcher2.cpp b/src/k2/i_resourcewatcher2.cpp
--- a/src/k2/i_resourcewatcher2.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/i_resourcewatcher2.cpp	(date 1685007426863)
@@ -8,5 +8,47 @@
 //=============================================================================
 #include "k2_common.h"
 
+#include "c_resourcemanager.h"
+
 #include "i_resourcewatcher2.h"
 //=============================================================================
+
+
+/*====================
+  IResourceWatcher::~IResourceWatcher
+  ====================*/
+IResourceWatcher::~IResourceWatcher()
+{
+    auto setResources(m_setWatchingResources); // copy, since RemoveResourceWatcher mutates m_setWatchingResources
+    for (ResHandle hResource : setResources)
+        g_ResourceManager.RemoveResourceWatcher(this, hResource);
+}
+
+
+/*====================
+  IResourceWatcher::HasAddedWatcher
+  ====================*/
+bool IResourceWatcher::HasAddedWatcher(ResHandle hResource) const
+{
+    return m_setWatchingResources.contains(hResource);
+}
+
+
+/*====================
+  IResourceWatcher::MarkHasAddedWatcher
+  ====================*/
+void IResourceWatcher::MarkHasAddedWatcher(ResHandle hResource)
+{
+    if (hResource != INVALID_RESOURCE)
+        m_setWatchingResources.insert(hResource);
+}
+
+
+/*====================
+  IResourceWatcher::ClearHasAddedWatcher
+  ====================*/
+void IResourceWatcher::ClearHasAddedWatcher(ResHandle hResource)
+{
+    if (auto it = m_setWatchingResources.find(hResource); it != m_setWatchingResources.end())
+        m_setWatchingResources.erase(it);
+}
Index: src/k2/i_resourcelibrary.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resourcelibrary.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"i_resourcelibrary.h\"\n#include \"i_resource.h\"\n#include \"i_resourcewatcher2.h\"\n#include \"c_statestring.h\"\n#include \"c_networkresourcemanager.h\"\n#include \"c_eventmanager.h\"\n#include \"c_resourcemanager.h\"\n#include \"c_restorevalue.h\"\n#include \"c_resourceinfo.h\"\n//=============================================================================\n\n//=============================================================================\n// Declarations\n//=============================================================================\nEXTERN_CVAR_STRING(host_vidDriver);\nEXTERN_CVAR_STRING(host_language);\n//=============================================================================\n\n\n/*====================\n  IResourceLibrary::~IResourceLibrary\n  ====================*/\nIResourceLibrary::~IResourceLibrary()\n{\n    for (ResPtrVec::iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n    {\n        if (*it)\n        {\n            // TODO:\n            //(*it)->Free();\n            //delete *it;\n        }\n    }\n\n    CResourceManager::GetInstance()->UnregisterLibrary(m_uiType);\n}\n\n\n/*====================\n  IResourceLibrary::IResourceLibrary\n  ====================*/\nIResourceLibrary::IResourceLibrary(uint uiType, const tstring &sName, const tstring &sTypeName, bool bLoadRaw, ResRegAllocFn fnAlloc) :\nm_sName(sName),\nm_sTypeName(sTypeName),\nm_uiType(uiType),\nm_fnAlloc(fnAlloc),\nm_bLoadRaw(bLoadRaw),\nm_bReplaceResources(false),\nm_llLoadTime(0),\nm_llLoadMemory(0),\nm_llLoadCount(0),\nm_bReloading(false)\n{\n    CResourceManager::GetInstance()->RegisterLibrary(uiType, this);\n}\n\n\n/*====================\n  IResourceLibrary::Register\n  ====================*/\nResHandle   IResourceLibrary::Register(const tstring &sDirtyPath, uint uiIgnoreFlags)\n{\n    IResource *pNewResource(nullptr);\n    ResHandle hReservedHandle(INVALID_RESOURCE);\n\n    tstring sPath(FileManager.SanitizePath(sDirtyPath));\n    tstring sOldDir(FileManager.GetWorkingDirectory());\n\n    // Check for an already registered resource\n    ResHandle hFind(LookUpPath(sPath));\n    if (hFind != INVALID_RESOURCE)\n    {\n        IResource *pOldResource(Get(hFind));\n\n        bool bShouldReload(false);\n        if ((pOldResource->GetIgnoreFlags() ^ uiIgnoreFlags) & ~uiIgnoreFlags)\n            bShouldReload = true;\n\n        if (bShouldReload)\n        {\n            if (!Reload(hFind, uiIgnoreFlags))\n                return INVALID_RESOURCE;\n        }\n\n        CGraphResource::LinkExistingChild(hFind);\n        return hFind;\n    }\n\n    g_ResourceManager.StartResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    CGraphResource cGraphResource;\n    cGraphResource.SetDebugPath(sPath);\n\n    const char *pData(nullptr);\n    uint uiSize(0);\n    CFileHandle hFile;\n\n    tstring sLocalizedPath(sPath);\n    bool bLocalized(true);\n    if (m_bLoadRaw && !sPath.empty() && sPath[0] != _T('$') && sPath[0] != _T('!') && sPath[0] != _T('*') && sPath.find(_CTS(\"%\"), 0) == tstring::npos) // check for virtual resources (like procedural textures)\n    {\n        if (!host_language.empty())\n        {\n            sLocalizedPath = Filename_StripExtension(sLocalizedPath) + _CTS(\"_\") + host_language + _CTS(\".\") + Filename_GetExtension(sLocalizedPath);\n            if (!FileManager.Exists(sLocalizedPath, FILE_READ))\n            {\n                bLocalized = false;\n                sLocalizedPath = sPath;\n            }\n        }\n#if 0\n        if (!hFile.Open(sPath, FILE_READ | FILE_BINARY))\n            EX_WARN(_T(\"Failed to open file\"));\n#else\n        hFile.Open(sLocalizedPath, FILE_READ | FILE_BINARY);\n#endif\n        pData = hFile.GetBuffer(uiSize);\n    }\n\n    try\n    {\n        // Allocate a new resource object\n        if (m_fnAlloc == nullptr)\n            EX_ERROR(_CTS(\"No allocator provided for this resource type\"));\n\n        pNewResource = m_fnAlloc(sPath);\n        if (pNewResource == nullptr)\n            EX_WARN(_CTS(\"Failed to allocate resource\"));\n\n        if (!sPath.empty() && sPath[0] != _T('$') && sPath[0] != _T('!') && sPath[0] != _T('*'))\n            FileManager.SetWorkingDirectory(Filename_GetPath(FileManager.SanitizePath(sPath)));\n\n        if (bLocalized)\n        {\n            pNewResource->AddFlags(RES_FLAG_LOCALIZED);\n            pNewResource->SetLocalizedPath(sLocalizedPath);\n        }\n\n        // Load the resource\n        pNewResource->AddFlags(pNewResource->Load(uiIgnoreFlags, pData, uiSize));\n        const tstring &sName(pNewResource->GetName());\n\n        // Check for a name conflict\n        if (!sName.empty())\n        {\n            if (LookUpName(sName) != INVALID_RESOURCE)\n                EX_ERROR(_CTS(\"Name collision for \") + QuoteStr(sName));\n        }\n    }\n    catch (CException &ex)\n    {\n        cGraphResource.Reset();\n\n        assert(pNewResource);\n        if (pNewResource)\n        {\n            pNewResource->AddFlags(RES_LOAD_FAILED);\n            pNewResource->LoadNull();\n        }\n\n        ex.Process(_CTS(\"IResourceLibrary::Register(\") + sPath + _CTS(\") - \"), NO_THROW);\n    }\n\n    CResourceManager::GetInstance()->EndResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    FileManager.SetWorkingDirectory(sOldDir);\n\n    assert(pNewResource);\n    if (!pNewResource)\n        return INVALID_RESOURCE;\n\n    // assign a handle to the resource.\n    if (hReservedHandle == INVALID_RESOURCE)\n    {\n        // if the path is reserved for a specific handle, use it.\n        PathHandleMap::iterator itFind(m_mapReservedHandles.find(sPath));\n        if (itFind != m_mapReservedHandles.end())\n        {\n            hReservedHandle = itFind->second;\n\n            // this is optional, but since memory is so tight, we should probably do this.\n            m_mapReservedHandles.erase(itFind);\n        }\n        else if (!m_stkAvailableHandles.empty())\n        {\n            // otherwise, try to use any available handle.\n            hReservedHandle = m_stkAvailableHandles.top();\n            m_stkAvailableHandles.pop();\n        }\n        else\n        {\n            // if no handles are available, then allocate a new one.\n            hReservedHandle = (ResHandle)m_vEntries.size();\n            m_vEntries.push_back(nullptr);\n        }\n    }\n    assert(hReservedHandle != INVALID_RESOURCE);\n\n    // Assign this entry a handle and add it to the map\n    ResHandle hIdx(hReservedHandle);\n    m_vEntries[hIdx] = pNewResource;\n    EmbedType(hReservedHandle);\n    if (!pNewResource->GetName().empty())\n        m_mapResNames[pNewResource->GetName()] = hReservedHandle;\n    if (!pNewResource->GetPath().empty())\n        m_mapResPaths[pNewResource->GetPath()] = hReservedHandle;\n    pNewResource->SetHandle(hReservedHandle);\n    pNewResource->PostLoad();\n\n    cGraphResource.SetHandle(hReservedHandle);\n    cGraphResource.Done();\n\n    // notify any watchers that this resource has been registered again.\n    NotifyWatchers(hReservedHandle);\n\n    return hReservedHandle;\n}\n\nResHandle   IResourceLibrary::Register(IResource *pResource, uint uiIgnoreFlags)\n{\n    tstring sOldDir(FileManager.GetWorkingDirectory());\n    ResHandle hReservedHandle(INVALID_RESOURCE);\n\n    ResHandle   hFind(INVALID_RESOURCE);\n\n    assert(!(pResource->GetPath().empty() && pResource->GetName().empty()));\n\n    // Check for an already registered resource\n    // External resources must have a unique name\n    const tstring &sName(pResource->GetName());\n    if (!sName.empty())\n        hFind = LookUpName(sName);\n\n    // Check for an already registered resource\n    // For paths, there can be only one...\n    const tstring &sPath(pResource->GetPath());\n    if (!sPath.empty() && hFind == INVALID_RESOURCE)\n    {\n        hFind = LookUpPath(sPath);\n\n        // Link the new name to the existing resource\n        if (!sName.empty() && hFind != INVALID_RESOURCE)\n            m_mapResNames[sName] = hFind;\n    }\n\n    // Delete the input resource if we already have a resource with this name registered\n    if (hFind != INVALID_RESOURCE)\n    {\n        if (m_bReplaceResources)\n        {\n            Unregister(hFind, UNREG_RESERVE_HANDLE);\n        }\n        else\n        {\n            IResource *pOldResource(Get(hFind));\n            bool bShouldReload(false);\n            if ((pOldResource->GetIgnoreFlags() ^ uiIgnoreFlags) & ~uiIgnoreFlags)\n                bShouldReload = true;\n\n            if (bShouldReload)\n            {\n                if (!Reload(hFind, uiIgnoreFlags))\n                {\n                    SAFE_DELETE(pResource);\n                    return INVALID_RESOURCE;\n                }\n            }\n\n            SAFE_DELETE(pResource);\n            CGraphResource::LinkExistingChild(hFind);\n            return hFind;\n        }\n    }\n\n    if (!sPath.empty() && sPath[0] != _T('$') && sPath[0] != _T('!') && sPath[0] != _T('*'))\n        FileManager.SetWorkingDirectory(Filename_GetPath(FileManager.SanitizePath(sPath)));\n\n    CResourceManager::GetInstance()->StartResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    CGraphResource cGraphResource;\n    cGraphResource.SetDebugPath(sPath);\n\n    try\n    {\n        uint uiResFlags(RES_EXTERNAL);\n\n        // prevent procedural textures from being reloaded.\n        if (!sPath.empty() && sPath[0] == '$')\n            uiResFlags = 0;\n\n        // Load the resource\n        pResource->AddFlags(pResource->Load(uiIgnoreFlags, pResource->GetData(), pResource->GetSize()) | uiResFlags);\n    }\n    catch (CException &ex)\n    {\n        cGraphResource.Reset();\n\n        tstring sPath(pResource->GetPath());\n\n        pResource->AddFlags(RES_LOAD_FAILED | RES_EXTERNAL);\n        pResource->LoadNull();\n\n        ex.Process(_TS(\"IResourceLibrary::Register(\") + sPath + _TS(\") - \"), NO_THROW);\n    }\n\n    CResourceManager::GetInstance()->EndResLoadProfile(m_uiType, K2System.GetTicks(), K2System.GetProcessVirtualMemoryUsage());\n\n    FileManager.SetWorkingDirectory(sOldDir);\n\n    // assign a handle to the resource.\n    if (hReservedHandle == INVALID_RESOURCE)\n    {\n        PathHandleMap::iterator itFind(m_mapReservedHandles.find(sPath));\n        if (itFind != m_mapReservedHandles.end())\n        {\n            // if the path is reserved for a specific handle, use it.\n            hReservedHandle = itFind->second;\n\n            // this is optional, but since memory is so tight, we should probably do this.\n            m_mapReservedHandles.erase(itFind);\n        }\n        else if (!m_stkAvailableHandles.empty()) \n        {\n            // otherwise, try to use any available handle.\n            hReservedHandle = m_stkAvailableHandles.top();\n            m_stkAvailableHandles.pop();\n        }\n        else\n        {\n            // if no handles are available, then allocate a new one.\n            hReservedHandle = (ResHandle)m_vEntries.size();\n            m_vEntries.push_back(nullptr);\n        }\n    }\n    assert(hReservedHandle != INVALID_RESOURCE);\n\n    // Assign this entry a handle and add it to the map\n    ResHandle hIdx(hReservedHandle);\n    m_vEntries[hIdx] = pResource;\n    EmbedType(hReservedHandle);\n    if (!pResource->GetName().empty())\n        m_mapResNames[pResource->GetName()] = hReservedHandle;\n    if (!pResource->GetPath().empty())\n        m_mapResPaths[pResource->GetPath()] = hReservedHandle;\n    pResource->SetHandle(hReservedHandle);\n    pResource->PostLoad();\n    cGraphResource.SetHandle(hReservedHandle);\n    cGraphResource.Done();\n\n    // notify any watchers that this resource has been registered again.\n    NotifyWatchers(hReservedHandle);\n\n    return hReservedHandle;\n}\n\n\n/*====================\n  IResourceLibrary::Unregister\n  ====================*/\nvoid    IResourceLibrary::Unregister(ResHandle hResource, EUnregisterResource eUnregisterOp)\n{\n    if (GetType(hResource) != m_uiType)\n    {\n        Console.Warn << _T(\"IResourceLibrary::Unregister(\") << hResource << _T(\") - Handle is of wrong type\") << newl;\n        return;\n    }\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n\n    if (hIdx >= m_vEntries.size())\n    {\n        Console.Warn << _T(\"IResourceLibrary::Unregister(\") << hResource << _T(\") - Handle out of range\") << newl;\n        return;\n    }\n\n    g_ResourceInfo.OnResourceUnregistered(hResource);\n\n    IResource* pResource(m_vEntries[hIdx]);\n    assert(pResource != nullptr);\n    if (pResource == nullptr)\n        return;\n\n    ResNameMap::iterator findit;\n\n    if (eUnregisterOp == UNREG_DELETE_HANDLE)\n    {\n        // free the handle for use by any other resource of the same type.\n        m_stkAvailableHandles.push(hIdx);\n\n        // if something was watching this resource, which we just deleted, then this is a very bad thing!\n        bool bHasResourceWatcher(HasResourceWatcher(hResource));\n        assert(!bHasResourceWatcher);\n        if (bHasResourceWatcher)\n            Console.Warn << _T(\"IResourceLibrary::Unregister(\") << hResource << _T(\") - Deleted a resource handle which was being watched!\") << newl;\n    }\n    else\n    {\n        assert(eUnregisterOp == UNREG_RESERVE_HANDLE);\n\n        // reserve the handle for resources with this path only.\n        const tstring &sPath(pResource->GetPath());\n        m_mapReservedHandles[sPath] = hIdx;\n    }\n\n    findit = m_mapResNames.find(pResource->GetName());\n    if (findit != m_mapResNames.end())\n        m_mapResNames.erase(findit);\n\n    findit = m_mapResPaths.find(pResource->GetPath());\n    if (findit != m_mapResPaths.end())\n        m_mapResPaths.erase(findit);\n\n    pResource->Free();\n    SAFE_DELETE(m_vEntries[hIdx]);\n\n    if (!m_bReloading)\n    {\n        // notify the resource watchers that this resource has been unregistered.\n        NotifyWatchers(hResource);\n    }\n}\n\n\n/*====================\n  IResourceLibrary::ReloadByFlag\n  ====================*/\nvoid    IResourceLibrary::ReloadByFlag(int iFlag)\n{\n    for (ResPtrVec::iterator it(m_vEntries.begin()); it != m_vEntries.end(); it++)\n    {\n        if (!*it)\n            continue;\n\n        if ((*it)->HasFlags(iFlag))\n            Reload((*it)->GetHandle(), 0xffffffff);\n    }\n}\n\n\n/*====================\n  IResourceLibrary::Reload\n  ====================*/\nbool    IResourceLibrary::Reload(ResHandle hResource, uint uiIgnoreFlags)\n{\n    IResource *pResource(Get(hResource));\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n\n    // Validate handle\n    if (pResource == nullptr)\n    {\n        Console.Warn << _T(\"Invalid resource handle\") << newl;\n        return false;\n    }\n\n    Console << _T(\"Reloading \");\n    g_ResourceManager.PrintResource(Console.DefaultStream(), pResource);\n    Console << newl;\n            \n    // Save pertinent data\n    tstring sSavedPath(pResource->GetPath());\n    uint uiSavedIgnoreFlags(pResource->GetIgnoreFlags());\n    set<ResHandle>  setDependents(pResource->GetDependents());\n\n    try\n    {\n        CRestoreValue<bool> cSetReloading(m_bReloading, true);\n\n        if (pResource->HasFlags(RES_EXTERNAL))\n        {\n            const tstring &sPath(pResource->GetPath());\n\n            if (!sPath.empty() && sPath[0] == _T('*'))\n                return true;\n\n            // External resources with valid paths set should just Free+Load\n            pResource->Free();\n            g_ResourceInfo.OnResourceUnregistered(hResource);\n            CGraphResource cGraphResource(hResource);\n            pResource->Load(pResource->GetIgnoreFlags() & uiIgnoreFlags, pResource->GetData(), pResource->GetSize());\n        }\n        else\n        {\n            // Reload\n            if (sSavedPath[0] != '$')\n            {\n                g_ResourceManager.Unregister(hResource, UNREG_RESERVE_HANDLE);\n                if (g_ResourceManager.Register(sSavedPath, m_uiType, uiSavedIgnoreFlags & uiIgnoreFlags) != hResource)\n                    EX_ERROR(_T(\"Resource handle changed\"));\n            }\n            pResource = Get(hResource);\n        }\n    }\n    catch (CException &ex)\n    {\n        g_ResourceInfo.OnResourceUnregistered(hResource);\n        CGraphResource cGraphResource(hResource);\n\n        pResource->AddFlags(RES_LOAD_FAILED);\n        pResource->LoadNull();\n\n        ex.Process(_TS(\"IResourceLibrary::Reload(\") + sSavedPath + _TS(\") - \"), NO_THROW);\n    }\n\n    // Handle the dependents\n    for (ResHandle hDependent : setDependents)\n    {\n        IResource *pChildResource(g_ResourceManager.Get(hDependent));\n        if (pChildResource == nullptr)\n        {\n            Console.Warn << _T(\"Couldn't retrieve a dependant resource\") << newl;\n            continue;\n        }\n\n        // If there is no path, a Free()/Load() should handle everything,\n        // otherwise just do a standard Reload\n        if (pChildResource->GetPath().empty())\n        {\n            pChildResource->Free();\n            g_ResourceInfo.OnResourceUnregistered(hResource);\n            CGraphResource cGraphResource(hResource);\n            pChildResource->Load(pChildResource->GetIgnoreFlags(), pChildResource->GetData(), pChildResource->GetSize());\n        }\n        else\n        {\n            g_ResourceManager.Reload(hDependent);\n        }\n\n        pResource->AddDependent(hDependent);\n    }\n\n    // notify the resource watchers that this resource has been reloaded.\n    NotifyWatchers(hResource);\n\n    pResource->Reloaded();\n    return true;\n}\n\n\n/*====================\n  IResourceLibrary::LookUpName\n  ====================*/\nResHandle   IResourceLibrary::LookUpName(const tstring &sName)\n{\n    ResNameMap::iterator findit(m_mapResNames.find(sName));\n    if (findit == m_mapResNames.end())\n        return INVALID_RESOURCE;\n\n    return findit->second;\n}\n\n\n/*====================\n  IResourceLibrary::LookUpPath\n  ====================*/\nResHandle   IResourceLibrary::LookUpPath(const tstring &sPath)\n{\n    if (sPath.empty())\n        return INVALID_RESOURCE;\n\n    ResNameMap::iterator findit(m_mapResPaths.find(FileManager.SanitizePath(sPath)));\n    if (findit == m_mapResPaths.end())\n        return INVALID_RESOURCE;\n\n    return findit->second;\n}\n\n\n/*====================\n  IResourceLibrary::LookUpHandle\n  ====================*/\nIResource*  IResourceLibrary::LookUpHandle(ResHandle hResource)\n{\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            throw CException(_T(\"Handle is of wrong type\"), E_ERROR);\n\n        MaskType(hResource);\n\n        assert(hResource < m_vEntries.size());\n        if (hResource >= m_vEntries.size())\n            return nullptr;\n\n        // resource has been unregistered.\n        if (!m_vEntries[hResource])\n            return nullptr;\n\n        return m_vEntries[hResource];\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary(\") + XtoA(m_uiType) + _T(\")::LookUpHandle(\") + XtoA(hResource, 0, 0, 16) + _T(\") - \"), NO_THROW);\n        return nullptr;\n    }\n}\n\n\n/*====================\n  IResourceLibrary::Get\n  ====================*/\nIResource*  IResourceLibrary::Get(ResHandle hResource)\n{\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            throw CException(_T(\"Handle is of wrong type\"), E_ERROR);\n\n        MaskType(hResource);\n\n        if (hResource >= m_vEntries.size())\n            throw CException(_T(\"Handle out of range\"), E_ERROR);\n\n        if (!m_vEntries[hResource])\n            throw CException(_T(\"Handle has been unregistered\"), E_ERROR);\n\n        return m_vEntries[hResource];\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary(\") + XtoA(m_uiType) + _T(\")::Get(\") + XtoA(hResource, 0, 0, 16) + _T(\") - \"), NO_THROW);\n        return nullptr;\n    }\n}\n\n\n/*====================\n  IResourceLibrary::ReloadAll\n  ====================*/\nvoid    IResourceLibrary::ReloadAll()\n{\n    if (m_uiType == RES_FONTMAP)\n    {\n        for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n            (*it)->Free();\n    }\n\n    if (host_vidDriver.IsModified())\n    {\n        for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n            Reload((*it)->GetHandle(), 0xffffffff);\n    }\n    else if (m_uiType == RES_MODEL)\n    {\n        class CReloadFunctions : public CLoadJob<ResPtrVec>::IFunctions\n        {\n        private:\n            IResourceLibrary*   m_pLib;\n    \n        public:\n            CReloadFunctions(IResourceLibrary *pLib) : m_pLib(pLib) {}\n            virtual ~CReloadFunctions() {}\n            \n            float   Frame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib == nullptr)\n                    return 0.0f;\n                SetTitle(_T(\"Reloading \") + m_pLib->GetName());\n                SetProgress(f);\n                return 0.0f;\n            }\n            \n            float   PostFrame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib != nullptr && *it != nullptr)\n                {\n                    m_pLib->Reload((*it)->GetHandle(), 0xffffffff);\n\n                    g_ResourceManager.PrecacheSkin((*it)->GetHandle(), uint(-1));\n                }\n                ++it;\n                return 1.0f;\n            }\n        };\n        class CReloadFunctions fnReload(this);\n        CLoadJob<ResPtrVec> jobReload(m_vEntries, &fnReload, LOADING_DISPLAY_LOGO);\n        jobReload.Execute(m_vEntries.size());\n    }\n    else\n    {\n        class CReloadFunctions : public CLoadJob<ResPtrVec>::IFunctions\n        {\n        private:\n            IResourceLibrary*   m_pLib;\n    \n        public:\n            CReloadFunctions(IResourceLibrary *pLib) : m_pLib(pLib) {}\n            virtual ~CReloadFunctions() {}\n            \n            float   Frame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib == nullptr)\n                    return 0.0f;\n                SetTitle(_T(\"Reloading \") + m_pLib->GetName());\n                SetProgress(f);\n                return 0.0f;\n            }\n            \n            float   PostFrame(ResPtrVec::iterator &it, float f) const\n            {\n                if (m_pLib != nullptr && *it != nullptr)\n                    m_pLib->Reload((*it)->GetHandle(), 0xffffffff);\n                ++it;\n                return 1.0f;\n            }\n        };\n        class CReloadFunctions fnReload(this);\n        CLoadJob<ResPtrVec> jobReload(m_vEntries, &fnReload, LOADING_DISPLAY_LOGO);\n        jobReload.Execute(m_vEntries.size());\n    }\n}\n\n\n/*====================\n  IResourceLibrary::FreeAll\n  ====================*/\nvoid    IResourceLibrary::FreeAll()\n{\n    // TODO: Make sure this plays nicely with the resource graphing.\n    assert(m_uiType == RES_SAMPLE);\n    for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n        (*it)->Free();\n}\n\n\n/*====================\n  IResourceLibrary::FindResources\n  ====================*/\nuint    IResourceLibrary::FindResources(ResPtrVec &vResults, const tstring &sWildcard)\n{\n    uint uiTotal(0);\n\n    for (ResPtrVec::const_iterator it(m_vEntries.begin()); it != m_vEntries.end(); ++it)\n    {\n        IResource* pResource(*it);\n        if (pResource == nullptr)\n            continue;\n\n        // skip invalid resources.\n        ResHandle hRes(pResource->GetHandle());\n        if (hRes == INVALID_RESOURCE)\n            continue;\n\n        const tstring &sPath(pResource->GetPath());\n        const tstring &sName(pResource->GetName());\n\n        // match the wildcard against the resource path or name.\n        if (!EqualsWildcards(sWildcard, sPath) &&\n            !EqualsWildcards(sWildcard, sName))\n        {\n            continue;\n        }\n\n        vResults.push_back(pResource);\n        ++uiTotal;\n    }\n\n    return uiTotal;\n}\n\n\n/*====================\n  IResourceLibrary::RemoveResourceWatcher\n  ====================*/\nvoid    IResourceLibrary::RemoveResourceWatcher(IResourceWatcher* pWatcher, ResHandle hUnregisterFrom)\n{\n    if (pWatcher == nullptr || hUnregisterFrom == INVALID_RESOURCE)\n        return;\n\n    ResHandle hIdx(hUnregisterFrom);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hUnregisterFrom) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::RemoveResourceWatcher(IResourceWatcher*, \") + XtoA(hUnregisterFrom) + _TS(\") - \"), NO_THROW);\n        return;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    assert(itFind != m_mapWatchers.end());\n    if (itFind == m_mapWatchers.end())\n        return;\n\n    ResourceWatcherSet& setWatchers(itFind->second);\n\n    // if the watcher was already removed, we're done.\n    if (setWatchers.find(pWatcher) == setWatchers.end())\n        return;\n\n    setWatchers.erase(pWatcher);\n\n    assert(pWatcher->HasAddedWatcher());\n    pWatcher->ClearHasAddedWatcher();\n\n    if (setWatchers.empty())\n        m_mapWatchers.erase(itFind);\n}\n\n\n/*====================\n  IResourceLibrary::AddResourceWatcher\n  ====================*/\nvoid    IResourceLibrary::AddResourceWatcher(IResourceWatcher* pWatcher, ResHandle hRegisterWith)\n{\n    if (pWatcher == nullptr || hRegisterWith == INVALID_RESOURCE)\n        return;\n\n    ResHandle hIdx(hRegisterWith);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hRegisterWith) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::AddResourceWatcher(IResourceWatcher*, \") + XtoA(hRegisterWith) + _TS(\") - \"), NO_THROW);\n        return;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    if (itFind == m_mapWatchers.end())\n        itFind = m_mapWatchers.insert(std::make_pair(hIdx, ResourceWatcherSet())).first;\n\n    ResourceWatcherSet& setWatchers(itFind->second);\n\n    // if the watcher was already added, we're done.\n    if (setWatchers.find(pWatcher) != setWatchers.end())\n        return;\n\n    // verify that the dependent hasn't already added a watcher.\n    assert(!pWatcher->HasAddedWatcher());\n    if (pWatcher->HasAddedWatcher())\n        Console.Err << _T(\"PROGRAMMER ERROR: IResourceWatcher has added multiple watchers!\") << newl;\n\n    // register the watcher.\n    pWatcher->MarkHasAddedWatcher();\n    setWatchers.insert(pWatcher);\n}\n\n\n/*====================\n  IResourceLibrary::HasResourceWatcher\n  ====================*/\nbool    IResourceLibrary::HasResourceWatcher(ResHandle hResource)\n{\n    if (hResource == INVALID_RESOURCE)\n        return false;\n\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::HasResourceWatcher(IResourceWatcher*, \") + XtoA(hResource) + _TS(\") - \"), NO_THROW);\n        return false;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    if (itFind == m_mapWatchers.end())\n        return false;\n\n    return true;\n}\n\n\n/*====================\n  IResourceLibrary::NotifyWatchers\n  ====================*/\nuint    IResourceLibrary::NotifyWatchers(ResHandle hResource)\n{\n    if (hResource == INVALID_RESOURCE)\n        return 0;\n\n    ResHandle hIdx(hResource);\n    MaskType(hIdx);\n    try\n    {\n        if (GetType(hResource) != m_uiType)\n            EX_ERROR(_T(\"Handle is of wrong type\"));\n\n        if (hIdx >= m_vEntries.size())\n            EX_ERROR(_T(\"Handle out of range\"));\n    }\n    catch (CException& ex)\n    {\n        ex.Process(_TS(\"IResourceLibrary::HasResourceWatcher(IResourceWatcher*, \") + XtoA(hResource) + _TS(\") - \"), NO_THROW);\n        return 0;\n    }\n\n    ResourceWatcherMap::iterator itFind(m_mapWatchers.find(hIdx));\n    if (itFind == m_mapWatchers.end())\n        return 0;\n\n    uint uiNotifiedCount(0);\n\n    // since the set of watchers could change as they get rebuilt, copy them.\n    ResourceWatcherSet setWatchers(itFind->second);\n    for (ResourceWatcherSet::const_iterator it(setWatchers.begin()); it != setWatchers.end(); ++it)\n    {\n        IResourceWatcher* pWatcher(*it);\n        pWatcher->Rebuild(hResource);\n    }\n\n    return uiNotifiedCount;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resourcelibrary.cpp b/src/k2/i_resourcelibrary.cpp
--- a/src/k2/i_resourcelibrary.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/i_resourcelibrary.cpp	(date 1685007426866)
@@ -806,8 +806,8 @@
 
     setWatchers.erase(pWatcher);
 
-    assert(pWatcher->HasAddedWatcher());
-    pWatcher->ClearHasAddedWatcher();
+    assert(pWatcher->HasAddedWatcher(hUnregisterFrom));
+    pWatcher->ClearHasAddedWatcher(hUnregisterFrom);
 
     if (setWatchers.empty())
         m_mapWatchers.erase(itFind);
@@ -849,12 +849,12 @@
         return;
 
     // verify that the dependent hasn't already added a watcher.
-    assert(!pWatcher->HasAddedWatcher());
-    if (pWatcher->HasAddedWatcher())
+    assert(!pWatcher->HasAddedWatcher(hRegisterWith));
+    if (pWatcher->HasAddedWatcher(hRegisterWith))
         Console.Err << _T("PROGRAMMER ERROR: IResourceWatcher has added multiple watchers!") << newl;
 
     // register the watcher.
-    pWatcher->MarkHasAddedWatcher();
+    pWatcher->MarkHasAddedWatcher(hRegisterWith);
     setWatchers.insert(pWatcher);
 }
 
Index: src/k2/i_resourcewatcher2.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// i_resourcewatcher2.h\n//\n//=============================================================================\n#ifndef __I_RESOURCEWATCHER_H__\n#define __I_RESOURCEWATCHER_H__\n\n//=============================================================================\n// Definitions\n//=============================================================================\nclass IResource;\n//=============================================================================\n\n//=============================================================================\n// IResourceWatcher\n//      ***NOTE***:  BE SURE you call g_ResourceManager.RemoveResourceWatcher(this, m_hResource)\n//      in the destructor of your derived class!\n//=============================================================================\nclass IResourceWatcher\n{\n    friend class IResourceLibrary;\n\n    // internal for IResourceLibrary\nprivate:\n    bool            m_bHasAddedWatcher;\n\n    void            MarkHasAddedWatcher()       { m_bHasAddedWatcher = true; }\n    void            ClearHasAddedWatcher()      { m_bHasAddedWatcher = false; }\n    bool            HasAddedWatcher()           { return m_bHasAddedWatcher; }\n\npublic:\n    IResourceWatcher()\n        : m_bHasAddedWatcher(false)\n    { }\n\n    virtual ~IResourceWatcher()\n    { }\n\n    virtual void    Rebuild(ResHandle hResource) = 0;\n};\n//=============================================================================\n\n#endif //__I_RESOURCEWATCHER_H__\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/i_resourcewatcher2.h b/src/k2/i_resourcewatcher2.h
--- a/src/k2/i_resourcewatcher2.h	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/i_resourcewatcher2.h	(date 1685007426854)
@@ -13,28 +13,22 @@
 
 //=============================================================================
 // IResourceWatcher
-//      ***NOTE***:  BE SURE you call g_ResourceManager.RemoveResourceWatcher(this, m_hResource)
-//      in the destructor of your derived class!
 //=============================================================================
 class IResourceWatcher
 {
     friend class IResourceLibrary;
+    friend class CResourceManager;
 
     // internal for IResourceLibrary
 private:
-    bool            m_bHasAddedWatcher;
+    set<ResHandle>  m_setWatchingResources;
 
-    void            MarkHasAddedWatcher()       { m_bHasAddedWatcher = true; }
-    void            ClearHasAddedWatcher()      { m_bHasAddedWatcher = false; }
-    bool            HasAddedWatcher()           { return m_bHasAddedWatcher; }
+    bool            HasAddedWatcher(ResHandle hResource) const;
+    void            MarkHasAddedWatcher(ResHandle hResource);
+    void            ClearHasAddedWatcher(ResHandle hResource);
 
 public:
-    IResourceWatcher()
-        : m_bHasAddedWatcher(false)
-    { }
-
-    virtual ~IResourceWatcher()
-    { }
+    virtual ~IResourceWatcher();
 
     virtual void    Rebuild(ResHandle hResource) = 0;
 };
Index: src/k2/c_vid.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_vid.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_vid.h\"\n#include \"c_cmd.h\"\n#include \"i_resourcelibrary.h\"\n#include \"c_scenestats.h\"\n#include \"c_uicmd.h\"\n#include \"i_widget.h\"\n#include \"i_listwidget.h\"\n#include \"c_uimanager.h\"\n#include \"c_resourcemanager.h\"\n\n#undef pVid\n#undef Vid\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nCVid    *pVid = CVid::GetInstance();\n\nEXTERN_CVAR_STRING(host_vidDriver);\nEXTERN_CVAR_STRING(host_startupCfg);\n\nCVAR_STRING     (vid_currentMode,               \"\");\nCVAR_INTF       (vid_mode,                      -1,         CVAR_READONLY);\n#ifdef linux\nCVAR_STRINGF    (vid_display,                   \"\",         CVAR_SAVECONFIG);\nCVAR_BOOLF      (vid_blankOtherDisplays,        false,      CVAR_SAVECONFIG);\n#endif\n#ifdef __APPLE__\nCVAR_INTF       (vid_display,                   -1,         CVAR_SAVECONFIG);\n#endif\nARRAY_CVAR_UINTF(vid_resolution,                _T(\"0,0\"),  CVAR_SAVECONFIG);\nCVAR_INTF       (vid_bpp,                       0,          CVAR_SAVECONFIG);\nCVAR_INTF       (vid_refreshRate,               0,          CVAR_SAVECONFIG);\nCVAR_STRINGF    (vid_aspect,                    \"\",         CVAR_SAVECONFIG);\nCVAR_FLOATF     (vid_gamma,                     1.1f,       CVAR_SAVECONFIG);\nARRAY_CVAR_UINTF(vid_antialiasing,              _T(\"0,0\"),  CVAR_SAVECONFIG);\nCVAR_INTR       (vid_textureFiltering,          TEXTUREFILTERING_TRILINEAR, CVAR_SAVECONFIG, 0, NUM_TEXTUREFILTERING_MODES - 1);\nCVAR_BOOLF      (vid_fullscreen,                false,      CVAR_SAVECONFIG);\nCVAR_BOOL       (vid_windowResize,              false);\n\ntypedef void (*_initapis_t)(SVidDriver *vid_api, void *_MainWndProc, void *hInstance);\n\nSINGLETON_INIT(CVid)\n//=============================================================================\n\n/*====================\n  CVid::CVid\n\n  Set the singleton up for a SetDriver call\n  ====================*/\nCVid::CVid() :\nm_iCurrentMode(-1),\nm_bInitialized(false),\nm_hVidDLL(nullptr)\n{\n#ifdef _WIN32\n    MemManager.Set(&m_Driver, 0, sizeof(m_Driver));\n#else\n    MemManager.Set((char*)(&m_Driver) + sizeof(tstring), 0, sizeof(m_Driver) - sizeof(tstring));\n#endif\n}\n\n\n/*====================\n  CVid::~CVid\n  ====================*/\nCVid::~CVid()\n{\n    UnloadVidModule();\n}\n\n\n/*====================\n  CVid::SetDriver\n  ====================*/\nvoid    CVid::SetDriver(const tstring &sDriverName)\n{\n    bool reload = false;\n    if (!m_Driver.sDriverName.empty()) // Shutdown an old driver if we had one\n    {\n        if (m_Driver.sDriverName == sDriverName)\n            return;\n\n        Shutdown(); // Shutdown old driver\n        UnloadVidModule();\n        reload = true;\n\n        // UTTAR: Not ideal but best solution I can find for cvars to stick properly.\n        // All other alternatives either required redoing some systems or had disadvantages (or crashes...)\n        Console.ExecuteScript(host_startupCfg);\n    }\n\n    LoadVidModule(sDriverName);\n\n    StartDriver();\n\n    // UTTAR: Reload all the resources the video driver is directly aware of...\n    if (reload)\n    {\n        g_ResourceManager.GetLib(RES_PIXEL_SHADER)->ReloadAll();\n        g_ResourceManager.GetLib(RES_VERTEX_SHADER)->ReloadAll();\n        g_ResourceManager.GetLib(RES_TEXTURE)->ReloadAll();\n        g_ResourceManager.GetLib(RES_MATERIAL)->ReloadAll();\n        g_ResourceManager.GetLib(RES_MODEL)->ReloadAll();\n    }\n    host_vidDriver.SetModified(0);\n}\n\n\n/*====================\n  CVid::RegisterModel\n  ====================*/\nint     CVid::RegisterModel(CModel *pModel)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterModel(pModel);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterModel\n  ====================*/\nvoid    CVid::UnregisterModel(CModel *pModel)\n{\n    if (m_bInitialized)\n        return m_Driver.UnregisterModel(pModel);\n}\n\n\n/*====================\n  CVid::GetCamera\n  ====================*/\nconst CCamera*  CVid::GetCamera()\n{\n    if (m_bInitialized)\n        return m_Driver.GetCamera();\n    else\n        return nullptr;\n}\n\n\n/*====================\n  CVid::StartDriver\n  ====================*/\nvoid    CVid::StartDriver()\n{\n    Console.Video << _T(\"---------------------------------------------------------\") << newl\n            << _T(\"CVid::StartDriver():\") << newl;\n\n    m_Driver.Init();\n\n    SVidMode vm;\n    for (int i(0); m_Driver.GetMode(i, &vm); ++i)\n    {\n        // Create two cvars, one for each direction\n        ICvar::CreateString(_T(\"SetVideoMode\") + XtoA(i, FMT_PADZERO, 2), vm.sName);\n        ICvar::CreateInt(vm.sName, i);\n    }\n\n    for (int i(0); i < NUM_TEXTUREFILTERING_MODES; ++i)\n    {\n        if (!TextureFilteringModeAvailable(ETextureFilteringModes(i)))\n            continue;\n\n        ICvar::CreateString(_T(\"vid_textureFiltering\") + XtoA(i, FMT_PADZERO, 1), g_aTextureFilteringNames[i]);\n    }\n\n    if (!vid_resolution[0] || !vid_resolution[1] || !vid_bpp\n#ifndef __APPLE__\n        // some devices report a refresh rate of 0 under OS X\n        || !vid_refreshRate\n#endif\n        )\n    {\n        SVidMode vm;\n        if (m_Driver.GetMode(0, &vm))\n        {\n            if (vid_resolution.GetSize() != 2)\n                vid_resolution.Resize(2, 0);\n\n            if (vid_fullscreen)\n            {\n                vid_resolution.SetValue(0, vm.iWidth);\n                vid_resolution.SetValue(1, vm.iHeight);\n            }\n            else\n            {\n                // Subtract a bit of resolution to account for title bar\n                vid_resolution.SetValue(0, MAX(720, vm.iWidth - 160));\n                vid_resolution.SetValue(1, MAX(480, vm.iHeight - 100));\n            }\n            vid_bpp = vm.iBpp;\n            vid_refreshRate = vm.iRefreshRate;\n        }\n    }\n\n    vid_mode = m_iCurrentMode = m_Driver.SetMode();\n    m_Driver.GetCurrentMode(&m_VidMode);\n\n    m_bInitialized = true;\n    m_Driver.Start();\n\n    m_Driver.GetCurrentMode(&m_VidMode);\n    Console.Video << _T(\"Using mode \") << m_iCurrentMode << _T(\": \") << m_VidMode.iWidth << _T(\"x\") << m_VidMode.iHeight << _T(\"x\") << m_VidMode.iBpp << newl;\n    vid_currentMode = XtoA(m_VidMode.iWidth) + _T(\"x\") + XtoA(m_VidMode.iHeight) + _T(\"x\") + XtoA(m_VidMode.iBpp);\n}\n\n\n/*====================\n  CVid::Shutdown\n  ====================*/\nvoid    CVid::Shutdown()\n{\n    if (m_bInitialized)\n        m_Driver.Shutdown();\n    m_bInitialized = false;\n}\n\n\n/*====================\n  CVid::RenderScene\n  ====================*/\nvoid    CVid::RenderScene(class CCamera &camera)\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::RenderScene\");\n        m_Driver.RenderScene(camera);\n    }\n}\n\n\n/*====================\n  CVid::Add2dRect\n  ====================*/\nvoid    CVid::Add2dRect(float x, float y, float w, float h, float s1, float t1, float s2, float t2, ResHandle hTexture, int iFlags)\n{\n    if (m_bInitialized)\n        m_Driver.Add2dRect(x, y, w, h, s1, t1, s2, t2, hTexture, iFlags);\n}\n\n\n/*====================\n  CVid::Add2dQuad\n  ====================*/\nvoid    CVid::Add2dQuad(const CVec2f& v1, const CVec2f& v2, const CVec2f& v3, const CVec2f& v4,\n                        const CVec2f& t1, const CVec2f& t2, const CVec2f& t3, const CVec2f& t4, ResHandle hTexture, int iFlags)\n{\n    if (m_bInitialized)\n        m_Driver.Add2dQuad(v1, v2, v3, v4, t1, t2, t3, t4, hTexture, iFlags);\n}\n\n\n/*====================\n  CVid:Add2dLine\n  ====================*/\nvoid    CVid::Add2dLine(const CVec2f& v1, const CVec2f& v2, const CVec4f& v4Color1, const CVec4f& v4Color2, int iFlags)\n{\n    if (m_bInitialized)\n        m_Driver.Add2dLine(v1, v2, v4Color1, v4Color2, iFlags);\n}\n\n\n/*====================\n  CVid::AddPoint\n  ====================*/\nvoid    CVid::AddPoint(const CVec3f &v3Point, const CVec4f &v4Color)\n{\n    if (m_bInitialized)\n        m_Driver.AddPoint(v3Point, v4Color);\n}\n\n\n/*====================\n  CVid::AddLine\n  ====================*/\nvoid    CVid::AddLine(const CVec3f &v3Start, const CVec3f &v3End, const CVec4f &v4Color)\n{\n    if (m_bInitialized)\n        m_Driver.AddLine(v3Start, v3End, v4Color);\n}\n\n\n/*====================\n  CVid::Clear\n  ====================*/\nvoid    CVid::Clear()\n{\n    if (m_bInitialized)\n        m_Driver.Clear();\n}\n\n\n/*====================\n  CVid::NormalizeColor\n  ====================*/\nvoid    CVid::NormalizeColor(const vec4_t color, vec4_t out)\n{\n    //just clamp values brighter than 1\n    if (color[0] > 1)\n        out[0] = 1;\n    else\n        out[0] = color[0];\n\n    if (color[1] > 1)\n        out[1] = 1;\n    else\n        out[1] = color[1];\n\n    if (color[2] > 1)\n        out[2] = 1;\n    else\n        out[2] = color[2];\n\n    out[3] = color[3];\n}\n\n\n/*====================\n  CVid::SetColor\n  ====================*/\nvoid    CVid::SetColor(CVec4f v4Color)\n{\n    if (m_bInitialized)\n        m_Driver.SetColor(v4Color);\n}\n\n\n/*====================\n  CVid::Notify\n  ====================*/\nvoid    CVid::Notify(EVidNotifyMessage eMsg, int iParam1, int iParam2, int iParam3, void *pData, const tstring &sResContext)\n{\n    if (m_bInitialized)\n        m_Driver.Notify(eMsg, iParam1, iParam2, iParam3, pData, sResContext);\n}\n\n\n/*====================\n  CVid::BeginFrame\n  ====================*/\nvoid    CVid::BeginFrame()\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::BeginFrame\");\n        m_Driver.BeginFrame();\n    }\n}\n\n\n/*====================\n  CVid::EndFrame\n  ====================*/\nvoid    CVid::EndFrame()\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::EndFrame\");\n        m_Driver.EndFrame();\n    }\n\n    SceneStats.ResetFrame();\n}\n\n\n/*====================\n  CVid::GetScreenW\n  ====================*/\nint     CVid::GetScreenW()\n{\n    return m_VidMode.iWidth;\n}\n\n\n/*====================\n  CVid::GetScreenH\n  ====================*/\nint     CVid::GetScreenH()\n{\n    return m_VidMode.iHeight;\n}\n\n\n/*====================\n  CVid::GetFrameBuffer\n  ====================*/\nvoid    CVid::GetFrameBuffer(CBitmap &bmp)\n{\n    if (m_bInitialized)\n        return m_Driver.GetFrameBuffer(bmp);\n}\n\n\n/*====================\n  CVid::ProjectVertex\n  ====================*/\nCVec2f  CVid::ProjectVertex(const class CCamera &cam, const CVec3f &vecVertex)\n{\n    if (m_bInitialized)\n        return m_Driver.ProjectVertex(cam, vecVertex);\n    else\n        return CVec2f(0,0);\n}\n\n\n/*====================\n  CVid::IsFullScreen\n  ====================*/\nbool    CVid::IsFullScreen()\n{\n    if (m_bInitialized)\n        return m_Driver.IsFullScreen();\n    else\n        return false;\n}\n\n\n/*====================\n  CVid::GetHWnd\n  ====================*/\nvoid*   CVid::GetHWnd()\n{\n    if (m_bInitialized)\n        return m_Driver.GetHWnd();\n    else\n        return nullptr;\n}\n\n\n/*====================\n  CVid::OpenTextureArchive\n  ====================*/\nvoid    CVid::OpenTextureArchive(bool bNoReload)\n{\n    if (m_bInitialized)\n        m_Driver.OpenTextureArchive(bNoReload);\n}\n\n\n/*====================\n  CVid::CloseTextureArchive\n  ====================*/\nvoid    CVid::CloseTextureArchive()\n{\n    if (m_bInitialized)\n        m_Driver.CloseTextureArchive();\n}\n\n\n/*====================\n  CVid::GetTextureList\n  ====================*/\nvoid    CVid::GetTextureList(const tstring &sPath, const tstring &sSearch, tsvector &vResult)\n{\n    if (m_bInitialized)\n        m_Driver.GetTextureList(sPath, sSearch, vResult);\n}\n\n\n/*====================\n  CVid::RegisterTexture\n  ====================*/\nint     CVid::RegisterTexture(CTexture *pTexture)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterTexture(pTexture);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterTexture\n  ====================*/\nvoid    CVid::UnregisterTexture(CTexture *pTexture)\n{\n    if (m_bInitialized)\n        m_Driver.UnregisterTexture(pTexture);\n}\n\n\n/*====================\n  CVid::RegisterVertexShader\n  ====================*/\nint     CVid::RegisterVertexShader(CVertexShader *pVertexShader)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterVertexShader(pVertexShader);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterVertexShader\n  ====================*/\nvoid    CVid::UnregisterVertexShader(CVertexShader *pVertexShader)\n{\n    if (m_bInitialized)\n        m_Driver.UnregisterVertexShader(pVertexShader);\n}\n\n\n/*====================\n  CVid::RegisterPixelShader\n  ====================*/\nint     CVid::RegisterPixelShader(CPixelShader *pPixelShader)\n{\n    if (m_bInitialized)\n        return m_Driver.RegisterPixelShader(pPixelShader);\n    else\n        return -1;\n}\n\n\n/*====================\n  CVid::UnregisterPixelShader\n  ====================*/\nvoid    CVid::UnregisterPixelShader(CPixelShader *pPixelShader)\n{\n    if (m_bInitialized)\n        m_Driver.UnregisterPixelShader(pPixelShader);\n}\n\n\n/*====================\n  CVid::RegisterShaderPair\n  ====================*/\nvoid    CVid::RegisterShaderPair(CVertexShader *pVertexShader, CPixelShader *pPixelShader)\n{\n    if (m_bInitialized)\n        m_Driver.RegisterShaderPair(pVertexShader, pPixelShader);\n}\n\n\n/*====================\n  CVid::RenderFogofWar\n  ====================*/\nvoid    CVid::RenderFogofWar(float fClear, bool bTexture, float fLerp)\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::RenderFogofWar\");\n        m_Driver.RenderFogofWar(fClear, bTexture, fLerp);\n    }\n}\n\n\n/*====================\n  CVid::UpdateFogofWar\n  ====================*/\nvoid    CVid::UpdateFogofWar(const CBitmap &cBmp)\n{\n    if (m_bInitialized)\n    {\n        PROFILE(\"CVid::UpdateFogofWar\");\n        m_Driver.UpdateFogofWar(cBmp);\n    }\n}\n\n\n/*====================\n  CVid::ShowCursor\n  ====================*/\nvoid    CVid::ShowCursor(bool bShow)\n{\n    if (m_bInitialized)\n    {\n        m_Driver.ShowCursor(bShow);\n    }\n}\n\n\n/*====================\n  CVid::SetCursor\n  ====================*/\nvoid    CVid::SetCursor(ResHandle hCursor)\n{\n    if (m_bInitialized)\n    {\n        m_Driver.SetCursor(hCursor);\n    }\n}\n\n\n/*====================\n  CVid::GetMode\n  ====================*/\nbool    CVid::GetMode(int iMode, SVidMode *pVidMode)\n{\n    if (m_bInitialized)\n    {\n        return m_Driver.GetMode(iMode, pVidMode);\n    }\n\n    return false;\n}\n\n\n/*====================\n  CVid::GetCurrentMode\n  ====================*/\nbool    CVid::GetCurrentMode(SVidMode *pVidMode)\n{\n    if (m_bInitialized)\n    {\n        return m_Driver.GetCurrentMode(pVidMode);\n    }\n\n    return false;\n}\n\n\n/*====================\n  CVid::GetTextureColor\n  ====================*/\nCVec4f  CVid::GetTextureColor(CTexture *pTexture)\n{\n    if (m_bInitialized)\n    {\n        return m_Driver.GetTextureColor(pTexture);\n    }\n\n    return WHITE;\n}\n\n\n/*====================\n  CVid::GetAAMode\n  ====================*/\nbool    CVid::GetAAMode(int iMode, SAAMode *pAAMode)\n{\n    if (!m_bInitialized)\n        return false;\n\n    return m_Driver.GetAAMode(iMode, pAAMode);\n}\n\n\n/*====================\n  CVid::GetCurrentAAMode\n  ====================*/\nbool    CVid::GetCurrentAAMode(SAAMode *pAAMode)\n{\n    if (!m_bInitialized)\n        return false;\n\n    return m_Driver.GetCurrentAAMode(pAAMode);\n}\n\n\n/*====================\n  CVid::TextureExists\n  ====================*/\nbool    CVid::TextureExists(const tstring &sFilename, uint uiTextureFlags)\n{\n    if (m_bInitialized)\n    {\n#if TKTK\n        return m_Driver.TextureExists(sFilename, uiTextureFlags);\n#else\n        if (m_Driver.TextureExists(sFilename, uiTextureFlags))\n            return true;\n        // try each image fallback extension.\n        for (auto sFallbackExt : {_T(\"png\"), _T(\"dds\"), _T(\"tga\")})\n        {\n            if (CompareNoCase(Filename_GetExtension(sFilename), sFallbackExt) == 0)\n                continue;\n            tstring sNewFilename(Filename_StripExtension(sFilename) + _T(\".\") + sFallbackExt);\n            if (m_Driver.TextureExists(sNewFilename, uiTextureFlags))\n                return true;\n        }\n        return false;\n#endif\n    }\n    else\n        return false;\n}\n\n\n/*====================\n  CVid::ChangeMode\n  ====================*/\nvoid    CVid::ChangeMode(int iMode)\n{\n    if (!m_bInitialized)\n        return;\n\n    int iWidth0(m_VidMode.iWidth);\n    int iHeight0(m_VidMode.iHeight);\n\n    if (iMode != -1)\n    {\n        SVidMode vm;\n        if (m_Driver.GetMode(iMode, &vm))\n        {\n            if (vid_resolution.GetSize() != 2)\n                vid_resolution.Resize(2, 0);\n\n            vid_resolution.SetValue(0, vm.iWidth);\n            vid_resolution.SetValue(1, vm.iHeight);\n            vid_bpp = vm.iBpp;\n            vid_refreshRate = vm.iRefreshRate;\n        }\n        else\n            return;\n    }\n\n    vid_mode = m_iCurrentMode = m_Driver.SetMode();\n    m_Driver.GetCurrentMode(&m_VidMode);\n    m_Driver.GetCurrentAAMode(&m_AAMode);\n    Console.Video << _T(\"Video Mode: width=\") << m_VidMode.iWidth << _T(\", height=\") << m_VidMode.iHeight << _T(\", bpp=\") << m_VidMode.iBpp << _T(\", refreshrate=\") << m_VidMode.iRefreshRate << _T(\", samples=\") << m_AAMode.iSamples << newl;\n    vid_currentMode = XtoA(m_VidMode.iWidth) + _T(\"x\") + XtoA(m_VidMode.iHeight) + _T(\"x\") + XtoA(m_VidMode.iBpp);\n\n    if (iWidth0 != m_VidMode.iWidth || iHeight0 != m_VidMode.iHeight)\n    {\n        Host.SetResolutionChange(true);\n\n        UIManager.ResizeInterface(_T(\"loading\"), m_VidMode.iWidth, m_VidMode.iHeight);\n\n        SetColor(BLACK);\n        Clear();\n    }\n}\n\n\n/*====================\n  CVid::TextureFilteringModeAvailable\n  ====================*/\nbool    CVid::TextureFilteringModeAvailable(ETextureFilteringModes eMode)\n{\n    if (!m_bInitialized)\n        return false;\n\n    return m_Driver.TextureFilteringModeAvailable(eMode);\n}\n\n\n/*====================\n  CVid::LoadVidModule\n  ====================*/\nvoid    CVid::LoadVidModule(const tstring &sFileName)\n{\n    _initapis_t InitAPIs;\n\n    m_hVidDLL = K2System.LoadLibrary(sFileName);\n    if (m_hVidDLL == nullptr)\n        K2System.Error(_T(\"Couldn't load \") + sFileName);\n\n    //find and call CL_InitAPIs to get function pointers to the client game functions\n    InitAPIs = (_initapis_t)K2System.GetProcAddress(m_hVidDLL, _T(\"InitAPIs\"));\n    if (!InitAPIs)\n        K2System.Error(_T(\"Couldn't find entry function InitAPIs()\"));\n\n    InitAPIs(&m_Driver, K2System.GetMainWndProc(), K2System.GetInstanceHandle());\n}\n\n\n/*====================\n  CVid::UnloadVidModule\n  ====================*/\nvoid    CVid::UnloadVidModule()\n{\n    if (m_hVidDLL)\n    {\n        K2System.FreeLibrary(m_hVidDLL);\n        m_hVidDLL = nullptr;\n\n#ifdef _WIN32\n        MemManager.Set(&m_Driver, 0, sizeof(m_Driver));\n#else\n        MemManager.Set((char*)(&m_Driver) + sizeof(tstring), 0, sizeof(m_Driver) - sizeof(tstring));\n        m_Driver.sDriverName.clear();\n#endif\n    }\n}\n\n\n/*--------------------\n  cmdSetVideoMode\n  --------------------*/\nCMD(SetVideoMode)\n{\n    CVid::GetInstance()->ChangeMode(vArgList.size() > 0 ? AtoI(vArgList[0]) : -1);\n    return true;\n}\n\n#if defined(linux) || defined(__APPLE__)\n/*--------------------\n  AddDisplays\n  --------------------*/\nUI_VOID_CMD(AddDisplays, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n    \n    mapParams[_T(\"label\")] = _T(\"Automatic\");\n#ifdef linux\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"\"), mapParams);\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        if (vm.sDisplay.empty() || setNames.find(vm.sDisplay) != setNames.end())\n            continue;\n\n        setNames.insert(vm.sDisplay);\n\n        mapParams[_T(\"label\")] = vm.sDisplay;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), vm.sDisplay, mapParams);\n    }\n#else\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"-1\"), mapParams);\n    \n    set<int> setDpys;\n    \n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        if (setDpys.find(vm.iDisplay) != setDpys.end())\n            continue;\n        \n        setDpys.insert(vm.iDisplay);\n        \n        mapParams[_T(\"label\")] = XtoA(vm.iDisplay);\n        \n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iDisplay), mapParams);\n    }\n#endif\n}\n#endif\n\n\n/*--------------------\n  AddVideoModes\n  --------------------*/\nUI_VOID_CMD(AddVideoModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    tsvector vVidModeList;\n\n    SVidMode vm;\n    for (int i(0); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        vVidModeList.push_back(vm.sName);\n    }\n\n    for (int i(0); i < int(vVidModeList.size()); ++i)\n    {\n        mapParams[_T(\"label\")] = vVidModeList[i];\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(i), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddTextureFilteringModes\n  --------------------*/\nUI_VOID_CMD(AddTextureFilteringModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    for (int i(0); i < NUM_TEXTUREFILTERING_MODES; ++i)\n    {\n        if (!CVid::GetInstance()->TextureFilteringModeAvailable(ETextureFilteringModes(i)))\n            continue;\n        \n        mapParams[_T(\"label\")] = g_aTextureFilteringNames[i];\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(i), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddAntiAliasingModes\n  --------------------*/\nUI_VOID_CMD(AddAntiAliasingModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    SAAMode cMode;\n    for (int i(0); CVid::GetInstance()->GetAAMode(i, &cMode); ++i)\n    {\n        mapParams[_T(\"label\")] = cMode.sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(cMode.iSamples) + _T(\",\") + XtoA(cMode.iQuality), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddAspectModes\n  --------------------*/\nUI_VOID_CMD(AddAspectModes, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    mapParams[_T(\"label\")] = _T(\"Automatic\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"4:3\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"4:3\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"16:10\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"16:10\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"16:9\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"16:9\"), mapParams);\n\n    mapParams[_T(\"label\")] = _T(\"5:4\");\n    pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), _T(\"5:4\"), mapParams);\n}\n\n\n#ifdef linux\nEXTERN_CVAR_STRING(options_display);\n#endif\n#ifdef __APPLE__\nEXTERN_CVAR_INT(options_display);\n#endif\n/*--------------------\n  AddResolutions\n  --------------------*/\nUI_VOID_CMD(AddResolutions, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n#ifdef linux\n        if (!options_display.GetValue().empty() && !vm.sDisplay.empty() && options_display.GetValue() != vm.sDisplay)\n            continue;\n#endif\n#ifdef __APPLE__\n        if (options_display > -1 && options_display != vm.iDisplay)\n            continue;\n#endif\n        \n        tstring sName(XtoA(vm.iWidth) + _T(\"x\") + XtoA(vm.iHeight));\n\n        if (setNames.find(sName) != setNames.end())\n            continue;\n\n        setNames.insert(sName);\n\n        mapParams[_T(\"label\")] = sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iWidth) + _T(\",\") + XtoA(vm.iHeight), mapParams);\n    }\n}\n\n\n/*--------------------\n  AddColorDepths\n  --------------------*/\nUI_VOID_CMD(AddColorDepths, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n        tstring sName(XtoA(vm.iBpp) + _T(\" bit\"));\n\n        if (setNames.find(sName) != setNames.end())\n            continue;\n\n        setNames.insert(sName);\n\n        mapParams[_T(\"label\")] = sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iBpp), mapParams);\n    }\n}\n\n\nEXTERN_ARRAY_CVAR_UINT(options_resolution);\n/*--------------------\n  AddRefreshRates\n  --------------------*/\nUI_VOID_CMD(AddRefreshRates, 1)\n{\n    if (!pThis || !pThis->HasFlags(WFLAG_LIST))\n        return;\n\n    IListWidget *pList(static_cast<IListWidget *>(pThis));\n    if (pList == nullptr)\n        return;\n\n    CXMLNode::PropertyMap mapParams;\n    for (ScriptTokenVector_cit cit(vArgList.begin() + 1); cit != vArgList.end(); ++cit)\n    {\n        CXMLNode::Key sKey((*cit)->Evaluate());\n        ++cit;\n        if (cit == vArgList.end())\n            break;\n        mapParams[sKey] = (*cit)->Evaluate();\n    }\n\n    set<tstring> setNames;\n\n    SVidMode vm;\n    for (int i(1); CVid::GetInstance()->GetMode(i, &vm); ++i)\n    {\n#ifdef linux\n        if (!options_display.GetValue().empty() && options_display.GetValue() != vm.sDisplay)\n            continue;\n        \n        if (vm.iWidth != options_resolution[0] || vm.iHeight != options_resolution[1])\n            continue;\n#endif\n#ifdef __APPLE__\n        if (options_display > -1 && options_display != vm.iDisplay)\n            continue;\n        \n        if (vm.iWidth != options_resolution[0] || vm.iHeight != options_resolution[1])\n            continue;\n#endif\n        \n        tstring sName(XtoA(vm.iRefreshRate) + _T(\" Hertz\"));\n        if (vm.iRefreshRate == 0)\n            sName = _T(\"Automatic\");\n\n        if (setNames.find(sName) != setNames.end())\n            continue;\n\n        setNames.insert(sName);\n\n        mapParams[_T(\"label\")] = sName;\n\n        pList->CreateNewListItemFromTemplate(vArgList[0]->Evaluate(), XtoA(vm.iRefreshRate), mapParams);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_vid.cpp b/src/k2/c_vid.cpp
--- a/src/k2/c_vid.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/c_vid.cpp	(date 1685007426874)
@@ -162,12 +162,14 @@
 
     m_Driver.Init();
 
-    SVidMode vm;
-    for (int i(0); m_Driver.GetMode(i, &vm); ++i)
-    {
-        // Create two cvars, one for each direction
-        ICvar::CreateString(_T("SetVideoMode") + XtoA(i, FMT_PADZERO, 2), vm.sName);
-        ICvar::CreateInt(vm.sName, i);
+    {
+        SVidMode vm;
+        for (int i(0); m_Driver.GetMode(i, &vm); ++i)
+        {
+            // Create two cvars, one for each direction
+            ICvar::CreateString(_T("SetVideoMode") + XtoA(i, FMT_PADZERO, 2), vm.sName);
+            ICvar::CreateInt(vm.sName, i);
+        }
     }
 
     for (int i(0); i < NUM_TEXTUREFILTERING_MODES; ++i)
@@ -183,7 +185,7 @@
         // some devices report a refresh rate of 0 under OS X
         || !vid_refreshRate
 #endif
-        )
+            )
     {
         SVidMode vm;
         if (m_Driver.GetMode(0, &vm))
Index: src/k2/c_skeleton.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2005 S2 Games\n// c_skeleton.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"k2_common.h\"\n\n#include \"c_skeleton.h\"\n#include \"c_k2model.h\"\n#include \"c_anim.h\"\n#include \"c_bone.h\"\n#include \"c_mesh.h\"\n#include \"c_model.h\"\n#include \"c_clip.h\"\n#include \"i_resource.h\"\n#include \"c_skeletonbonepool.h\"\n#include \"c_resourcemanager.h\"\n\n#include \"../public/modelclip_t.h\"\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\nCVAR_BOOL(skel_interpolate, true);\nCVAR_BOOL(skel_blendAnims, true);\nCVAR_BOOL(skel_noPose, false);\nCVAR_BOOL(skel_debug, false);\n//=============================================================================\n\n/*====================\n  CSkeleton::CSkeleton\n  ====================*/\nCSkeleton::CSkeleton() :\nm_pBoneStates(nullptr),\nm_pTempBoneStates(nullptr),\nm_uiNumBones(0),\nm_bIsValid(false),\n\nm_bIsCharacter(false),\nm_uiPoseTime(INVALID_TIME),\nm_uiPrevPoseTime(INVALID_TIME),\nm_uiSavedPoseTime(INVALID_TIME),\nm_fPrevPitch(0.0f),\nm_fPitch(0.0f),\nm_fPrevYaw(0.0f),\nm_fYaw(0.0f),\n\nm_sDefaultAnimName(_T(\"idle\")),\n\nm_hModel(INVALID_RESOURCE),\nm_pModel(nullptr)\n{\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        m_pAnim[i] = nullptr;\n        m_fSpeed[i] = 1.0f;\n        m_uiForceLength[i] = 0;\n        m_bPassiveAnim[i] = true;\n        m_pCurrentPose[i] = nullptr;\n        m_pSavedPose[i] = nullptr;\n        m_pTempPose[i] = nullptr;\n        m_iParentChannel[i] = -1;\n        m_bValidPose[i] = false;\n        m_uiStartTime[i] = INVALID_TIME;\n        m_fSpeed[i] = 1.0f;\n        m_uiForceLength[i] = 0;\n        m_iOffsetTime[i] = 0;\n        m_aAnimRequest[i].sAnim.clear();\n        m_aAnimRequest[i].uiTime = INVALID_TIME;\n    }\n\n    Clear();\n}\n\n\n/*====================\n  CSkeleton::~CSkeleton\n  ====================*/\nCSkeleton::~CSkeleton()\n{\n    // Give the bone data back to the pool\n    SSkeletonBoneData cBoneData;\n    cBoneData.uiNumBones = m_uiNumBones;\n    \n    cBoneData.pBoneStates = m_pBoneStates;\n    cBoneData.pTempBoneStates = m_pTempBoneStates;\n\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        cBoneData.pCurrentPose[i] = m_pCurrentPose[i];\n        cBoneData.pSavedPose[i] = m_pSavedPose[i];\n        cBoneData.pTempPose[i] = m_pTempPose[i];\n    }\n\n    SkeletonBonePool.Deallocate(cBoneData);\n\n    g_ResourceManager.RemoveResourceWatcher(this, m_hModel);\n}\n\n\n/*====================\n  CSkeleton::SetBoneState\n  ====================*/\nvoid    CSkeleton::SetBoneState(uint uiBone, int iState)\n{\n    if (uiBone == INVALID_BONE)\n        return;\n\n    m_pBoneStates[uiBone].poseState = iState;\n\n    CBone *pBone(m_pModel->GetBone(uiBone));\n    uint uiNumChildren(pBone->NumChildren());\n    for (uint n(0); n < uiNumChildren; ++n)\n    {\n        uint uiChild(pBone->GetChildIndex(n));\n        SetBoneState(uiChild, iState);\n    }\n}\n\n\n/*====================\n  CSkeleton::SetBoneState\n  ====================*/\nvoid    CSkeleton::SetBoneState(const tstring &sBoneName, int iState)\n{\n    uint uiBone(m_pModel->GetBoneIndex(sBoneName));\n    if (uiBone == INVALID_BONE)\n        return;\n\n    SetBoneState(uiBone, iState);\n}\n\n\n/*====================\n  CSkeleton::SetBoneState\n  ====================*/\nvoid    CSkeleton::SetBoneState(int iState)\n{\n    for (uint n(0); n < m_uiNumBones; ++n)\n        m_pBoneStates[n].poseState = iState;\n}\n\n\n\n/*====================\n  CSkeleton::Clear\n  ====================*/\nvoid    CSkeleton::Clear()\n{\n    // Give the bone data back to the pool\n    SSkeletonBoneData cBoneData;\n    cBoneData.uiNumBones = m_uiNumBones;\n    cBoneData.pBoneStates = m_pBoneStates;\n    cBoneData.pTempBoneStates = m_pTempBoneStates;\n\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        cBoneData.pCurrentPose[i] = m_pCurrentPose[i];\n        cBoneData.pSavedPose[i] = m_pSavedPose[i];\n        cBoneData.pTempPose[i] = m_pTempPose[i];\n    }\n\n    SkeletonBonePool.Deallocate(cBoneData);\n\n    m_uiNumBones = 0;\n    m_pBoneStates = nullptr;\n    m_pTempBoneStates = nullptr;\n\n    for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n    {\n        m_pCurrentPose[i] = nullptr;\n        m_pSavedPose[i] = nullptr;\n        m_pTempPose[i] = nullptr;\n    }\n\n    m_pModel = nullptr;\n    m_bIsValid = false;\n\n    m_bIsCharacter = false;\n    m_uiPoseTime = INVALID_TIME;\n    m_uiPrevPoseTime = INVALID_TIME;\n    m_uiSavedPoseTime = INVALID_TIME;\n\n    m_fYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPrevPitch = 0.0f;\n\n    for (int n(0); n < NUM_ANIM_CHANNELS; ++n)\n    {\n        m_pAnim[n] = nullptr;\n        m_uiBlendTime[n] = 0;\n        m_uiBlendStartTime[n] = 0;\n        m_uiTime[n] = 0;\n        m_iParentChannel[n] = n;\n        m_iLastAnimTime[n] = 0;\n        m_bPassiveAnim[n] = true;\n        m_bValidPose[n] = false;\n        m_uiStartTime[n] = INVALID_TIME;\n        m_fSpeed[n] = 1.0f;\n        m_uiForceLength[n] = 0;\n        m_iOffsetTime[n] = 0;\n\n        m_aAnimRequest[n].sAnim.clear();\n        m_aAnimRequest[n].uiTime = INVALID_TIME;\n    }\n\n    ClearEvents();\n}\n\n\n/*====================\n  CSkeleton::GetBoneXform\n  ====================*/\nvoid    CSkeleton::GetBoneXform(SBoneMotion *pMotion, int iLoFrame, int iHiFrame, float fLerp, SBoneXForm &cBone)\n{   \n    if (skel_interpolate)\n    {\n        // Translation\n        cBone.v3Pos.x = pMotion->keys_x.num_keys == 1 ? pMotion->keys_x.keys[0] : LERP(fLerp, pMotion->keys_x.keys[iLoFrame], pMotion->keys_x.keys[iHiFrame]);\n        cBone.v3Pos.y = pMotion->keys_y.num_keys == 1 ? pMotion->keys_y.keys[0] : LERP(fLerp, pMotion->keys_y.keys[iLoFrame], pMotion->keys_y.keys[iHiFrame]);\n        cBone.v3Pos.z = pMotion->keys_z.num_keys == 1 ? pMotion->keys_z.keys[0] : LERP(fLerp, pMotion->keys_z.keys[iLoFrame], pMotion->keys_z.keys[iHiFrame]);\n\n        // Rotation\n        if (pMotion->keys_quat.num_keys == 1)\n        {\n            M_CopyVec4(pMotion->keys_quat.keys[0], vec4_cast(cBone.v4Quat));\n        }\n        else\n        {\n            M_LerpQuat(fLerp,\n                pMotion->keys_quat.keys[iLoFrame % pMotion->keys_quat.num_keys],\n                pMotion->keys_quat.keys[iHiFrame % pMotion->keys_quat.num_keys],\n                vec4_cast(cBone.v4Quat));\n        }\n\n        // Scale\n        cBone.v3Scale.x = pMotion->keys_scalex.num_keys == 1 ? pMotion->keys_scalex.keys[0] : LERP(fLerp, pMotion->keys_scalex.keys[iLoFrame], pMotion->keys_scalex.keys[iHiFrame]);\n        cBone.v3Scale.y = pMotion->keys_scaley.num_keys == 1 ? pMotion->keys_scaley.keys[0] : LERP(fLerp, pMotion->keys_scaley.keys[iLoFrame], pMotion->keys_scaley.keys[iHiFrame]);\n        cBone.v3Scale.z = pMotion->keys_scalez.num_keys == 1 ? pMotion->keys_scalez.keys[0] : LERP(fLerp, pMotion->keys_scalez.keys[iLoFrame], pMotion->keys_scalez.keys[iHiFrame]);\n    }\n    else\n    {\n        // Translation\n        cBone.v3Pos.x = pMotion->keys_x.keys[iLoFrame % pMotion->keys_x.num_keys];\n        cBone.v3Pos.y = pMotion->keys_y.keys[iLoFrame % pMotion->keys_y.num_keys];\n        cBone.v3Pos.z = pMotion->keys_z.keys[iLoFrame % pMotion->keys_z.num_keys];\n        M_CopyVec4(pMotion->keys_quat.keys[iLoFrame % pMotion->keys_quat.num_keys], vec4_cast(cBone.v4Quat));\n\n        // Scale\n        cBone.v3Scale.x = pMotion->keys_scalex.keys[iLoFrame % pMotion->keys_scalex.num_keys];\n        cBone.v3Scale.y = pMotion->keys_scaley.keys[iLoFrame % pMotion->keys_scaley.num_keys];\n        cBone.v3Scale.z = pMotion->keys_scalez.keys[iLoFrame % pMotion->keys_scalez.num_keys];\n    }\n}\n\n\n/*====================\n  CSkeleton::PoseBones\n  ====================*/\nvoid    CSkeleton::PoseBones(SBoneMotion **ppMotions, int iLoFrame, int iHiFrame, float fLerp, int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone, ++ppMotions)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n\n        SBoneMotion *pMotion(*ppMotions);\n\n        if (!pMotion)\n        {\n            m_pCurrentPose[iChannel][uiBone].v3Pos = CVec3f(0.0f, 0.0f, 0.0f);\n            m_pCurrentPose[iChannel][uiBone].v4Quat = CVec4f(0.0f, 0.0f, 0.0f, 1.0f);\n            m_pCurrentPose[iChannel][uiBone].v3Scale = CVec3f(1.0f, 1.0f, 1.0f);\n            \n            pBoneState->visibility = 255;\n            continue;\n        }\n\n        GetBoneXform(pMotion, iLoFrame, iHiFrame, fLerp, m_pCurrentPose[iChannel][uiBone]);\n        \n        // Update bone sisibility\n        if (pMotion->keys_visibility.num_keys == 0)\n            pBoneState->visibility = 255;\n        else\n            pBoneState->visibility = pMotion->keys_visibility.num_keys == 1 ?\n                pMotion->keys_visibility.keys[0] : pMotion->keys_visibility.keys[iLoFrame % pMotion->keys_visibility.num_keys];\n    }\n}\n\n\n/*====================\n  CSkeleton::UpdateBones\n\n  update skeleton local tms\n  ====================*/\nvoid    CSkeleton::UpdateBones(int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n        \n        SBoneXForm &cCurrentPose(m_pCurrentPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = cCurrentPose.v3Pos;\n\n        // Rotation\n        M_QuatToAxis(vec4_cast(cCurrentPose.v4Quat), pBoneState->tm.axis);\n\n        // Scale\n        if (cCurrentPose.v3Scale[X] != 1.0f)\n            M_MultVec3(pBoneState->tm.axis[X], cCurrentPose.v3Scale[X], pBoneState->tm.axis[X]);\n        if (cCurrentPose.v3Scale[Y] != 1.0f)\n            M_MultVec3(pBoneState->tm.axis[Y], cCurrentPose.v3Scale[Y], pBoneState->tm.axis[Y]);\n        if (cCurrentPose.v3Scale[Z] != 1.0f)\n            M_MultVec3(pBoneState->tm.axis[Z], cCurrentPose.v3Scale[Z], pBoneState->tm.axis[Z]);\n    }\n}\n\n\n/*====================\n  CSkeleton::UpdateBonesLerp\n\n  update skeleton local tms\n  ====================*/\nvoid    CSkeleton::UpdateBonesLerp(float fLerp, int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n        \n        SBoneXForm &cSavedPose(m_pSavedPose[iChannel][uiBone]);\n        SBoneXForm &cCurrentPose(m_pCurrentPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = LERP(fLerp, cSavedPose.v3Pos, cCurrentPose.v3Pos);\n\n        // Rotation\n        vec4_t quat;\n        M_LerpQuat(fLerp, vec4_cast(cSavedPose.v4Quat), vec4_cast(cCurrentPose.v4Quat), vec4_cast(quat));\n        M_QuatToAxis(quat, pBoneState->tm.axis);\n\n        // Scale\n        M_MultVec3(pBoneState->tm.axis[X], LERP(fLerp, cSavedPose.v3Scale[X], cCurrentPose.v3Scale[X]), pBoneState->tm.axis[X]);\n        M_MultVec3(pBoneState->tm.axis[Y], LERP(fLerp, cSavedPose.v3Scale[Y], cCurrentPose.v3Scale[Y]), pBoneState->tm.axis[Y]);\n        M_MultVec3(pBoneState->tm.axis[Z], LERP(fLerp, cSavedPose.v3Scale[Z], cCurrentPose.v3Scale[Z]), pBoneState->tm.axis[Z]);\n    }\n}\n\n\n\n/*====================\n  CSkeleton::BlendBones\n\n  Update the current skeleton quats to most recent blend so we can save the values\n  to be used in a new blend.  This only happens during a StartAnim call.\n  ====================*/\nvoid    CSkeleton::BlendBones(float fLerp, int iChannel)\n{\n    for (uint uiBone(0); uiBone < m_uiNumBones; ++uiBone)\n    {\n        SBoneState  *pBoneState(GetBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n            continue;\n        \n        SBoneXForm &cSavedPose(m_pSavedPose[iChannel][uiBone]);\n        SBoneXForm &cCurrentPose(m_pCurrentPose[iChannel][uiBone]);\n\n        cCurrentPose.v3Pos = LERP(fLerp, cSavedPose.v3Pos, cCurrentPose.v3Pos);\n        M_LerpQuat(fLerp, vec4_cast(cSavedPose.v4Quat), vec4_cast(cCurrentPose.v4Quat), vec4_cast(cCurrentPose.v4Quat));\n        cCurrentPose.v3Scale = LERP(fLerp, cSavedPose.v3Scale, cCurrentPose.v3Scale);\n    }\n}\n\n\n/*====================\n  CSkeleton::SetAnim\n  ====================*/\nvoid    CSkeleton::SetAnim(const tstring &sAnim, uint uiTime, int iBlendTime, int iChannel, float fSpeed, uint uiForceLength, bool bStartEvent, bool bEndEvent)\n{\n    if (!m_pModel)\n        return;\n\n    m_bPassiveAnim[iChannel] = (sAnim == m_sDefaultAnimName);\n\n    CAnim *pNewAnim(m_pModel->GetAnim(sAnim));\n\n    if (!pNewAnim)\n        return;\n\n    CAnim *pOldAnim(m_pAnim[iChannel]);\n\n    // Add end events\n    if (pOldAnim && bEndEvent)\n    {\n        const tsvector &vEndEvents(pOldAnim->GetEndEvents());\n        for (tsvector::const_iterator it(vEndEvents.begin()); it != vEndEvents.end(); ++it)\n            AddEvent(*it, 0);\n    }\n\n    m_pAnim[iChannel] = pNewAnim;\n\n    // Calculate and save the current pose for blending\n    if (iChannel == 1)\n    {\n        SetBoneState(POSE_MASKED);\n        SetBoneState(_T(\"Bip01 Spine\"), 0);\n    }\n\n    uint uiBlendTime(m_fSpeed[iChannel] != 0.0f ? INT_ROUND(m_uiBlendTime[iChannel] / m_fSpeed[iChannel]) : 0);\n\n    if (uiBlendTime && uiTime - m_uiBlendStartTime[iChannel] < uiBlendTime && skel_blendAnims)\n    {\n        float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(uiBlendTime)));\n        BlendBones(fBlend, iChannel);\n    }\n\n    if (iChannel == 1)\n        SetBoneState(0);\n\n    if (pOldAnim && m_bValidPose[iChannel])\n    {\n        // Start a new blend\n        MemManager.Copy(m_pSavedPose[iChannel], m_pCurrentPose[iChannel], sizeof(SBoneXForm) * m_pModel->GetNumBones());\n\n        if (iBlendTime == -1)\n            iBlendTime = pNewAnim->GetBlendTime();\n\n        m_uiBlendTime[iChannel] = iBlendTime;\n    }\n    else\n    {\n        m_uiBlendTime[iChannel] = 0;\n    }\n\n    m_uiBlendStartTime[iChannel] = uiTime;\n    m_uiStartTime[iChannel] = uiTime;\n    m_fSpeed[iChannel] = fSpeed;\n    m_uiForceLength[iChannel] = uiForceLength;\n    m_iOffsetTime[iChannel] = (M_Randnum(m_pAnim[iChannel]->GetMinStartFrame(), m_pAnim[iChannel]->GetMaxStartFrame()) - m_pAnim[iChannel]->GetStartFrame()) * m_pAnim[iChannel]->GetMSperFrame();\n    m_iLastAnimTime[iChannel] = m_iOffsetTime[iChannel];\n    m_uiPoseTime = INVALID_TIME;\n\n    // Add start events\n    if (pNewAnim && bStartEvent)\n    {\n        const tsvector &vStartEvents(pNewAnim->GetStartEvents());\n        for (tsvector::const_iterator it(vStartEvents.begin()); it != vStartEvents.end(); ++it)\n            AddEvent(*it, 0);\n    }\n}\n\n\n/*====================\n  CSkeleton::StartAnim\n  ====================*/\nint     CSkeleton::StartAnim(const tstring &sAnim, uint uiTime, int iChannel, int iBlendTime, float fSpeed, uint uiForceLength)\n{\n    PROFILE(\"CSkeleton::StartAnim\");\n\n    if (!m_pModel)\n        return -1;\n\n    assert(iChannel >= 0 && iChannel < NUM_ANIM_CHANNELS); \n\n    //Console.Dev << \"CSkeleton::StartAnim() - \" << sAnim << _T(\" \") << uiTime << _T(\" \") << iChannel << newl;\n\n    // Update old anims to the current time\n    if (m_uiPoseTime != uiTime && HasValidAnims())\n        Pose(uiTime);\n\n    SetAnim(sAnim, uiTime, iBlendTime, iChannel, fSpeed, uiForceLength, true, true);\n    m_iParentChannel[iChannel] = iChannel;\n\n    for (int i(0); i < NUM_ANIM_CHANNELS; ++i)\n    {\n        CAnim *pDefaultAnim = m_pModel->GetAnim(m_sDefaultAnimName);\n\n        if (iChannel != i && (m_bPassiveAnim[i] || m_iParentChannel[i] == iChannel) && !(pDefaultAnim && pDefaultAnim->GetLock()))\n        {\n            SetAnim(sAnim, uiTime, iBlendTime, i, fSpeed, uiForceLength, false, false);\n            m_iParentChannel[i] = iChannel;\n        }\n    }\n    return -1;\n}\n\n\n/*====================\n  CSkeleton::StopAnim\n  ====================*/\nvoid    CSkeleton::StopAnim(int iChannel, uint uiTime)\n{\n    PROFILE(\"CSkeleton::StartAnim\");\n\n    if (iChannel < 0 || iChannel > NUM_ANIM_CHANNELS)\n    {\n        Console.Warn << _T(\"CSkeleton::StopAnim() - Invalid channel: \") << iChannel << newl;\n        return;\n    }\n\n    CAnim *pDefaultAnim(m_pModel->GetAnim(m_sDefaultAnimName));\n\n    // If possible, synch with channel zero, otherwise fall\n    // back to the current default anim\n    if (iChannel != 0 && m_pAnim[0] != nullptr && !(pDefaultAnim && pDefaultAnim->GetLock()))\n    {\n        if (m_iParentChannel[0] == iChannel)\n            StopAnim(0, uiTime);\n\n        SetAnim(m_pAnim[0]->GetName(), uiTime, -1, iChannel, m_fSpeed[0], m_uiForceLength[0], false, m_iParentChannel[iChannel] != iChannel);\n        m_uiStartTime[iChannel] = m_uiStartTime[0];\n        m_fSpeed[iChannel] = m_fSpeed[0];\n        m_uiForceLength[iChannel] = m_uiForceLength[0];\n        m_iOffsetTime[iChannel] = m_iOffsetTime[0];\n        m_iParentChannel[iChannel] = 0;\n    }\n    else\n    {\n        SetAnim(m_sDefaultAnimName, uiTime, -1, iChannel, 1.0f, 0, iChannel == 0, iChannel == 0);\n        m_iParentChannel[iChannel] = iChannel;\n    }\n}\n\n\n/*====================\n  CSkeleton::HasAnim\n  ====================*/\nbool    CSkeleton::HasAnim(const tstring &sAnim)\n{\n    if (!m_pModel)\n        return false;\n\n    return (m_pModel->GetAnim(sAnim) != nullptr);\n}\n\n\n/*====================\n  CSkeleton::ProcessAnimRequests\n  ====================*/\nvoid    CSkeleton::ProcessAnimRequests(uint uiTime)\n{\n    // Process StopAnim's\n    for (int n(0); n < NUM_ANIM_CHANNELS; ++n)\n    {\n        if (m_aAnimRequest[n].uiTime == INVALID_TIME)\n            continue;\n\n        if (m_aAnimRequest[n].sAnim.empty())\n        {\n            StopAnim(n, m_aAnimRequest[n].uiTime);\n\n            m_aAnimRequest[n].sAnim.clear();\n            m_aAnimRequest[n].uiTime = INVALID_TIME;\n        }\n    }\n\n    // Process StartAnim's\n    for (int n(NUM_ANIM_CHANNELS - 1); n >= 0; --n)\n    {\n        if (m_aAnimRequest[n].uiTime == INVALID_TIME)\n            continue;\n\n        if (!m_aAnimRequest[n].sAnim.empty())\n        {\n            StartAnim(m_aAnimRequest[n].sAnim, m_aAnimRequest[n].uiTime, n, m_aAnimRequest[n].iBlendTime, m_aAnimRequest[n].fSpeed, m_aAnimRequest[n].uiForceLength);\n\n            m_aAnimRequest[n].sAnim.clear();\n            m_aAnimRequest[n].uiTime = INVALID_TIME;\n        }\n    }\n}\n\n\n/*====================\n  CSkeleton::PoseStandard\n  ====================*/\nvoid    CSkeleton::PoseStandard(uint uiTime)\n{\n    PROFILE(\"CSkeleton::PoseStandard\");\n\n    m_bIsCharacter = false;\n    m_fPrevPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fYaw = 0.0f;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    PoseSkeleton(uiTime, 0);\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::Pose\n  ====================*/\nvoid    CSkeleton::Pose(uint uiTime, float fParam1, float fParam2)\n{\n    if (m_pModel == nullptr)\n        return;\n\n    m_uiPrevPoseTime = m_uiPoseTime;\n    m_uiPoseTime = uiTime;\n\n    ProcessAnimRequests(uiTime);\n\n    switch(m_pModel->GetPoseType())\n    {\n    default:\n    case POSE_STANDARD:\n        PoseStandard(uiTime);\n        break;\n\n    case POSE_CHARACTER:\n        PoseCharacter(uiTime, fParam1, fParam2);\n        break;\n\n    case POSE_VEHICLE:\n        PoseVehicle(uiTime, fParam1);\n        break;\n\n    case POSE_GADGET:\n        PoseGadget(uiTime, fParam1, fParam2);\n        break;\n    }\n}\n\n\n/*====================\n  CSkeleton::PoseCharacter\n\n  Specialized character version of the Pose functions\n  ====================*/\nvoid    CSkeleton::PoseCharacter(uint uiTime, float fPitch, float fYaw)\n{\n    PROFILE(\"CSkeleton::PoseCharacter\");\n\n    m_bIsCharacter = true;\n    m_fPrevPitch = m_fPitch;\n    m_fPrevYaw = m_fYaw;\n    m_fPitch = fPitch;\n    m_fYaw = fYaw;\n    m_uiSavedPoseTime = uiTime;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    uint uiBip01Spine(m_pModel->GetBoneIndex(_T(\"Bip01 Spine\")));\n\n    // *** Channel 0 ***\n    // Mask everything above the spine\n    SetBoneState(0);\n    SetBoneState(uiBip01Spine, POSE_MASKED);\n\n    PoseSkeleton(uiTime, 0);\n\n    // *** Channel 1 ***\n    // Mask everything below the spine so only the upper\n    // body gets posed\n    SetBoneState(POSE_MASKED);\n    SetBoneState(uiBip01Spine, 0);\n\n    PoseSkeleton(uiTime, 1);\n\n    if (fPitch > 180.0f)\n        fPitch -= 360.0f;\n    if (fPitch < -180.0f)\n        fPitch += 360.0f;\n\n    if (fYaw > 180.0f)\n        fYaw -= 360.0f;\n    if (fYaw < -180.0f)\n        fYaw += 360.0f;\n\n    // Head movements\n    // HACK: For some reason pitch and yaw values are swapped in the biped\n    // Biped orients X towards children\n    RotateBone(_T(\"Bip01 Head\"), -fPitch / 4.0f, 0, fYaw * 0.25f, true);\n    RotateBone(_T(\"Bip01 Spine\"), -fPitch / 6.0f, 0, fYaw * 0.75f, true);\n\n    // Get the final world coordinate transformation, then\n    // unmask the legs\n    SetBoneState(0);\n\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::PoseVehicle\n\n  Specialized character version of the Pose functions\n  ====================*/\nvoid    CSkeleton::PoseVehicle(uint uiTime, uint uiWheelTime)\n{\n    PROFILE(\"CSkeleton::PoseVehicle\");\n\n    m_bIsCharacter = false;\n    m_fPrevPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fYaw = 0.0f;\n\n    // Make the posing happier\n    m_uiStartTime[0] = 0;\n    m_uiBlendTime[0] = 0;\n    m_uiBlendStartTime[0] = 0;\n    m_iOffsetTime[0] = 0;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    // *** Channel 0 ***\n    // Mask everything above the spine\n    SetBoneState(0);\n    SetBoneState(_T(\"Bip01 Spine\"), POSE_MASKED);\n\n    PoseSkeleton(uiWheelTime, 0);\n\n    // *** Channel 1 ***\n    // Mask everything below the spine so only the upper\n    // body gets posed\n    SetBoneState(POSE_MASKED);\n    SetBoneState(_T(\"Bip01 Spine\"), 0);\n\n    PoseSkeleton(uiTime, 1);\n\n    // Get the final world coordinate transformation, then\n    // unmask the legs\n    SetBoneState(0);\n\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::PoseGadget\n\n  Specialized character version of the Pose functions\n  ====================*/\nvoid    CSkeleton::PoseGadget(uint uiTime, float fPitch, float fYaw)\n{\n    PROFILE(\"CSkeleton::PoseGadget\");\n\n    m_bIsCharacter = true;\n    m_fPrevPitch = m_fPitch;\n    m_fPrevYaw = m_fYaw;\n    m_fPitch = fPitch;\n    m_fYaw = fYaw;\n\n    if (!m_pModel)\n        return;\n\n    if (!CheckAnims(uiTime))\n        return;\n\n    PoseSkeleton(uiTime, 0);\n\n    if (fPitch > 180.0f)\n        fPitch -= 360.0f;\n    if (fPitch < -180.0f)\n        fPitch += 360.0f;\n\n    if (fYaw > 180.0f)\n        fYaw -= 360.0f;\n    if (fYaw < -180.0f)\n        fYaw += 360.0f;\n\n    RotateBone(_T(\"gun_pivot\"), fYaw, 0, -fPitch, true);\n\n    CalcWorldTransforms();\n\n    if (m_vEventCmds.size() >= 256)\n        m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::PoseLite\n  ====================*/\nvoid    CSkeleton::PoseLite(uint uiTime)\n{\n    if (m_pModel == nullptr)\n        return;\n\n    ProcessAnimRequests(uiTime);\n\n    switch (m_pModel->GetPoseType())\n    {\n    default:\n    case POSE_STANDARD:\n    case POSE_GADGET:\n        PoseSkeletonLite(uiTime, 0);\n        break;\n\n    case POSE_CHARACTER:\n    case POSE_VEHICLE:\n        PoseSkeletonLite(uiTime, 0);\n        PoseSkeletonLite(uiTime, 1);\n        break;\n    }\n}\n\n\n/*====================\n  CSkeleton::CheckAnims\n  ====================*/\nbool    CSkeleton::CheckAnims(uint uiTime)\n{\n    for (int iChannel(0); iChannel < NUM_ANIM_CHANNELS; ++iChannel)\n    {\n        if (m_pAnim[iChannel] == nullptr)\n            StartAnim(m_sDefaultAnimName, uiTime, iChannel);\n        if (m_pAnim[iChannel] == nullptr)\n        {\n            Invalidate();\n            return false;\n        }\n        //else\n        //  m_bPassiveAnim[iChannel] = (m_pAnim[iChannel]->GetName() == m_sDefaultAnimName);\n    }\n    return true;\n}\n\n\n/*====================\n  CSkeleton::HasValidAnims\n  ====================*/\nbool    CSkeleton::HasValidAnims()\n{\n    for (int iChannel(0); iChannel < NUM_ANIM_CHANNELS; ++iChannel)\n    {\n        if (m_pAnim[iChannel] == nullptr)\n            return false;\n    }\n    return true;\n}\n\n\n/*====================\n  CSkeleton::PoseSkeleton\n  ====================*/\nvoid    CSkeleton::PoseSkeleton(uint uiTime, int iChannel)\n{\n    PROFILE(\"PoseSkeleton\");\n\n    if (skel_noPose)\n        return;\n\n    // Make sure we have an anim to pose\n    if (!CheckAnims(uiTime))\n        return;\n\n    if (uiTime < m_uiStartTime[iChannel])\n        uiTime = m_uiStartTime[iChannel];\n\n    // Determine hi and lo frames and interpolation amount\n    int     iAnimTime(m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]));\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    if (iAnimTime - m_iLastAnimTime[iChannel] > 0xffff)\n    {\n        if (skel_debug)\n            Console.Warn << _T(\"CSkeleton::PoseSkeleton delta AnimTime == \") << iAnimTime - m_iLastAnimTime[iChannel] << newl;\n\n        if (iAnimTime < 0xffff)\n            m_iLastAnimTime[iChannel] = 0;\n        else\n            m_iLastAnimTime[iChannel] = iAnimTime - 0xffff;\n    }\n\n    bool bEnd = false;\n    if (!m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]) &&\n        !m_bPassiveAnim[iChannel])\n        bEnd = true;\n\n    // Check for events on this frame\n    if ((m_pModel->GetPoseType() != POSE_VEHICLE && (iChannel == 0 || m_pAnim[iChannel] != m_pAnim[0]))\n        || (m_pModel->GetPoseType() == POSE_VEHICLE && (iChannel == 1 || m_pAnim[iChannel] != m_pAnim[1])))\n        m_pAnim[iChannel]->CheckEvents(this, m_iLastAnimTime[iChannel], iAnimTime, iChannel);\n    m_iLastAnimTime[iChannel] = iAnimTime;\n\n    // Get the clip\n    CClip *pClip = g_ResourceManager.GetClip(m_pAnim[iChannel]->GetClip());\n    if (pClip)\n    {\n        int iNumFrames = pClip->GetNumFrames();\n        if (iNumFrames != 0)\n        {\n            // Make sure we don't get an access violation trying to access bad frames\n            iLoFrame = (int)iLoFrame % iNumFrames;\n            iHiFrame = (int)iHiFrame % iNumFrames;\n        }\n    }\n\n    {\n        PROFILE(\"PoseBones\");\n\n        // iLoFrame and iHiFrame should be valid array indexes at this point\n        PoseBones(m_pAnim[iChannel]->GetMotions(), iLoFrame, iHiFrame, fLerp, iChannel);\n    }\n\n    {\n        PROFILE(\"UpdateBones\");\n\n        uint uiBlendTime(m_fSpeed[iChannel] != 0.0f ? INT_ROUND(m_uiBlendTime[iChannel] / m_fSpeed[iChannel]) : 0);\n\n        // Blending\n        if (uiBlendTime && uiTime - m_uiBlendStartTime[iChannel] < uiBlendTime && skel_blendAnims)\n        {\n            float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(uiBlendTime)));\n            UpdateBonesLerp(fBlend, iChannel);\n        }\n        else\n            UpdateBones(iChannel);\n    }\n\n    Validate();\n\n    m_uiTime[iChannel] = uiTime;\n\n    if (bEnd)\n        StopAnim(iChannel, uiTime);\n\n    m_bValidPose[iChannel] = true;\n}\n\n\n/*====================\n  CSkeleton::PoseSkeletonLite\n  ====================*/\nvoid    CSkeleton::PoseSkeletonLite(uint uiTime, int iChannel)\n{\n    // Make sure we have an anim to pose\n    if (!CheckAnims(uiTime))\n        return;\n\n    if (uiTime < m_uiStartTime[iChannel])\n        uiTime = m_uiStartTime[iChannel];\n\n    // Determine hi and lo frames and interpolation amount\n    int     iAnimTime(m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]));\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    if (iAnimTime - m_iLastAnimTime[iChannel] > 0xffff)\n    {\n        if (skel_debug)\n            Console.Warn << _T(\"CSkeleton::PoseSkeletonLite delta AnimTime == \") << iAnimTime - m_iLastAnimTime[iChannel] << newl;\n\n        if (iAnimTime < 0xffff)\n            m_iLastAnimTime[iChannel] = 0;\n        else\n            m_iLastAnimTime[iChannel] = iAnimTime - 0xffff;\n    }\n\n    bool bEnd = false;\n    if (!m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]) &&\n        !m_bPassiveAnim[iChannel])\n        bEnd = true;\n\n    // Check for events on this frame\n    if ((m_pModel->GetPoseType() != POSE_VEHICLE && (iChannel == 0 || m_pAnim[iChannel] != m_pAnim[0]))\n        || (m_pModel->GetPoseType() == POSE_VEHICLE && (iChannel == 1 || m_pAnim[iChannel] != m_pAnim[1])))\n        m_pAnim[iChannel]->CheckEvents(this, m_iLastAnimTime[iChannel], iAnimTime, iChannel);\n    m_iLastAnimTime[iChannel] = iAnimTime;\n}\n\n\n/*====================\n  CSkeleton::RelativeToWorldRecurse\n  ====================*/\nvoid    CSkeleton::RelativeToWorldRecurse(uint uiBone)\n{\n    SBoneState  *pBoneState(GetBoneState(uiBone));\n\n    if (!(pBoneState->poseState & POSE_MASKED))\n    {\n        const CBone *pParent(m_pModel->GetBoneParent(uiBone));\n        const CBone *pThis(m_pModel->GetBone(uiBone));\n        if (pParent != nullptr)\n        {\n            M_MultiplyMatrix(&m_pBoneStates[pParent->GetIndex()].tm_local, &pBoneState->tm, &pBoneState->tm_local);\n            M_MultiplyMatrix(&pBoneState->tm_local, &pThis->m_invBase, &pBoneState->tm_world);\n        }\n        else\n        {\n            pBoneState->tm_local = pBoneState->tm;\n            M_MultiplyMatrix(&pBoneState->tm_local, &pThis->m_invBase, &pBoneState->tm_world);\n        }\n    }\n\n    const uivector *pvChildren(m_pModel->GetBoneChildren(uiBone));\n    uivector::const_iterator itEnd(pvChildren->end());\n    for (uivector::const_iterator it(pvChildren->begin()); it != itEnd; ++it)\n        RelativeToWorldRecurse(*it);\n}\n\n\n/*====================\n  CSkeleton::CalcWorldTransforms\n  ====================*/\nvoid    CSkeleton::CalcWorldTransforms()\n{\n    PROFILE(\"CSkeleton::CalcWorldTransforms\");\n\n    RelativeToWorldRecurse(0);\n}\n\n\n/*====================\n  CSkeleton::RotateBone\n\n  set euler angles for bone.  'multiply' specifies whether or not\n  to multiply by the current transform or to use an absolute\n  orientation\n  ====================*/\nvoid    CSkeleton::RotateBone(const tstring &sBoneName, float yaw_offset, float roll_offset, float pitch_offset, bool multiply)\n{\n    uint uiBone = m_pModel->GetBoneIndex(sBoneName);\n    if (uiBone == INVALID_BONE)\n        return;\n\n    matrix43_t rotation = g_identity43;\n\n    // Postmultiply the rotation\n    M_GetAxis(pitch_offset, roll_offset, yaw_offset, rotation.axis);\n\n    if (multiply)\n    {\n        matrix43_t temp;\n        M_MultiplyMatrix(&GetBoneState(uiBone)->tm, &rotation, &temp);\n        GetBoneState(uiBone)->tm = temp;\n    }\n    else\n    {\n        MemManager.Copy(GetBoneState(uiBone)->tm.axis, rotation.axis, sizeof(rotation.axis));\n    }\n}\n\n\n/*====================\n  CSkeleton::SetModel\n  ====================*/\nvoid    CSkeleton::SetModel(ResHandle hModel)\n{\n    // store the new model and add it as a resource dependent.\n    g_ResourceManager.RemoveResourceWatcher(this, m_hModel);\n    m_hModel = hModel;\n    g_ResourceManager.AddResourceWatcher(this, hModel);\n\n    CModel *pModel(g_ResourceManager.GetModel(hModel));\n\n    if (pModel == nullptr)\n    {\n        Clear();\n        Invalidate();\n        return;\n    }\n\n    IModel *pIModel = pModel->GetModelFile();\n\n    if (pIModel == nullptr || pIModel->GetType() != MODEL_K2)\n    {\n        Clear();\n        Invalidate();\n        return;\n    }\n\n    CK2Model *pK2Model = static_cast<CK2Model *>(pIModel);\n\n    if (pK2Model == nullptr)\n    {\n        Clear();\n        Invalidate();\n        return;\n    }\n\n    // If the skeleton is using a new model, clear all the data\n    if (pK2Model != m_pModel)\n    {\n        Clear();\n        m_pModel = pK2Model;\n        m_uiNumBones = pK2Model->GetNumBones();\n\n        // Grab bone allocated bone data from bone pool\n        SSkeletonBoneData cBoneData;\n        SkeletonBonePool.Allocate(m_uiNumBones, cBoneData);\n\n        m_pBoneStates = cBoneData.pBoneStates;\n        m_pTempBoneStates = cBoneData.pTempBoneStates;\n\n        MemManager.Set(m_pBoneStates, 0, sizeof(SBoneState) * m_uiNumBones);\n        MemManager.Set(m_pTempBoneStates, 0, sizeof(SBoneState) * m_uiNumBones);\n\n        // Reset masks, etc\n        for (size_t z(0); z < pK2Model->GetNumBones(); ++z)\n        {\n            m_pBoneStates[z].poseState = 0;\n            m_pBoneStates[z].visibility = 255;\n\n            m_pTempBoneStates[z].poseState = 0;\n            m_pTempBoneStates[z].visibility = 255;\n        }\n\n        for (int i = 0; i < NUM_ANIM_CHANNELS; ++i)\n        {\n            m_pCurrentPose[i] = cBoneData.pCurrentPose[i];\n            m_pSavedPose[i] = cBoneData.pSavedPose[i];\n            m_pTempPose[i] = cBoneData.pTempPose[i];\n        }\n\n        const tsvector &vSpawnEvents(pIModel->GetSpawnEvents());\n        for (tsvector::const_iterator it(vSpawnEvents.begin()); it != vSpawnEvents.end(); ++it)\n            AddEvent(*it, 0);\n\n        g_ResourceManager.AddResourceWatcher(this, hModel);\n    }\n\n    Validate();\n}\n\n\n/*====================\n  CSkeleton::Rebuild\n  ====================*/\nvoid    CSkeleton::Rebuild(ResHandle hResource)\n{\n    Clear();\n    SetModel(hResource);\n}\n\n\n/*====================\n  CSkeleton::ClearEvents\n  ====================*/\nvoid    CSkeleton::ClearEvents()\n{\n    m_vEventCmds.clear();\n}\n\n\n/*====================\n  CSkeleton::CheckEvents\n  ====================*/\nbool    CSkeleton::CheckEvents()\n{\n    return m_vEventCmds.size() > 0;\n}\n\n\n/*====================\n  CSkeleton::AddEvent\n  ====================*/\nvoid    CSkeleton::AddEvent(const tstring &sCmd, int iTimeNudge)\n{\n    if (m_vEventCmds.size() >= 255)\n    {\n        Console.Warn << _T(\"Large number of events on skeleton\") << newl;\n        return;\n    }\n\n    m_vEventCmds.push_back(SAnimEventCmd(sCmd, iTimeNudge));\n}\n\n\n/*====================\n  CSkeleton::GetAnimIndex\n  ====================*/\nuint    CSkeleton::GetAnimIndex(int iChannel)\n{\n    if (m_pAnim[iChannel])\n        return m_pAnim[iChannel]->GetIndex();\n    else\n        return -1;\n}\n\n\n/*====================\n  CSkeleton::GetAnimIndex\n  ====================*/\nint     CSkeleton::GetAnimIndex(const tstring &sAnim)\n{\n    if (m_pModel != nullptr)\n        return m_pModel->GetAnimIndex(sAnim);\n    else\n        return -1;\n}\n\n\n/*====================\n  CSkeleton::TempUpdateBonesLerp\n\n  update skeleton local tms (temp version)\n  ====================*/\nvoid    CSkeleton::TempUpdateBonesLerp(uint uiBone, float fLerp, int iChannel)\n{\n    while (uiBone != INVALID_INDEX)\n    {\n        SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n        {\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        SBoneXForm &cSavedPose(m_pSavedPose[iChannel][uiBone]);\n        SBoneXForm &cTempPose(m_pTempPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = LERP(fLerp, cSavedPose.v3Pos, cTempPose.v3Pos);\n\n        // Rotation\n        vec4_t quat;\n        M_LerpQuat(fLerp, vec4_cast(cSavedPose.v4Quat), vec4_cast(cTempPose.v4Quat), vec4_cast(quat));\n        M_QuatToAxis(quat, pBoneState->tm.axis);\n\n        // Scale\n        M_MultVec3(pBoneState->tm.axis[X], LERP(fLerp, cSavedPose.v3Scale[X], cTempPose.v3Scale[X]), pBoneState->tm.axis[X]);\n        M_MultVec3(pBoneState->tm.axis[Y], LERP(fLerp, cSavedPose.v3Scale[Y], cTempPose.v3Scale[Y]), pBoneState->tm.axis[Y]);\n        M_MultVec3(pBoneState->tm.axis[Z], LERP(fLerp, cSavedPose.v3Scale[Z], cTempPose.v3Scale[Z]), pBoneState->tm.axis[Z]);\n\n        uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n    }\n}\n\n\n/*====================\n  CSkeleton::TempUpdateBones\n\n  update skeleton local tms (temp version)\n  ====================*/\nvoid    CSkeleton::TempUpdateBones(uint uiBone, int iChannel)\n{\n    while (uiBone != INVALID_INDEX)\n    {\n        SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n        if (pBoneState->poseState & POSE_MASKED)\n        {\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        SBoneXForm &cTempPose(m_pTempPose[iChannel][uiBone]);\n\n        // Translation\n        CVec3_cast(pBoneState->tm.pos) = cTempPose.v3Pos;\n    \n        // Rotation\n        M_QuatToAxis(vec4_cast(cTempPose.v4Quat), pBoneState->tm.axis);\n\n        // Scale\n        M_MultVec3(pBoneState->tm.axis[X], cTempPose.v3Scale[X], pBoneState->tm.axis[X]);\n        M_MultVec3(pBoneState->tm.axis[Y], cTempPose.v3Scale[Y], pBoneState->tm.axis[Y]);\n        M_MultVec3(pBoneState->tm.axis[Z], cTempPose.v3Scale[Z], pBoneState->tm.axis[Z]);\n\n        uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n    }\n}\n\n\n/*====================\n  CSkeleton::TempPoseBone\n  ====================*/\nvoid    CSkeleton::TempPoseBone(SBoneMotion **ppMotions, uint uiBone, int iLoFrame, int iHiFrame, float fLerp, int iChannel)\n{\n    if (m_pModel->GetNumBones() <= uiBone)\n        return;\n\n    while (uiBone != INVALID_INDEX)\n    {\n        if (GetTempBoneState(uiBone)->poseState & POSE_MASKED)\n        {\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        if (!ppMotions[uiBone])\n        {\n            m_pTempPose[iChannel][uiBone].v3Pos = CVec3f(0.0f, 0.0f, 0.0f);\n            m_pTempPose[iChannel][uiBone].v4Quat = CVec4f(0.0f, 0.0f, 0.0f, 1.0f);\n            m_pTempPose[iChannel][uiBone].v3Scale = CVec3f(1.0f, 1.0f, 1.0f);\n\n            uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n            continue;\n        }\n\n        GetBoneXform(ppMotions[uiBone], iLoFrame, iHiFrame, fLerp, m_pTempPose[iChannel][uiBone]);\n\n        uiBone = m_pModel->GetBone(uiBone)->GetParentIndex();\n    }\n}\n\n\n/*====================\n  CSkeleton::TempPose\n\n  Pose function which changes a temp bone state structure instead of the normal bone state structure\n  ====================*/\nvoid    CSkeleton::TempPose(uint uiTime, uint uiBone, int iChannel)\n{\n    if (uiTime < m_uiStartTime[iChannel])\n        uiTime = m_uiStartTime[iChannel]; // don't try to pose back farther then we started this animation\n\n    if (skel_noPose)\n        return;\n\n    // Make sure we have an anim to pose\n    if (!CheckAnims(uiTime))\n        return;\n\n    // Determine hi and lo frames and interpolation amount\n    int     iAnimTime(m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]));\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]);\n\n    // Get the clip\n    CClip *pClip = g_ResourceManager.GetClip(m_pAnim[iChannel]->GetClip());\n    if (pClip)\n    {\n        int iNumFrames = pClip->GetNumFrames();\n        if (iNumFrames != 0)\n        {\n            // Make sure we don't get an access violation trying to access bad frames\n            iLoFrame = (int)iLoFrame % iNumFrames;\n            iHiFrame = (int)iHiFrame % iNumFrames;\n        }\n    }\n\n    // iLoFrame and iHiFrame should be valid array indices at this point\n    TempPoseBone(m_pAnim[iChannel]->GetMotions(), uiBone, iLoFrame, iHiFrame, fLerp, iChannel);\n\n    // Blending\n    if (m_uiBlendTime[iChannel] && uiTime - m_uiBlendStartTime[iChannel] < m_uiBlendTime[iChannel] && skel_blendAnims)\n    {\n        float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(m_uiBlendTime[iChannel])));\n        TempUpdateBonesLerp(uiBone, fBlend, iChannel);\n    }\n    else\n        TempUpdateBones(uiBone, iChannel);\n}\n\n\n/*====================\n  CSkeleton::TempCalcWorldTransforms\n  ====================*/\nvoid    CSkeleton::TempCalcWorldTransforms(uint uiBone)\n{\n    uint uiParentIndex(m_pModel->GetBone(uiBone)->GetParentIndex());\n\n    if (uiParentIndex != INVALID_INDEX)\n    {\n        if (uiParentIndex > m_pModel->GetNumBones())\n        {\n            Console.Warn << _T(\"CSkeleton::TempCalcWorldTransforms() - Invalid bone parent index: \") << uiParentIndex << _T(\", model: \") << m_pModel->GetName() << _T(\", model bones: \") << m_pModel->GetNumBones() << _T(\", skeleton bones: \") << GetNumBones() << _T(\", child bone: \") << uiBone << newl;\n            uiParentIndex = INVALID_INDEX;\n        }\n        else\n            TempCalcWorldTransforms(uiParentIndex);\n    }\n\n    SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n    if (!(pBoneState->poseState & POSE_MASKED))\n    {\n        if (uiParentIndex != INVALID_INDEX)\n            M_MultiplyMatrix(&m_pTempBoneStates[uiParentIndex].tm_local, &pBoneState->tm, &pBoneState->tm_local);\n        else\n            pBoneState->tm_local = pBoneState->tm;\n    }\n}\n\n\n/*====================\n  CSkeleton::SetTempBoneState\n  ====================*/\nvoid    CSkeleton::SetTempBoneState(uint uiBone, int iState)\n{\n    if (uiBone == INVALID_BONE)\n        return;\n\n    m_pTempBoneStates[uiBone].poseState = iState;\n\n    CBone *pBone(m_pModel->GetBone(uiBone));\n    uint uiNumChildren(pBone->NumChildren());\n    for (uint n(0); n < uiNumChildren; ++n)\n    {\n        uint uiChild(pBone->GetChildIndex(n));\n        SetTempBoneState(uiChild, iState);\n    }\n}\n\n\n/*====================\n  CSkeleton::SetTempBoneState\n  ====================*/\nvoid    CSkeleton::SetTempBoneState(const tstring &sBoneName, int iState)\n{\n    uint uiBone(m_pModel->GetBoneIndex(sBoneName));\n    if (uiBone == INVALID_BONE)\n        return;\n\n    SetTempBoneState(uiBone, iState);\n}\n\n\n/*====================\n  CSkeleton::SetTempBoneState\n  ====================*/\nvoid    CSkeleton::SetTempBoneState(int iState)\n{\n    for (uint n(0); n < m_uiNumBones; ++n)\n        m_pTempBoneStates[n].poseState = iState;\n}\n\n\n/*====================\n  CSkeleton::TempRotateBone\n\n  set euler angles for bone.  'multiply' specifies whether or not\n  to multiply by the current transform or to use an absolute\n  orientation\n  ====================*/\nvoid    CSkeleton::TempRotateBone(const tstring &sBoneName, float yaw_offset, float roll_offset, float pitch_offset, bool multiply)\n{\n    uint uiBone = m_pModel->GetBoneIndex(sBoneName);\n    if (uiBone == INVALID_BONE)\n        return;\n\n    SBoneState  *pBoneState(GetTempBoneState(uiBone));\n\n    if (m_pModel->GetBone(uiBone)->GetParentIndex() != INVALID_INDEX)\n        TempCalcWorldTransforms(m_pModel->GetBone(uiBone)->GetParentIndex());\n\n    matrix43_t rotation = g_identity43;\n\n    // Postmultiply the rotation\n    M_GetAxis(pitch_offset, roll_offset, yaw_offset, rotation.axis);\n\n    if (multiply)\n    {\n        matrix43_t temp;\n        M_MultiplyMatrix(&pBoneState->tm, &rotation, &temp);\n        pBoneState->tm = temp;\n    }\n    else\n    {\n        MemManager.Copy(pBoneState->tm.axis, rotation.axis, sizeof(rotation.axis));\n    }\n}\n\n\n/*====================\n  CSkeleton::GetBonePose\n  ====================*/\nCVec3f  CSkeleton::GetBonePose(uint uiBone, uint uiTime)\n{\n    PROFILE(\"CSkeleton::GetBonePose\");\n\n    if (uiBone == INVALID_BONE || !m_pModel)\n        return V3_ZERO;\n\n    if (uiTime == m_uiPoseTime || m_pModel->GetPoseType() == POSE_VEHICLE)\n        return CVec3_cast(m_pBoneStates[uiBone].tm_local.pos);\n\n    if (m_pModel->GetPoseType() == POSE_CHARACTER)\n    {\n        uint uiBip01Spine(m_pModel->GetBoneIndex(_T(\"Bip01 Spine\")));\n\n        // *** Channel 0 ***\n        // Mask everything above the spine\n        SetTempBoneState(0);\n        SetTempBoneState(uiBip01Spine, POSE_MASKED);\n\n        TempPose(uiTime, uiBone, 0);\n\n        // *** Channel 1 ***\n        // Mask everything below the spine so only the upper\n        // body gets posed\n        SetTempBoneState(POSE_MASKED);\n        SetTempBoneState(uiBip01Spine, 0);\n\n        TempPose(uiTime, uiBone, 1);\n\n        // Head/Torso movements\n        if (m_uiSavedPoseTime != INVALID_TIME)\n        {\n            float fPitch;\n            float fYaw;\n\n            if (m_uiPrevPoseTime != INVALID_TIME)\n            {\n                fPitch = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevPitch, m_fPitch);\n                fYaw = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevYaw, m_fYaw);\n            }\n            else\n            {\n                fPitch = m_fPitch;\n                fYaw = m_fYaw;\n            }\n\n            if (fPitch > 180.0f)\n                fPitch -= 360.0f;\n            if (fPitch < -180.0f)\n                fPitch += 360.0f;\n\n            if (fYaw > 180.0f)\n                fYaw -= 360.0f;\n            if (fYaw < -180.0f)\n                fYaw += 360.0f;\n            \n            if (fYaw || fPitch)\n            {\n                // HACK: For some reason pitch and yaw values are swapped in the biped\n                // Biped orients X towards children\n                TempRotateBone(_T(\"Bip01 Head\"), -fPitch / 4.0f, 0, fYaw * 0.25f, true);\n                TempRotateBone(_T(\"Bip01 Spine\"), -fPitch / 6.0f, 0, fYaw * 0.75f, true);\n            }\n        }\n\n        // Get the final world coordinate transformation, then\n        // unmask the legs\n        SetTempBoneState(0);\n    }\n    else\n    {\n        TempPose(uiTime, uiBone, 0);\n    }\n\n    {\n        PROFILE(\"CSkeleton::TempCalcWorldTransforms\");\n        TempCalcWorldTransforms(uiBone);\n    }\n\n    return CVec3_cast(m_pTempBoneStates[uiBone].tm_local.pos);\n}\n\n\n/*====================\n  CSkeleton::GetBonePoseAxisPos\n  ====================*/\nvoid    CSkeleton::GetBonePoseAxisPos(uint uiBone, uint uiTime, CAxis &aOutAxis, CVec3f &v3OutPos)\n{\n    PROFILE(\"CSkeleton::GetBonePoseAxisPos\");\n\n    if (uiBone == INVALID_BONE || !m_pModel)\n    {\n        aOutAxis = CAxis(0.0f, 0.0f, 0.0f);\n        v3OutPos = CVec3f(0.0f, 0.0f, 0.0f);\n        return;\n    }\n\n    if (uiTime == m_uiPoseTime || m_pModel->GetPoseType() == POSE_VEHICLE)\n    {\n        aOutAxis = CAxis_cast(m_pBoneStates[uiBone].tm_local.axis);\n        v3OutPos = CVec3_cast(m_pBoneStates[uiBone].tm_local.pos);\n        return;\n    }\n\n    if (m_pModel->GetPoseType() == POSE_CHARACTER)\n    {\n        uint uiBip01Spine(m_pModel->GetBoneIndex(_T(\"Bip01 Spine\")));\n\n        // *** Channel 0 ***\n        // Mask everything above the spine\n        SetTempBoneState(0);\n        SetTempBoneState(uiBip01Spine, POSE_MASKED);\n\n        TempPose(uiTime, uiBone, 0);\n\n        // *** Channel 1 ***\n        // Mask everything below the spine so only the upper\n        // body gets posed\n        SetTempBoneState(POSE_MASKED);\n        SetTempBoneState(uiBip01Spine, 0);\n\n        TempPose(uiTime, uiBone, 1);\n\n        // Head/Torso movements\n        if (m_uiSavedPoseTime != INVALID_TIME)\n        {\n            float fPitch;\n            float fYaw;\n\n            if (m_uiPrevPoseTime != INVALID_TIME)\n            {\n                fPitch = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevPitch, m_fPitch);\n                fYaw = M_LerpAngle(ILERP(uiTime, m_uiPrevPoseTime, m_uiSavedPoseTime), m_fPrevYaw, m_fYaw);\n            }\n            else\n            {\n                fPitch = m_fPitch;\n                fYaw = m_fYaw;\n            }\n\n            if (fPitch > 180.0f)\n                fPitch -= 360.0f;\n            if (fPitch < -180.0f)\n                fPitch += 360.0f;\n\n            if (fYaw > 180.0f)\n                fYaw -= 360.0f;\n            if (fYaw < -180.0f)\n                fYaw += 360.0f;\n            \n            if (fYaw || fPitch)\n            {\n                // HACK: For some reason pitch and yaw values are swapped in the biped\n                // Biped orients X towards children\n                TempRotateBone(_T(\"Bip01 Head\"), -fPitch / 4.0f, 0, fYaw * 0.25f, true);\n                TempRotateBone(_T(\"Bip01 Spine\"), -fPitch / 6.0f, 0, fYaw * 0.75f, true);\n            }\n        }\n\n        // Get the final world coordinate transformation, then\n        // unmask the legs\n        SetTempBoneState(0);\n    }\n    else\n    {\n        TempPose(uiTime, uiBone, 0);\n    }\n\n    {\n        TempCalcWorldTransforms(uiBone);\n    }\n\n    aOutAxis = CAxis_cast(m_pTempBoneStates[uiBone].tm_local.axis);\n    v3OutPos = CVec3_cast(m_pTempBoneStates[uiBone].tm_local.pos);\n\n#if 0\n    if (!aOutAxis.Forward().IsValid() || \n        !aOutAxis.Right().IsValid() ||\n        !aOutAxis.Up().IsValid() ||\n        !v3OutPos.IsValid())\n    {\n        Console << _T(\"CSkeleton::GetBonePoseAxisPos - NAN\") << newl;\n        \n        aOutAxis = CAxis(0.0f, 0.0f, 0.0f);\n        v3OutPos = CVec3f(0.0f, 0.0f, 0.0f);\n    }\n#endif\n\n    return;\n}\n\n\n/*====================\n  CSkeleton::GetCurrentAnimName\n  ====================*/\nconst tstring&  CSkeleton::GetCurrentAnimName(int iChannel)\n{\n    if (m_pAnim[iChannel])\n        return m_pAnim[iChannel]->GetName();\n    else\n        return TSNULL;\n}\n\n\n/*====================\n  CSkeleton::SetAnimSpeed\n  ====================*/\nvoid    CSkeleton::SetAnimSpeed(float fSpeed, int iChannel)\n{\n    if (m_fSpeed[iChannel] == fSpeed ||\n        m_uiTime[iChannel] == INVALID_TIME ||\n        m_uiStartTime[iChannel] == INVALID_TIME ||\n        m_iParentChannel[iChannel] != iChannel ||\n        !m_pModel || m_pModel->GetPoseType() == POSE_VEHICLE)\n        return;\n\n#if 0\n    int iOldOffsetTime(m_iOffsetTime[iChannel]);\n#endif\n\n    if (fSpeed == 0.0f)\n    {\n        int iAnimTime(INT_FLOOR((m_uiTime[iChannel] - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel])) * m_fSpeed[iChannel]);\n        m_iOffsetTime[iChannel] = iAnimTime;\n    }\n    else\n    {\n        if (m_fSpeed[iChannel] == 0.0f)\n        {\n            int iAnimTime(m_iOffsetTime[iChannel]);\n            m_iOffsetTime[iChannel] = INT_FLOOR((iAnimTime - (m_uiTime[iChannel] - m_uiStartTime[iChannel]) * fSpeed) / fSpeed);\n        }\n        else\n        {\n            int iAnimTime(INT_FLOOR((m_uiTime[iChannel] - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel])) * m_fSpeed[iChannel]);\n            m_iOffsetTime[iChannel] = INT_FLOOR((iAnimTime - (m_uiTime[iChannel] - m_uiStartTime[iChannel]) * fSpeed) / fSpeed);\n        }\n    }\n\n#if 0\n    if (m_iOffsetTime[iChannel] < -1000000)\n    {\n        int x = 0;\n    }\n#endif\n\n    m_fSpeed[iChannel] = fSpeed;\n\n    for (int i(0); i < NUM_ANIM_CHANNELS; ++i)\n    {\n        if (i != iChannel && m_iParentChannel[i] == iChannel)\n        {\n            m_iOffsetTime[i] = m_iOffsetTime[iChannel];\n            m_fSpeed[i] = m_fSpeed[iChannel];\n        }\n    }\n}\n\n\n/*====================\n  CSkeleton::SetAnimTime\n  ====================*/\nvoid    CSkeleton::SetAnimTime(int iAnimTime, int iChannel)\n{\n    if (m_fSpeed[iChannel] == 0.0f)\n    {\n        m_iOffsetTime[iChannel] = iAnimTime;\n    }\n}\n\n\n/*====================\n  CSkeleton::SetAnimTime\n  ====================*/\nvoid    CSkeleton::SetAnimTime(float fFraction, int iChannel)\n{\n    if (m_fSpeed[iChannel] == 0.0f)\n    {\n        m_iOffsetTime[iChannel] = INT_ROUND(m_pAnim[iChannel]->GetNumFrames() * m_pAnim[iChannel]->GetMSperFrame() * fFraction);\n    }\n}\n\n\n/*====================\n  CSkeleton::Pose\n  ====================*/\nvoid    CSkeleton::Pose(uint uiTime, SBoneXForm *pPose)\n{\n    PROFILE(\"CSkeleton::Pose\");\n\n    m_bIsCharacter = false;\n    m_fPrevPitch = 0.0f;\n    m_fPrevYaw = 0.0f;\n    m_fPitch = 0.0f;\n    m_fYaw = 0.0f;\n    int iChannel(0);\n\n    if (!m_pModel)\n        return;\n\n    MemManager.Copy(m_pCurrentPose[iChannel], pPose, sizeof(SBoneXForm) * m_uiNumBones);\n\n    {\n        PROFILE(\"UpdateBones\");\n\n        uint uiBlendTime(m_fSpeed[iChannel] != 0.0f ? INT_ROUND(m_uiBlendTime[iChannel] / m_fSpeed[iChannel]) : 0);\n\n        // Blending\n        if (uiBlendTime && uiTime - m_uiBlendStartTime[iChannel] < uiBlendTime && skel_blendAnims)\n        {\n            float fBlend(M_SmoothStepN((uiTime - m_uiBlendStartTime[iChannel]) / float(uiBlendTime)));\n            UpdateBonesLerp(fBlend, iChannel);\n        }\n        else\n            UpdateBones(iChannel);\n    }\n\n    Validate();\n\n    m_uiTime[iChannel] = uiTime;\n\n    m_bValidPose[iChannel] = true;\n\n    CalcWorldTransforms();\n}\n\n\n/*====================\n  CSkeleton::ComputeAnimFrame\n  ====================*/\nvoid    CSkeleton::ComputeAnimFrame(uint uiTime, int iChannel, int &iAnimTime, float &fFrame, float &fFraction)\n{\n    if (!CheckAnims(uiTime))\n        return;\n\n    // Determine hi and lo frames and interpolation amount\n    iAnimTime = m_fSpeed[iChannel] == 0.0f ? m_iOffsetTime[iChannel] : INT_FLOOR((uiTime - m_uiStartTime[iChannel] + m_iOffsetTime[iChannel]) * m_fSpeed[iChannel]);\n    int     iLoFrame, iHiFrame;\n    float   fLerp;\n\n    bool bEnd = false;\n    if (!m_pAnim[iChannel]->ComputeAnimFrame(iAnimTime, iLoFrame, iHiFrame, fLerp, m_uiForceLength[iChannel]) &&\n        !m_bPassiveAnim[iChannel])\n        bEnd = true;\n\n    fFrame = iLoFrame - m_pAnim[iChannel]->GetStartFrame() + fLerp;\n    fFraction = fFrame / m_pAnim[iChannel]->GetNumFrames();\n}\n\n\n/*====================\n  CSkeleton::RequestStartAnim\n  ====================*/\nvoid    CSkeleton::RequestStartAnim(const tstring &sAnim, uint uiTime, int iChannel, int iBlendTime, float fSpeed, uint uiForceLength)\n{\n    PROFILE(\"CSkeleton::RequestStartAnim\");\n\n    //Console.Dev << \"CSkeleton::RequestStartAnim() - \" << sAnim << _T(\" \") << uiTime << _T(\" \") << iChannel << newl;\n\n    m_aAnimRequest[iChannel].sAnim = sAnim;\n    m_aAnimRequest[iChannel].uiTime = uiTime;\n    m_aAnimRequest[iChannel].iBlendTime = iBlendTime;\n    m_aAnimRequest[iChannel].fSpeed = fSpeed;\n    m_aAnimRequest[iChannel].uiForceLength = uiForceLength;\n}\n\n\n/*====================\n  CSkeleton::RequestStopAnim\n  ====================*/\nvoid    CSkeleton::RequestStopAnim(int iChannel, uint uiTime)\n{\n    PROFILE(\"CSkeleton::RequestStopAnim\");\n\n    m_aAnimRequest[iChannel].sAnim.clear();\n    m_aAnimRequest[iChannel].uiTime = uiTime;\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/k2/c_skeleton.cpp b/src/k2/c_skeleton.cpp
--- a/src/k2/c_skeleton.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/k2/c_skeleton.cpp	(date 1685007426887)
@@ -97,8 +97,6 @@
     }
 
     SkeletonBonePool.Deallocate(cBoneData);
-
-    g_ResourceManager.RemoveResourceWatcher(this, m_hModel);
 }
 
 
Index: src/vid_gl2/gl2_win32.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2008 S2 Games\n// gl2_win32.cpp\n//\n// Win32 specific renderer API functions\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"vid_common.h\"\n\n#include \"../k2/c_uimanager.h\"\n#include \"../k2/c_cursor.h\"\n#include \"../k2/c_resourcemanager.h\"\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nWNDPROC     MainWndProc;\nHINSTANCE   g_hInstance;\nHWND        g_hWnd;\nHDC         g_hDC;\nHGLRC       g_hglrc;\nICONINFO    g_IconInfo = {0};\nHICON       g_hCursorIcon = nullptr;\n\nCVAR_BOOL   (win_changeDisplayMode,     false);\n//=============================================================================\n\n/*====================\n  InitAPIs\n\n  This is what's exported by the DLL and called by the rest of\n  the engine. It's a wrapper to do the windows-specific stuff\n  and call the shared API initialization function, basically.\n  ====================*/\nextern \"C\" __declspec(dllexport)\nvoid    InitAPIs(SVidDriver *vid_api, WNDPROC _MainWndProc, HINSTANCE hInstance)\n{\n    g_hInstance = hInstance;\n    MainWndProc = _MainWndProc;\n\n    InitAPIs_Global(vid_api);\n}\n\n\n/*====================\n  GL_GetHWnd\n  ====================*/\nvoid*   GL_GetHWnd()\n{\n    return g_hWnd;\n}\n\n\n/*====================\n  GL_Init\n  ====================*/\nint     GL_Init()\n{\n    int modenum = 0;\n    BOOL bSuccess(FALSE);\n    DEVMODE devmode;\n    \n    gl_initialized = false;\n\n    ZeroMemory(&devmode, sizeof(devmode));\n    devmode.dmSize = sizeof(DEVMODE);\n\n    // Fill in the default mode (Desktop)\n    if (EnumDisplaySettings(nullptr, ENUM_REGISTRY_SETTINGS, &devmode))\n    {\n        g_VidModes[0].iWidth = devmode.dmPelsWidth;\n        g_VidModes[0].iHeight = devmode.dmPelsHeight;\n        g_VidModes[0].iBpp = devmode.dmBitsPerPel;\n        g_VidModes[0].iRefreshRate = devmode.dmDisplayFrequency;\n        g_VidModes[0].sName = _T(\"Desktop \") + ParenStr(XtoA(g_VidModes[0].iWidth) + _T(\"x\") + XtoA(g_VidModes[0].iHeight) + _T(\"x\") + XtoA(g_VidModes[0].iBpp) + _T(\"@\") + XtoA(g_VidModes[0].iRefreshRate));\n    }\n    else\n        K2System.Error(_T(\"EnumDisplaySettings failed on mode 0\"));\n\n    g_iNumVidModes = 1;  // Always keep mode 0 open\n\n    do\n    {\n        bool bModeExists(false);\n        bSuccess = EnumDisplaySettings(nullptr, modenum, &devmode);\n        if (!bSuccess)\n        {\n            if (modenum == 0)\n                K2System.Error(_T(\"EnumDisplaySettings failed on mode 0\"));\n            break;\n        }\n\n        if (devmode.dmBitsPerPel >= 15 && devmode.dmPelsWidth >= 1024 && devmode.dmPelsHeight >= 720 && g_iNumVidModes < MAX_VID_MODES)\n        {\n            // See if the mode is valid\n            devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;\n            if (ChangeDisplaySettings(&devmode, CDS_TEST | CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL)\n            {\n                // Make sure the mode doesn't already exist\n                for (int n = 1; n < g_iNumVidModes; ++n)\n                {\n                    if (g_VidModes[n].iWidth == int(devmode.dmPelsWidth) &&\n                        g_VidModes[n].iHeight == int(devmode.dmPelsHeight) &&\n                        g_VidModes[n].iBpp == int(devmode.dmBitsPerPel) &&\n                        g_VidModes[n].iRefreshRate == int(devmode.dmDisplayFrequency))\n                        bModeExists = true;\n                }\n                if (!bModeExists)\n                {\n                    // The mode is valid, so add it to g_VidModes\n                    g_VidModes[g_iNumVidModes].iWidth = int(devmode.dmPelsWidth);\n                    g_VidModes[g_iNumVidModes].iHeight = int(devmode.dmPelsHeight);\n                    g_VidModes[g_iNumVidModes].iBpp = int(devmode.dmBitsPerPel);\n                    g_VidModes[g_iNumVidModes].iRefreshRate = int(devmode.dmDisplayFrequency);\n                    g_VidModes[g_iNumVidModes].sName = XtoA(devmode.dmPelsWidth) + _T(\"x\") + XtoA(devmode.dmPelsHeight) + _T(\"x\") + XtoA(devmode.dmBitsPerPel) + _T(\" @ \") + XtoA(devmode.dmDisplayFrequency) + _T(\" Hz\");\n\n                    Console.Video << _T(\"Vid mode \") << g_iNumVidModes << _T(\": \")\n                                << _T(\"Width: \") << devmode.dmPelsWidth\n                                << _T(\", Height: \") << devmode.dmPelsHeight\n                                << _T(\", Bpp: \") << devmode.dmBitsPerPel\n                                << _T(\", Refresh rate: \") << devmode.dmDisplayFrequency << newl;\n                    ++g_iNumVidModes;\n                }\n            }\n        }\n        ++modenum;\n    }\n    while (bSuccess);\n    \n    return GL_Global_Init();\n}\n\n\n/*====================\n  GL_SetupPixelFormat\n  ====================*/\nvoid    GL_SetupPixelFormat()\n{\n    int pixelformat;\n    static PIXELFORMATDESCRIPTOR pfd = {\n    sizeof(PIXELFORMATDESCRIPTOR),  // size of this pfd\n    1,                      // version number\n    PFD_DRAW_TO_WINDOW      // support window\n    | PFD_SUPPORT_OPENGL    // support OpenGL\n    | PFD_DOUBLEBUFFER,     // double buffered\n    PFD_TYPE_RGBA,          // RGBA type\n    24,                     // 24-bit color depth\n    0, 0, 0, 0, 0, 0,       // color bits ignored\n    0,                      // no alpha buffer\n    0,                      // shift bit ignored\n    0,                      // no accumulation buffer\n    0, 0, 0, 0,             // accum bits ignored\n    24,                     // 24-bit z-buffer  \n    0,                      // no stencil buffer\n    0,                      // no auxiliary buffer\n    PFD_MAIN_PLANE,         // main layer\n    0,                      // reserved\n    0, 0, 0                 // layer masks ignored\n    };\n    \n    if (!(pixelformat = ChoosePixelFormat(g_hDC, &pfd)))    \n       K2System.Error(_T(\"GL_SetupPixelFormat: ChoosePixelFormat failed\"));            \n\n    if (!SetPixelFormat(g_hDC, pixelformat, &pfd))\n        K2System.Error(_T(\"SetPixelFormat failed\"));\n}\n\n\n/*====================\n  GL_Start\n  ====================*/\nvoid    GL_Start()\n{\n    static bool class_registered = false;\n\n    // Register window class\n    if (!class_registered)\n    {\n        WNDCLASS wc;\n\n        MemManager.Set(&wc, 0, sizeof(WNDCLASS));       \n        wc.lpfnWndProc = MainWndProc;\n        wc.hInstance = g_hInstance;\n        wc.lpszClassName = _T(\"K2_OpenGL\");\n#if TKTK // LoadIcon\n        wc.hIcon = LoadIcon(wc.hInstance, MAKEINTRESOURCE(IDI_ICON1));\n#endif\n\n        if (!RegisterClass(&wc))\n            K2System.Error(_T(\"GL_Start: RegisterClass() failed\"));\n        class_registered = true;\n    }\n\n    // Create the window\n    HWND hWnd = CreateWindowEx\n    (\n        WS_EX_ACCEPTFILES,\n        _T(\"K2_OpenGL\"),\n        K2System.GetGameName().c_str(),\n        WS_MAXIMIZE | WS_POPUP,\n        0, \n        0, \n        g_CurrentVidMode.iWidth,\n        g_CurrentVidMode.iHeight,\n        nullptr,\n        nullptr,\n        g_hInstance,\n        nullptr\n    );\n\n    if (!hWnd)\n        K2System.Error(_T(\"GL_Start: CreateWindow() failed\"));\n    K2System.SetWindowHandle(hWnd);\n\n    g_hWnd = hWnd;\n    g_hDC = GetDC(g_hWnd);\n\n    GL_SetMode();\n\n    ShowWindow(hWnd, SW_SHOW);\n    UpdateWindow(hWnd);\n\n    PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n\n    GL_SetupPixelFormat();\n\n    if (!(g_hglrc = wglCreateContext(g_hDC)))\n        K2System.Error(_T(\"GL_Start: wglCreateContext() failed\"));\n\n    if (!wglMakeCurrent(g_hDC, g_hglrc))\n        K2System.Error(_T(\"GL_Start: wglMakeCurrent() failed\"));\n\n    gl_initialized = true;\n\n    PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n\n    GL_Global_Start();\n\n    // Build anti-aliasing mode list\n    g_AAModes[0].iSamples = 0;\n    g_AAModes[0].iQuality = 0;\n    g_AAModes[0].sName = _T(\"None\");\n    g_iNumAAModes = 1; // Always keep mode 0 open\n\n    for (int i(2); i <= 16; ++i)\n    {\n        int iAttributes[] =\n        {\n            WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,\n            WGL_SUPPORT_OPENGL_ARB, GL_TRUE,\n            WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,\n            WGL_COLOR_BITS_ARB, 24,\n            WGL_ALPHA_BITS_ARB, 8,\n            WGL_DEPTH_BITS_ARB, 16,\n            WGL_STENCIL_BITS_ARB, 0,\n            WGL_DOUBLE_BUFFER_ARB, GL_TRUE,\n            WGL_SAMPLE_BUFFERS_ARB, GL_TRUE,\n            WGL_SAMPLES_ARB, i,\n            0, 0\n        };\n\n        float fAttributes[] = {0, 0};\n        int iPixelFormat;\n        UINT uiNumFormats;\n\n        BOOL bValid(wglChoosePixelFormatARB(g_hDC, iAttributes, fAttributes, 1, &iPixelFormat, &uiNumFormats));\n     \n        if (!bValid || uiNumFormats == 0)\n            continue;\n\n        g_AAModes[g_iNumAAModes].iSamples = i;\n        g_AAModes[g_iNumAAModes].iQuality = 0;\n        g_AAModes[g_iNumAAModes].sName = XtoA(i) + _T(\"x\");\n\n        ++g_iNumAAModes;\n    }\n\n    GL_SetGamma(DEFAULT_OVERBRIGHT);\n}\n\n\n/*====================\n  GL_SetMode\n  ====================*/\nint     GL_SetMode()\n{\n    int iMode(-1);\n\n    // Try to match a valid mode\n    for (int i(0); i < g_iNumVidModes; ++i)\n    {\n        if (g_VidModes[i].iWidth == vid_resolution[0] &&\n            g_VidModes[i].iHeight == vid_resolution[1] &&\n            g_VidModes[i].iBpp == vid_bpp &&\n            g_VidModes[i].iRefreshRate == vid_refreshRate)\n        {\n            g_CurrentVidMode = g_VidModes[i];\n            iMode = i;\n            break;\n        }\n    }\n\n    if (iMode == -1)\n    {\n        if (vid_fullscreen)\n        {\n            g_CurrentVidMode = g_VidModes[0];\n            iMode = 0;\n        }\n        else\n        {\n            g_CurrentVidMode.iWidth = vid_resolution[0];\n            g_CurrentVidMode.iHeight = vid_resolution[1];\n            g_CurrentVidMode.iBpp = vid_bpp;\n            g_CurrentVidMode.iRefreshRate = vid_refreshRate;\n        }\n    }\n    \n    g_iCurrentVideoMode = iMode;\n\n    if (vid_antialiasing.GetSize() != 2)\n        vid_antialiasing.Resize(2, 0);\n\n    g_CurrentAAMode.iSamples = vid_antialiasing[0];\n    g_CurrentAAMode.iQuality = vid_antialiasing[1];\n    g_CurrentAAMode.sName = _T(\"\");\n\n    if (vid_fullscreen)\n    {\n        if (iMode != 0 || win_changeDisplayMode)\n        {\n            DEVMODE devmode;\n            MemManager.Set(&devmode, 0, sizeof(devmode));\n            devmode.dmPelsWidth = g_CurrentVidMode.iWidth;\n            devmode.dmPelsHeight = g_CurrentVidMode.iHeight;\n            devmode.dmBitsPerPel = g_CurrentVidMode.iBpp;\n            devmode.dmDisplayFrequency = g_CurrentVidMode.iRefreshRate;\n            devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY;\n\n            devmode.dmSize = sizeof(devmode);\n\n            bool bSuccess(false);\n\n            bSuccess = ChangeDisplaySettings(&devmode, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL;\n\n            if (!bSuccess && iMode != 0)\n            {\n                if (win_changeDisplayMode)\n                {\n                    DEVMODE devmode0;\n                    MemManager.Set(&devmode0, 0, sizeof(devmode0));\n                    devmode0.dmPelsWidth = g_VidModes[0].iWidth;\n                    devmode0.dmPelsHeight = g_VidModes[0].iHeight;\n                    devmode0.dmBitsPerPel = g_VidModes[0].iBpp;\n                    devmode0.dmDisplayFrequency = g_VidModes[0].iRefreshRate;\n                    devmode0.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;\n\n                    bSuccess = ChangeDisplaySettings(&devmode0, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL;\n\n                    devmode = devmode0;\n                }\n                else\n                {\n                    bSuccess = ChangeDisplaySettings(nullptr, 0) == DISP_CHANGE_SUCCESSFUL;\n                }\n\n                g_iCurrentVideoMode = 0;\n            }\n\n            if (!bSuccess)\n            {\n                K2System.Error(_T(\"GL_SetMode: Unable to set Mode 0\"));\n            }\n        }\n        else\n        {\n            if (ChangeDisplaySettings(nullptr, 0) != DISP_CHANGE_SUCCESSFUL)\n                K2System.Error(_T(\"GL_SetMode: Unable to set desktop video mode\"));\n        }\n\n        g_bFullscreen = true;\n    }\n    else\n    {\n        g_bFullscreen = false;\n\n        if (ChangeDisplaySettings(nullptr, 0) != DISP_CHANGE_SUCCESSFUL)\n            K2System.Error(_T(\"GL_SetMode: Unable to set desktop video mode\"));\n    }\n\n    if (g_hWnd)\n    {\n        if (!vid_fullscreen)\n        {\n            DWORD dwWindowStyle(WS_CAPTION | WS_MINIMIZEBOX | WS_VISIBLE | WS_SYSMENU);\n\n            if (vid_windowResize)\n                dwWindowStyle |= WS_SIZEBOX;\n\n            if (!SetWindowLong(g_hWnd, GWL_STYLE, dwWindowStyle))\n                K2System.Error(_TS(\"SetWindowLong() - \") + K2System.GetLastErrorString());\n\n            RECT    winsize;\n            winsize.left = 0;\n            winsize.right = g_CurrentVidMode.iWidth;\n            winsize.top = 0;\n            winsize.bottom = g_CurrentVidMode.iHeight;\n            AdjustWindowRect(&winsize, dwWindowStyle, false);\n            if (!SetWindowPos(g_hWnd, HWND_TOP, 0, 0, winsize.right - winsize.left, winsize.bottom - winsize.top, SWP_SHOWWINDOW))\n                K2System.Error(_TS(\"SetWindowPos() - \") + K2System.GetLastErrorString());\n            GetClientRect(g_hWnd, &winsize);\n    \n            // Resize render surface to match new window size (if it was clipped)\n            g_CurrentVidMode.iWidth = MIN<int>(g_CurrentVidMode.iWidth, winsize.right - winsize.left);\n            g_CurrentVidMode.iHeight = MIN<int>(g_CurrentVidMode.iHeight, winsize.bottom - winsize.top);\n        }\n        else\n        {\n            if (!SetWindowLong(g_hWnd, GWL_STYLE, WS_MAXIMIZE))\n                K2System.Error(_TS(\"SetWindowLong() - \") + K2System.GetLastErrorString());\n\n            if (!SetWindowPos(g_hWnd, HWND_TOP, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, SWP_SHOWWINDOW))\n                K2System.Error(_TS(\"SetWindowPos() - \") + K2System.GetLastErrorString());\n        }\n\n        ShowWindow(g_hWnd, SW_SHOW);\n        UpdateWindow(g_hWnd);\n\n        PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n    }\n\n    return g_iCurrentVideoMode;\n}\n\n\n/*====================\n  GL_SetGamma\n  ====================*/\nvoid    GL_SetGamma(float gamma)\n{\n}\n\n\n/*====================\n  GL_ShowCursor\n  ====================*/\nvoid    GL_ShowCursor(bool bShow)\n{\n    if (bShow)\n        while(ShowCursor(true) < 0);\n    else\n        while(::ShowCursor(false) >= 0);\n}\n\n\n/*====================\n  GL_SetCursor\n  ====================*/\nvoid    GL_SetCursor(ResHandle hCursor)\n{\n    if (hCursor == g_hCursor)\n        return;\n    g_hCursor = hCursor;\n\n    if (g_hCursor == INVALID_RESOURCE)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    CCursor *pCursor(g_ResourceManager.GetCursor(hCursor));\n    if (pCursor == nullptr)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    CBitmap *pBitmap(pCursor->GetBitmapPointer());\n    if (pBitmap == nullptr)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    const int WIDTH(32), HEIGHT(32), BYTEPP(4);\n    \n    if (pBitmap->GetWidth() != WIDTH || pBitmap->GetHeight() != HEIGHT || pBitmap->GetBMPType() != BYTEPP)\n        return;\n\n    byte yBuffer[WIDTH * HEIGHT * 4];\n\n    const byte *pSrcData(static_cast<const byte *>(pBitmap->GetBuffer()));\n    byte *pDstData(yBuffer);\n    int iDeltaPitch(0);\n\n    // Invert\n    pSrcData += pBitmap->GetWidth() * 4 * (pBitmap->GetHeight() - 1);\n    iDeltaPitch -= pBitmap->GetWidth() * 4 * 2;\n\n    for (int y(0); y < pBitmap->GetHeight(); ++y)\n    {\n        for (int x(0); x < pBitmap->GetWidth(); ++x)\n        {\n            pDstData[0] = pSrcData[2];\n            pDstData[1] = pSrcData[1];\n            pDstData[2] = pSrcData[0];\n            pDstData[3] = pSrcData[3];\n\n            pDstData += 4;\n            pSrcData += 4;\n        }\n\n        pSrcData += iDeltaPitch;\n    }\n\n    CVec2i v2Hotspot(pCursor->GetHotspot());\n\n    if (g_hCursorIcon != nullptr) {\n        DeleteObject(g_IconInfo.hbmMask);\n        DeleteObject(g_IconInfo.hbmColor);\n        DestroyIcon(g_hCursorIcon);\n    }\n\n    g_IconInfo.fIcon = false;\n    g_IconInfo.xHotspot = v2Hotspot.x;\n    g_IconInfo.yHotspot = v2Hotspot.y;\n    g_IconInfo.hbmMask = CreateBitmap(WIDTH, HEIGHT, 1, 1, nullptr);\n    g_IconInfo.hbmColor = CreateBitmap(WIDTH, HEIGHT, 1, BYTEPP * 8, yBuffer);\n\n    g_hCursorIcon = CreateIconIndirect(&g_IconInfo);\n\n#ifdef _WIN64\n    SetClassLongPtr(g_hWnd, GCLP_HCURSOR, LONG_PTR(g_hCursorIcon));\n#else\n    SetClassLongPtr(g_hWnd, GCL_HCURSOR, LONG_PTR(g_hCursorIcon));\n#endif\n}\n\n\n/*====================\n  GL_Shutdown\n  ====================*/\nvoid    GL_Shutdown()\n{\n    if (!gl_initialized)\n        return;\n\n    GL_Global_Shutdown();\n\n    wglMakeCurrent(nullptr, nullptr);\n    \n    GL_SetGamma(1);\n\n    if (g_hglrc)\n    {\n        wglDeleteContext(g_hglrc);\n        g_hglrc = 0;\n    }\n\n    if (g_hDC)\n    {\n        ReleaseDC(g_hWnd, g_hDC);\n        g_hDC = 0;\n    }\n\n    if (g_hCursorIcon != nullptr)\n        DestroyIcon(g_hCursorIcon);\n\n    DestroyWindow(g_hWnd);\n    UnregisterClass(_T(\"K2_OpenGL\"), g_hInstance);\n\n    ChangeDisplaySettings(nullptr, 0);\n\n    ShowCursor(TRUE);\n    DestroyIcon(g_hCursorIcon);\n    DeleteObject(g_IconInfo.hbmMask);\n    DeleteObject(g_IconInfo.hbmColor);\n\n    gl_initialized = false;\n    g_bValidScene = false;\n}\n\n\n/*====================\n  GL_EndFrame\n  ====================*/\nvoid    GL_EndFrame()\n{\n    GL_Global_EndFrame();\n    SwapBuffers(g_hDC);\n    \n    PRINT_GLERROR_BREAK();\n}\n\n\n/*====================\n  GL_Break\n  ====================*/\nvoid    GL_Break()\n{\n#ifndef _WIN64\n    __asm int 0x03;\n#else\n    // TODO\n#endif\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/vid_gl2/gl2_win32.cpp b/src/vid_gl2/gl2_win32.cpp
--- a/src/vid_gl2/gl2_win32.cpp	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/src/vid_gl2/gl2_win32.cpp	(date 1685007426892)
@@ -44,6 +44,19 @@
     InitAPIs_Global(vid_api);
 }
 
+inline int get_title_bar_thickness(HWND window_handle)
+{
+    RECT window_rectangle, client_rectangle;
+    int height, width;
+    GetWindowRect(window_handle, &window_rectangle);
+    GetClientRect(window_handle, &client_rectangle);
+    height = (window_rectangle.bottom - window_rectangle.top) -
+    (client_rectangle.bottom - client_rectangle.top);
+    width = (window_rectangle.right - window_rectangle.left) -
+    (client_rectangle.right - client_rectangle.left);
+    return height - (width/2);
+}
+
 
 /*====================
   GL_GetHWnd
Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required(VERSION 3.22)\ncmake_policy(VERSION \"3.22.0\")\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\nif(UNIX AND NOT APPLE)\n  set(LINUX TRUE)\nendif()\n\n# https://stackoverflow.com/questions/17275348/how-to-specify-new-gcc-path-for-cmake\nproject(noh NONE)\nif(APPLE)\n  # Compile with clang version 16, since Apple's default clang is quite out of date (version 12)\n  # brew install llvm\n  set(LLVM_ROOT \"/opt/homebrew/opt/llvm\")\n  set(CMAKE_C_COMPILER \"/opt/homebrew/opt/llvm/bin/clang\" CACHE STRING \"C compiler\" FORCE)\n  set(CMAKE_CXX_COMPILER \"/opt/homebrew/opt/llvm/bin/clang++\" CACHE STRING \"C++ compiler\" FORCE)\n  set(CMAKE_OBJCXX_COMPILER \"/opt/homebrew/opt/llvm/bin/clang++\" CACHE STRING \"Objective-C++ compiler\" FORCE)\n  set(CMAKE_LINKER \"/opt/homebrew/opt/llvm/bin/lld\" CACHE STRING \"Linker\" FORCE)\nendif()\nenable_language(C CXX)\n\nstring(TOLOWER \"${CMAKE_SYSTEM_PROCESSOR}\" K2_PROCESSOR)\nif(\"${K2_PROCESSOR}\" STREQUAL \"aarch64\")\n  set(K2_PROCESSOR \"arm64\")\nendif()\n\nset(K2_NOVID FALSE CACHE BOOL \"Whether to build without graphics dependencies (OpenGL, etc)\")\nset(K2_NOSOUND FALSE CACHE BOOL \"Whether to build without sound dependencies (FMOD)\")\n\n# C++ 20\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nadd_definitions(-D_LIBCPP_ENABLE_CXX20_REMOVED_ALLOCATOR_MEMBERS)\nadd_definitions(-D_HAS_DEPRECATED_ALLOCATOR_MEMBERS)\n\n# from https://gitlab.kitware.com/cmake/cmake/-/issues/22184\nif(APPLE)\n  enable_language(OBJCXX)\n  set (CMAKE_OSX_DEPLOYMENT_TARGET \"13.0\" CACHE STRING \"Minimum OS X deployment version\" FORCE)\n  # Someday try to build universal binaries. Currently this causes a bunch of missing symbol errors on my M1 Air,\n  # since homebrew only installs arm64 versions of the libraries we depend on. I suspect vcpkg might work.\n  #set (CMAKE_OSX_ARCHITECTURES \"x86_64;arm64\" CACHE STRING \"Architectures\" FORCE)\nendif()\n\n# default to RelWithDebInfo\n# https://stackoverflow.com/questions/48832233/have-a-cmake-project-default-to-the-release-build-type\nif (NOT CMAKE_BUILD_TYPE OR CMAKE_BUILD_TYPE STREQUAL \"\")\n  set(CMAKE_BUILD_TYPE \"RelWithDebInfo\" CACHE STRING \"\" FORCE)\nendif()\n\n#\n# Heroes of Newerth\n#\nset(HON_GAME_ID \"hon\")\nset(HON_GAME_NAME \"Heroes of Newerth\")\nset(HON_GAME_NAME_SHORT \"HoN\")\nset(HON_CONTENT_DIR \"${noh_SOURCE_DIR}/Heroes of Newerth\")\nset(HON_ICON \"${HON_CONTENT_DIR}/icon.icns\")\nset_source_files_properties(${HON_ICON} PROPERTIES MACOSX_PACKAGE_LOCATION \"Resources\")\nlist(APPEND NOH_GAMES HON)\n\n#\n# Beatopia\n#\nset(BET_GAME_ID \"bet\")\nset(BET_GAME_NAME \"Beatopia\")\nset(BET_GAME_NAME_SHORT \"BeT\")\nset(BET_CONTENT_DIR \"${noh_SOURCE_DIR}/Beatopia\")\nlist(APPEND NOH_GAMES BET)\n\nset(SUFFIX \"\")\nif(CMAKE_BUILD_TYPE MATCHES Debug)\n  set(SUFFIX \"_debug\")\n  set(TITLE_SUFFIX \" Debug\")\n  add_definitions(-DDEBUG -D_DEBUG)\nelse()\n  add_definitions(-DNDEBUG)\nendif()\nif(APPLE)\n  set(LIB_EXT \"${SUFFIX}.dylib\")\n  set(DLL_EXT \"${SUFFIX}.dylib\")\n  set(EXE_EXT \"${TITLE_SUFFIX}\")\n  set(LIB_DIR \"${CMAKE_BINARY_DIR}\")\n  set(BIN_DIR \"${CMAKE_BINARY_DIR}\")\nelseif(WIN32)\n  set(EXE_TYPE WIN32)\n  set(LIB_EXT \"${SUFFIX}.lib\")\n  set(DLL_EXT \"${SUFFIX}.dll\")\n  set(EXE_EXT \"${TITLE_SUFFIX}\")\n  set(LIB_DIR \"${CMAKE_BINARY_DIR}\")\n  set(BIN_DIR \"${CMAKE_BINARY_DIR}\")\nelse()\n  set(LIB_EXT \"${SUFFIX}.so\")\n  set(DLL_EXT \"${SUFFIX}.so\")\n  set(EXE_EXT \"${TITLE_SUFFIX}\")\n  set(LIB_DIR \"${CMAKE_BINARY_DIR}\")\n  set(BIN_DIR \"${CMAKE_BINARY_DIR}\")\nendif()\n\nfunction(app_configure_mods target target_dir content_dir)\n  string(JOIN \"\\;\" game_mods ${ARGN})\n  target_compile_definitions(${target} PRIVATE \"-DGAME_MODS=\\\"${game_mods}\\\"\")\nendfunction()\n\nfunction(app_configure_game_settings target game_name game_subtitle)\n  if(\"${game_name}\" STREQUAL \"\")\n    message(FATAL_ERROR \"game name not set for ${target}\")\n  endif()\n  target_compile_definitions(${target} PRIVATE \"-DGAME_NAME=\\\"${game_name}\\\"\")\n  if(NOT \"${game_subtitle}\" STREQUAL \"\")\n    target_compile_definitions(${target} PRIVATE \"-DGAME_COMPONENT=\\\"${game_subtitle}\\\"\")\n  endif()\nendfunction()\n\nfunction(app_configure_lib library)\n  set(library_dir \"${LIB_DIR}\")\n  set(library_dll \"${library}${DLL_EXT}\")\n  set_target_properties(${library} PROPERTIES\n    PREFIX        \"\"\n    SUFFIX        \"${DLL_EXT}\"\n    IMPORT_SUFFIX \"${LIB_EXT}\"\n    LIBRARY_OUTPUT_DIRECTORY \"${library_dir}\"\n    RUNTIME_OUTPUT_DIRECTORY \"${library_dir}\"\n    # https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#compatible-interface-properties\n    POSITION_INDEPENDENT_CODE ON\n    )\n  # Copy the dll to the content dir of each game\n  foreach(game ${NOH_GAMES})\n    target_copy(${library}\n      \"${library_dir}/${library_dll}\"\n      \"${${game}_CONTENT_DIR}/${library_dll}\"\n      )\n  endforeach()\nendfunction()\n\nfunction(app_configure_exe exe_target exe_output_name exe_icon content_dir)\n  if(K2_SYMLINK_MOD_DIRS_IN_BUILD_DIR)\n    set(exe_dir \"${BIN_DIR}\")\n  else()\n    set(exe_dir \"${content_dir}\")\n  endif()\n  set(exe_name \"${exe_output_name}${EXE_EXT}\")\n  set_target_properties(${exe_target} PROPERTIES\n    RUNTIME_OUTPUT_DIRECTORY \"${exe_dir}\"\n    OUTPUT_NAME              \"${exe_name}\"\n    )\n  app_configure_mods(\"${exe_target}\" \"${exe_dir}\" \"${content_dir}\" ${ARGN})\n  if(UNIX)\n    # Create a symlink in the main directory called e.g. NoH (or NoH_debug) pointing to the freshly-built executable.\n    target_symlink(${exe_target}\n      \"${exe_dir}/${exe_name}\"\n      \"${noh_SOURCE_DIR}/${exe_name}\"\n      )\n  endif()\n  # Set file icon\n  # https://apple.stackexchange.com/questions/6901/how-can-i-change-a-file-or-folder-icon-using-the-terminal\n  if(APPLE)\n    # brew install fileicon\n    target_command(\"${exe_target}\" fileicon set \"${exe_dir}/${exe_name}\" \"${exe_icon}\")\n  endif()\n  if(K2_SYMLINK_MOD_DIRS_IN_BUILD_DIR)\n    # Copy the exe to the content dir of each game\n    foreach(game ${NOH_GAMES})\n      target_copy(${exe_target} \"${exe_dir}/${exe_name}\" \"${${game}_CONTENT_DIR}/${exe_name}\")\n    endforeach()\n  elseif(UNIX)\n    # Create a symlink in the build directory pointing to the content dir's executable\n    target_symlink(${exe_target}\n      \"${exe_dir}/${exe_name}\"\n      \"${BIN_DIR}/${exe_name}\"\n      )\n  endif()\nendfunction()\n\nfunction(app_configure_bundle app_target app_icon app_plist content_dir)\n  set(app_dir \"${CMAKE_BINARY_DIR}\")\n  set(app_name \"${app_target}${SUFFIX}.app\")\n  set(app_bundle \"${app_dir}/${app_name}\")\n  snakecase(\"${app_target}\" app_id)\n  set_target_properties(${app_target} PROPERTIES\n    BUNDLE                             TRUE\n    RUNTIME_OUTPUT_DIRECTORY           \"${app_dir}\"\n    MACOSX_BUNDLE_ICON_FILE            \"icon.icns\"\n    MACOSX_BUNDLE_GUI_IDENTIFIER       \"shawwn.com.${app_id}\"\n    MACOSX_BUNDLE_BUNDLE_NAME          \"${app_target}\"\n    MACOSX_BUNDLE_BUNDLE_VERSION       \"0.1\"\n    MACOSX_BUNDLE_SHORT_VERSION_STRING \"0.1\"\n    MACOSX_BUNDLE_INFO_PLIST           \"${app_plist}\"\n    )\n  target_copy(\"${app_target}\" \"${K2_LIBRARY_DLL}\"      \"${app_bundle}/${K2_LIBRARY}${DLL_EXT}\")\n  target_copy(\"${app_target}\" \"${VID_GL2_LIBRARY_DLL}\" \"${app_bundle}/${VID_GL2_LIBRARY}${DLL_EXT}\")\n  app_configure_mods(\"${app_target}\" \"${app_bundle}\" \"${content_dir}\" ${ARGN})\nendfunction()\n\n\nfunction(disp status)\n  string(JOIN \" \" msg ${ARGN})\n  message(${status} \"${msg}\")\nendfunction()\n\nset(VERBOSE 0)\nfunction(debug)\n  if (VERBOSE)\n    disp(STATUS \" [DEBUG] -- \" ${ARGN})\n  endif()\nendfunction()\n\nfunction(info)\n  disp(STATUS ${ARGN})\nendfunction()\n\nfunction(err)\n  disp(FATAL_ERROR ${ARGN})\nendfunction()\n\nmacro(assert cond)\n  if (NOT ${cond})\n    err(\"Assertion failed: ${cond} \" ${ARGN})\n  endif()\nendmacro()\n\nfunction(symlink src dst)\n  info(\"symlink ${src} -> ${dst}\")\n  execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink \"${src}\" \"${dst}\")\nendfunction()\n\nfunction(symlinks)\n  set(l ${ARGN})\n  while(l)\n    list(POP_FRONT l src dst)\n    debug(\"src: ${src} -> dst: ${dst}\")\n    assert(dst \"symlinks: dst is null\")\n    symlink(\"${src}\" \"${dst}\")\n  endwhile()\nendfunction()\n\nfunction(target_command target)\n  debug(\"adding ${target} post build command: \" ${ARGN})\n  add_custom_command(\n    TARGET \"${target}\" POST_BUILD\n    COMMAND ${ARGN}\n    VERBATIM\n  )\nendfunction()\n\nfunction(target_symlink target src dst)\n  info(\"${target}: symlink ${src} -> ${dst}\")\n  # add_custom_command(\n  #   OUTPUT \"${dst}\"\n  #   COMMAND ${CMAKE_COMMAND} -E create_symlink \"${src}\" \"${dst}\"\n  #   MAIN_DEPENDENCY \"${target}\"\n  #   VERBATIM\n  #   )\n  # add_custom_command(\n  #   TARGET \"${target}\" POST_BUILD\n  #   COMMAND ${CMAKE_COMMAND} -E create_symlink \"${src}\" \"${dst}\"\n  #   VERBATIM\n  #   )\n  # #target_sources(${target} PRIVATE \"${dst}\")\n  target_command(\"${target}\" \"${CMAKE_COMMAND}\" -E create_symlink \"${src}\" \"${dst}\")\nendfunction()\n\nfunction(target_copy target src dst)\n  info(\"${target}: copy ${src} -> ${dst}\")\n  target_command(\"${target}\" \"${CMAKE_COMMAND}\" -E copy \"${src}\" \"${dst}\")\nendfunction()\n\n# Converts \"Foo Bar\" to a snake case identifier like foo_bar\nfunction(snakecase name VAR)\n  string(MAKE_C_IDENTIFIER \"${name}\" \"${VAR}\")\n  string(TOLOWER \"${${VAR}}\" \"${VAR}\")\n  return(PROPAGATE \"${VAR}\")\nendfunction()\n\ninclude(FindPackageHandleStandardArgs)\nmacro(handle_standard_args lib)\n  # handle the QUIETLY and REQUIRED arguments and set ${lib}_FOUND to TRUE if\n  # all listed variables are TRUE\n  if (NOT DEFINED ${lib}_INCLUDE_DIR)\n    if (DEFINED ${lib}_INCLUDE_DIRS)\n      set(${lib}_INCLUDE_DIR ${${lib}_INCLUDE_DIRS})\n    endif()\n  endif()\n  if (NOT DEFINED ${lib}_LIBRARIES)\n    if (DEFINED ${lib}_LIBRARY)\n      set(${lib}_LIBRARIES ${${lib}_LIBRARY})\n    endif()\n  endif()\n  FIND_PACKAGE_HANDLE_STANDARD_ARGS(${lib}\n    REQUIRED_VARS ${lib}_LIBRARIES ${lib}_INCLUDE_DIR\n    VERSION_VAR ${lib}_VERSION_STRING)\n  if (NOT DEFINED ${lib}_LIBRARY)\n    set(${lib}_LIBRARY ${${lib}_LIBRARIES})\n  endif()\n  if (NOT DEFINED ${lib}_INCLUDE_DIRS)\n    set(${lib}_INCLUDE_DIRS ${${lib}_INCLUDE_DIR})\n  endif()\n  mark_as_advanced(${lib}_INCLUDE_DIR ${lib}_LIBRARY)\n  if (NOT ${lib}_FOUND)\n    message(FATAL_ERROR \"Can't find ${lib} library\")\n  endif()\nendmacro()\n\nmacro(add_package_for_k2 LIB)\n  handle_standard_args(${LIB})\n  if (NOT DEFINED ${LIB}_INCLUDE_DIRS)\n    message(FATAL_ERROR \"${LIB}_INCLUDE_DIRS not defined\")\n  endif()\n  if (NOT DEFINED ${LIB}_LIBRARIES)\n    message(FATAL_ERROR \"${LIB}_LIBRARIES not defined\")\n  endif()\n  list(APPEND K2_INCLUDE_DIRS ${${LIB}_INCLUDE_DIRS})\n  list(APPEND K2_LIBRARIES ${${LIB}_LIBRARIES})\n  #return(PROPAGATE K2_INCLUDE_DIRS K2_LIBRARIES)\nendmacro()\n\nmacro(find_package_for_k2 name var)\n  find_package(\"${name}\" REQUIRED)\n  add_package_for_k2(${var})\nendmacro()\n\nmacro(find_include_dir VAR ROOT header)\n  find_path(${VAR}\n    ${header}\n    PATH_SUFFIXES ${ARGN}\n    PATHS \"${ROOT}\" ENV ${ROOT} REQUIRED)\nendmacro()\n\nmessage(STATUS \"CMAKE_CXX_FLAGS: \" ${CMAKE_CXX_FLAGS})\nmessage(STATUS \"CMAKE_OBJC_FLAGS: \" ${CMAKE_OBJC_FLAGS})\n\n#\n# fmod\n#\nset(FMOD_ROOT \"${noh_SOURCE_DIR}/lib/fmodex/api/core\" CACHE PATH \"FMOD SDK core API directory\")\nfind_include_dir(FMOD_INCLUDE_DIR \"${FMOD_ROOT}\"\n  fmod.h\n  inc)\nif(WIN32)\n  if(CMAKE_SIZEOF_VOID_P EQUAL 8)\n    if(\"${K2_PROCESSOR}\" STREQUAL \"arm64\")\n      # Windows ARM64 is unsupported\n      # https://qa.fmod.com/t/is-there-a-plan-for-releasing-fmod-dll-for-windows-on-arm/17876\u001B\n      set(K2_NOSOUND CACHE BOOL \"Whether to build without sound dependencies (FMOD)\" FORCE)\n    else()\n      find_library(FMOD_LIBRARY\n        NAMES fmod_vc\n        NAMES_PER_DIR\n        PATH_SUFFIXES lib/x64\n        PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\n    endif()\n  else()\n    find_library(FMOD_LIBRARY\n      NAMES fmod_vc\n      NAMES_PER_DIR\n      PATH_SUFFIXES lib/x86\n      PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\n  endif()\nelseif(\"${K2_PROCESSOR}\" STREQUAL \"arm64\")\n  find_library(FMOD_LIBRARY\n    NAMES fmod\n    NAMES_PER_DIR\n    PATH_SUFFIXES lib lib/arm64\n    PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\nelseif(CMAKE_SIZEOF_VOID_P EQUAL 8)\n  find_library(FMOD_LIBRARY\n    NAMES fmod\n    NAMES_PER_DIR\n    PATH_SUFFIXES lib/x86_64\n    PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\nelse()\n  find_library(FMOD_LIBRARY\n    NAMES fmod_vc fmod\n    NAMES_PER_DIR\n    PATH_SUFFIXES lib/x86\n    PATHS \"${FMOD_ROOT}\" ENV FMOD_ROOT REQUIRED)\nendif()\nif(K2_NOSOUND)\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_NOSOUND)\nelse()\n  add_package_for_k2(FMOD)\n\n  # get the directory of the found library\n  get_filename_component(FMOD_LIBRARY_DIR ${FMOD_LIBRARY} DIRECTORY)\n  # construct the path to the dll\n  if(WIN32)\n    set(FMOD_DLL_PATH \"${FMOD_LIBRARY_DIR}/fmod.dll\")\n  elseif(APPLE)\n    set(FMOD_DLL_PATH \"${FMOD_LIBRARY_DIR}/libfmod.dylib\")\n  else()\n    set(FMOD_DLL_PATH \"${FMOD_LIBRARY_DIR}/libfmod.so\")\n  endif()\nendif()\n\n#\n# SpeedTree\n#\nset(SPEEDTREE_ROOT \"${noh_SOURCE_DIR}/lib/SpeedTree\")\nfind_include_dir(SPEEDTREE_INCLUDE_DIR \"${SPEEDTREE_ROOT}\"\n  SpeedTreeRT.h\n  include)\nset(SPEEDTREE_LIBRARIES SpeedTree)\nlist(APPEND CMAKE_MODULE_PATH \"${SPEEDTREE_ROOT}/cmake\")\ninclude(SpeedTree)\nadd_package_for_k2(SPEEDTREE)\n\nif(APPLE)\n  # brew install fswatch\n  set(FSWATCH_ROOT /opt/homebrew/opt/fswatch CACHE PATH \"Path to fswatch directory\")\n  find_include_dir(FSWATCH_INCLUDE_DIR\n    \"${FSWATCH_ROOT}\"\n    libfswatch/c/libfswatch.h\n    include)\n  find_library(FSWATCH_LIBRARY REQUIRED\n    NAMES fswatch\n    NAMES_PER_DIR\n    PATH_SUFFIXES lib\n    PATHS \"${FSWATCH_ROOT}\" ENV FSWATCH_ROOT)\n  list(APPEND K2_INCLUDE_DIRS \"${noh_SOURCE_DIR}/lib/fswatch/include\")\n  add_package_for_k2(FSWATCH)\nendif()\n\n# brew install speex\nfind_package_for_k2(Speex SPEEX)\n# brew install speexdsp\nfind_package_for_k2(SpeexDSP SPEEXDSP)\n# brew install openssl@1.1\nif(APPLE)\n  # Fix debugger crash in OpenSSL 3 (by using OpenSSL 1.1 instead):\n  # https://github.com/openssl/openssl/issues/20753\n  set(OPENSSL_ROOT_DIR /opt/homebrew/opt/openssl@1.1)\nendif()\nfind_package_for_k2(OpenSSL OPENSSL)\n# brew install giflib\nfind_package_for_k2(GIF GIF)\nfind_package_for_k2(PNG PNG)\nfind_package_for_k2(CURL CURL)\nfind_package_for_k2(ZLIB ZLIB)\nif(APPLE)\n  # find_package(JPEG) doesn't seem to locate homebrew jpeg, and there's\n  # no way to specify a root directory like JPEG_ROOT_DIR. Just hardcode\n  # to homebrew for now.\n  set(JPEG_LIBRARY /opt/homebrew/opt/libjpeg/lib/libjpeg.dylib)\n  set(JPEG_INCLUDE_DIR /opt/homebrew/opt/libjpeg/include)\nendif()\nfind_package_for_k2(JPEG JPEG)\nfind_package_for_k2(LibXml2 LIBXML2)\nfind_package_for_k2(Freetype FREETYPE)\nlist(APPEND K2_INCLUDE_DIRS \"${noh_SOURCE_DIR}/lib/libpng/include\")\nif(K2_NOVID)\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_NOVID)\nelse()\n  if(WIN32)\n    find_package(OpenGL REQUIRED)\n    list(APPEND K2_LIBRARIES ${OPENGL_LIBRARIES})\n  else()\n    find_package_for_k2(OpenGL OPENGL)\n  endif()\nendif() # if(K2_NOVID)\nif(UNIX)\n  find_package_for_k2(Curses CURSES)\nendif()\nif(LINUX)\n  find_package_for_k2(Xrandr XRANDR)\nendif()\n\nif(CMAKE_SIZEOF_VOID_P EQUAL 8)\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_64)\nendif()\n\nif(BUILD_STATIC)\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_LIB)\n  list(APPEND HON_SHARED_PUBLIC_DEFINITIONS -DGAME_SHARED_LIB)\nelse()\n  list(APPEND K2_PUBLIC_DEFINITIONS -DK2_DLL)\n  list(APPEND HON_SHARED_PUBLIC_DEFINITIONS -DGAME_SHARED_DLL)\nendif()\n\nlist(APPEND K2_INCLUDE_DIRS_PUBLIC \"${noh_SOURCE_DIR}/lib/k2public\")\n\n#========================================\n# k2\n#========================================\nset(K2_LIBRARY k2)\nset(K2_LIBRARY_LIB \"${K2_LIBRARY}\")\nset(K2_LIBRARY_DLL \"${BIN_DIR}/${K2_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(K2_LIBRARY_LIB \"${LIB_DIR}/${K2_LIBRARY}${LIB_EXT}\")\nendif()\n\nif(APPLE)\n  list(APPEND K2_LIBRARIES\n    \"-framework Foundation\"\n    \"-framework AppKit\"\n    \"-framework CoreAudio\"\n    \"-framework IOKit\")\nelseif(LINUX)\n  list(APPEND K2_LIBRARIES\n    X11)\nelseif(WIN32)\n  list(APPEND K2_LIBRARIES\n    wsock32\n    ws2_32\n    psapi\n    iphlpapi\n    wbemuuid)\nendif()\n\nset(K2_SOURCES\n  #  src/k2/md6.cpp\n  src/k2/blue_noise.h\n  src/k2/c_accountmanager.cpp\n  src/k2/c_accountmanager.h\n  src/k2/c_action.cpp\n  src/k2/c_action.h\n  src/k2/c_actionregistry.cpp\n  src/k2/c_actionregistry.h\n  src/k2/c_alias.cpp\n  src/k2/c_alias.h\n  src/k2/c_anim.cpp\n  src/k2/c_anim.h\n  src/k2/c_animatedimage.cpp\n  src/k2/c_animatedimage.h\n  src/k2/c_archive.cpp\n  src/k2/c_archive.h\n  src/k2/c_avatar.cpp\n  src/k2/c_avatar.h\n  src/k2/c_axis.h\n  src/k2/c_beamemitter.cpp\n  src/k2/c_beamemitter.h\n  src/k2/c_billboardemitter.cpp\n  src/k2/c_billboardemitter.h\n  src/k2/c_bind.h\n  src/k2/c_bitmap.cpp\n  src/k2/c_bitmap.h\n  src/k2/c_bitmapresource.cpp\n  src/k2/c_bitmapresource.h\n  src/k2/c_blockpool.h\n  src/k2/c_bone.cpp\n  src/k2/c_bone.h\n  src/k2/c_boundingbox.h\n  src/k2/c_boundingcone.cpp\n  src/k2/c_boundingcone.h\n  src/k2/c_brush.cpp\n  src/k2/c_brush.h\n  src/k2/c_buffer.cpp\n  src/k2/c_buffer.h\n  src/k2/c_button.cpp\n  src/k2/c_button.h\n  src/k2/c_buttoncatcher.cpp\n  src/k2/c_buttoncatcher.h\n  src/k2/c_bytemanager.cpp\n  src/k2/c_bytemanager.h\n  src/k2/c_camera.cpp\n  src/k2/c_camera.h\n  src/k2/c_chatmanager.cpp\n  src/k2/c_chatmanager.h\n  src/k2/c_checksumtable.cpp\n  src/k2/c_checksumtable.h\n  src/k2/c_clientconnection.cpp\n  src/k2/c_clientconnection.h\n  src/k2/c_clientgamelib.cpp\n  src/k2/c_clientgamelib.h\n  src/k2/c_clientlogin.cpp\n  src/k2/c_clientlogin.h\n  src/k2/c_clientsnapshot.cpp\n  src/k2/c_clientsnapshot.h\n  src/k2/c_cliffdefinitionresource.cpp\n  src/k2/c_cliffdefinitionresource.h\n  src/k2/c_cliffsetlist.cpp\n  src/k2/c_cliffsetlist.h\n  src/k2/c_cliffvariationmap.cpp\n  src/k2/c_cliffvariationmap.h\n  src/k2/c_clip.cpp\n  src/k2/c_clip.h\n  src/k2/c_cmd.cpp\n  src/k2/c_cmd.h\n  src/k2/c_cmdprecache.cpp\n  src/k2/c_cmdprecache.h\n  src/k2/c_combobox.cpp\n  src/k2/c_combobox.h\n  src/k2/c_combobox_listbox.cpp\n  src/k2/c_combobox_listbox.h\n  src/k2/c_compressedfile.cpp\n  src/k2/c_compressedfile.h\n  src/k2/c_console.cpp\n  src/k2/c_console.h\n  src/k2/c_consoleelement.cpp\n  src/k2/c_consoleelement.h\n  src/k2/c_consoleregistry.cpp\n  src/k2/c_consoleregistry.h\n  src/k2/c_controlleremitter.cpp\n  src/k2/c_controlleremitter.h\n  src/k2/c_convexhull.cpp\n  src/k2/c_convexhull.h\n  src/k2/c_convexpolygon.cpp\n  src/k2/c_convexpolygon.h\n  src/k2/c_convexpolygon2.cpp\n  src/k2/c_convexpolygon2.h\n  src/k2/c_convexpolyhedron.cpp\n  src/k2/c_convexpolyhedron.h\n  src/k2/c_cursor.cpp\n  src/k2/c_cursor.h\n  src/k2/c_cvar.cpp\n  src/k2/c_cvar.h\n  src/k2/c_cvararray.cpp\n  src/k2/c_cvararray.h\n  src/k2/c_cvarlabel.cpp\n  src/k2/c_cvarlabel.h\n  src/k2/c_cvarreference.cpp\n  src/k2/c_cvarreference.h\n  src/k2/c_date.cpp\n  src/k2/c_date.h\n  src/k2/c_debrisemitter.cpp\n  src/k2/c_debrisemitter.h\n  src/k2/c_DebugRenderer.cpp\n  src/k2/c_DebugRenderer.h\n  src/k2/c_draw2d.cpp\n  src/k2/c_draw2d.h\n  src/k2/c_edge.cpp\n  src/k2/c_edge.h\n  src/k2/c_effect.cpp\n  src/k2/c_effect.h\n  src/k2/c_effectpanel.cpp\n  src/k2/c_effectpanel.h\n  src/k2/c_effectthread.cpp\n  src/k2/c_effectthread.h\n  src/k2/c_entitysnapshot.cpp\n  src/k2/c_entitysnapshot.h\n  src/k2/c_eventcmd.cpp\n  src/k2/c_eventcmd.h\n  src/k2/c_eventcmdregistry.cpp\n  src/k2/c_eventcmdregistry.h\n  src/k2/c_eventmanager.cpp\n  src/k2/c_eventmanager.h\n  src/k2/c_eventscript.cpp\n  src/k2/c_eventscript.h\n  src/k2/c_exception.cpp\n  src/k2/c_exception.h\n  # src/k2/c_fastunzip.cpp\n  # src/k2/c_fastunzip.h\n  src/k2/c_file.cpp\n  src/k2/c_file.h\n  src/k2/c_filearchive.cpp\n  src/k2/c_filearchive.h\n  src/k2/c_filebuffer.cpp\n  src/k2/c_filebuffer.h\n  src/k2/c_filechangecallback.cpp\n  src/k2/c_filechangecallback.h\n  src/k2/c_filedisk.cpp\n  src/k2/c_filedisk.h\n  src/k2/c_filehandle.cpp\n  src/k2/c_filehandle.h\n  src/k2/c_filehttp.cpp\n  src/k2/c_filehttp.h\n  src/k2/c_filemanager.cpp\n  src/k2/c_filemanager.h\n  src/k2/c_filestream.cpp\n  src/k2/c_filestream.h\n  src/k2/c_floater.cpp\n  src/k2/c_floater.h\n  src/k2/c_foliagedensitymap.h\n  src/k2/c_fontface.cpp\n  src/k2/c_fontface.h\n  src/k2/c_fontmap.cpp\n  src/k2/c_fontmap.h\n  src/k2/c_frame.cpp\n  src/k2/c_frame.h\n  # src/k2/c_frame_border.cpp\n  # src/k2/c_frame_border.h\n  src/k2/c_freetype.cpp\n  src/k2/c_freetype.h\n  src/k2/c_frustum.cpp\n  src/k2/c_frustum.h\n  src/k2/c_function.cpp\n  src/k2/c_function.h\n  src/k2/c_gamebind.cpp\n  src/k2/c_gamebind.h\n  src/k2/c_gate.h\n  src/k2/c_groundspriteemitter.cpp\n  src/k2/c_groundspriteemitter.h\n  src/k2/c_heap.cpp\n  src/k2/c_heap.h\n  # src/k2/c_heapfactory.cpp\n  # src/k2/c_heapfactory.h\n  src/k2/c_heightmap.cpp\n  src/k2/c_heightmap.h\n  src/k2/c_host.cpp\n  src/k2/c_host.h\n  src/k2/c_hostclient.cpp\n  src/k2/c_hostclient.h\n  src/k2/c_hostinterface.cpp\n  src/k2/c_hostinterface.h\n  src/k2/c_hostserver.cpp\n  src/k2/c_hostserver.h\n  src/k2/c_httpmanager.cpp\n  src/k2/c_httpmanager.h\n  src/k2/c_httprequest.cpp\n  src/k2/c_httprequest.h\n  src/k2/c_image.cpp\n  src/k2/c_image.h\n  src/k2/c_input.cpp\n  src/k2/c_input.h\n  src/k2/c_inputstate.h\n  src/k2/c_interface.cpp\n  src/k2/c_interface.h\n  src/k2/c_interfaceresource.cpp\n  src/k2/c_interfaceresource.h\n  src/k2/c_k2model.cpp\n  src/k2/c_k2model.h\n  src/k2/c_label.cpp\n  src/k2/c_label.h\n  src/k2/c_lerps.cpp\n  src/k2/c_lerps.h\n  src/k2/c_lightemitter.cpp\n  src/k2/c_lightemitter.h\n  src/k2/c_listbox.cpp\n  src/k2/c_listbox.h\n  src/k2/c_listbox_scrollbar.cpp\n  src/k2/c_listbox_scrollbar.h\n  src/k2/c_listitem.cpp\n  src/k2/c_listitem.h\n  # src/k2/c_locale.cpp\n  # src/k2/c_locale.h\n  src/k2/c_material.cpp\n  src/k2/c_material.h\n  src/k2/c_materialbrush.cpp\n  src/k2/c_materialbrush.h\n  src/k2/c_materiallist.cpp\n  src/k2/c_materiallist.h\n  src/k2/c_materialparameter.cpp\n  src/k2/c_materialparameter.h\n  # src/k2/c_matrix3x3.cpp\n  src/k2/c_matrix3x3.h\n  src/k2/c_matrix4x3.h\n  src/k2/c_memmanager.cpp\n  src/k2/c_memmanager.h\n  src/k2/c_menu.cpp\n  src/k2/c_menu.h\n  src/k2/c_menu_listbox.cpp\n  src/k2/c_menu_listbox.h\n  src/k2/c_mesh.cpp\n  src/k2/c_mesh.h\n  src/k2/c_meshemitter.cpp\n  src/k2/c_meshemitter.h\n  src/k2/c_minimap.cpp\n  src/k2/c_minimap.h\n  src/k2/c_mmapunzip.cpp\n  src/k2/c_mmapunzip.h\n  src/k2/c_model.cpp\n  src/k2/c_model.h\n  src/k2/c_modelallocatorregistry.cpp\n  src/k2/c_modelallocatorregistry.h\n  src/k2/c_modelemitter.cpp\n  src/k2/c_modelemitter.h\n  src/k2/c_modelpanel.cpp\n  src/k2/c_modelpanel.h\n  src/k2/c_modifier.h\n  src/k2/c_movie.h\n  src/k2/c_movie_linux.cpp\n  # src/k2/c_movie_win32.cpp\n  src/k2/c_navgridUnits.cpp\n  src/k2/c_navgridUnits.h\n  src/k2/c_navgridZ.cpp\n  src/k2/c_navgridZ.h\n  src/k2/c_navigationgraph.cpp\n  src/k2/c_navigationgraph.h\n  src/k2/c_navigationmap.cpp\n  src/k2/c_navigationmap.h\n  src/k2/c_netdriver.h\n  src/k2/c_netstats.cpp\n  src/k2/c_netstats.h\n  src/k2/c_networkresourcemanager.cpp\n  src/k2/c_networkresourcemanager.h\n  src/k2/c_occluder.cpp\n  src/k2/c_occluder.h\n  src/k2/c_occlusionmap.cpp\n  src/k2/c_occlusionmap.h\n  src/k2/c_optionsmanager.cpp\n  src/k2/c_optionsmanager.h\n  src/k2/c_orbiter.cpp\n  src/k2/c_orbiter.h\n  src/k2/c_orbiteremitter.cpp\n  src/k2/c_orbiteremitter.h\n  src/k2/c_orthofrustum.cpp\n  src/k2/c_orthofrustum.h\n  src/k2/c_packet.cpp\n  src/k2/c_packet.h\n  src/k2/c_panel.cpp\n  src/k2/c_panel.h\n  src/k2/c_particlepool.cpp\n  src/k2/c_particlepool.h\n  src/k2/c_particlesystem.cpp\n  src/k2/c_particlesystem.h\n  src/k2/c_path.cpp\n  src/k2/c_path.h\n  src/k2/c_phpdata.cpp\n  src/k2/c_phpdata.h\n  src/k2/c_piegraph.cpp\n  src/k2/c_piegraph.h\n  src/k2/c_pixelshader.cpp\n  src/k2/c_pixelshader.h\n  src/k2/c_plane.cpp\n  src/k2/c_plane.h\n  src/k2/c_plane2.cpp\n  src/k2/c_plane2.h\n  src/k2/c_pool.h\n  src/k2/c_posteffect.cpp\n  src/k2/c_posteffect.h\n  src/k2/c_precipemitter.cpp\n  src/k2/c_precipemitter.h\n  src/k2/c_priorityqueue.h\n  src/k2/c_profilemanager.cpp\n  src/k2/c_profilemanager.h\n  src/k2/c_profilenode.cpp\n  src/k2/c_profilenode.h\n  src/k2/c_profilesample.cpp\n  src/k2/c_profilesample.h\n  src/k2/c_ramplist.cpp\n  src/k2/c_ramplist.h\n  src/k2/c_rampresource.cpp\n  src/k2/c_rampresource.h\n  src/k2/c_range.h\n  src/k2/c_rasterbuffer.cpp\n  src/k2/c_rasterbuffer.h\n  src/k2/c_rect.h\n  src/k2/c_recyclepool.h\n  src/k2/c_referencecounter.h\n  src/k2/c_referencerecyclepool.h\n  src/k2/c_reliablepacket.cpp\n  src/k2/c_reliablepacket.h\n  src/k2/c_resourcemanager.cpp\n  src/k2/c_resourcemanager.h\n  src/k2/c_resourcereference.cpp\n  src/k2/c_resourcereference.h\n  src/k2/c_resourceinfo.cpp\n  src/k2/c_resourceinfo.h\n  src/k2/c_resultgate.h\n  src/k2/c_resultsegment.h\n  src/k2/c_sample.cpp\n  src/k2/c_sample.h\n  src/k2/c_sceneentity.cpp\n  src/k2/c_sceneentity.h\n  src/k2/c_sceneentitymodifier.cpp\n  src/k2/c_sceneentitymodifier.h\n  src/k2/c_scenelight.h\n  src/k2/c_scenemanager.cpp\n  src/k2/c_scenemanager.h\n  src/k2/c_sceneobject.h\n  src/k2/c_scenestats.cpp\n  src/k2/c_scenestats.h\n  src/k2/c_script.cpp\n  src/k2/c_script.h\n  src/k2/c_scriptthread.cpp\n  src/k2/c_scriptthread.h\n  src/k2/c_scrollbar.cpp\n  src/k2/c_scrollbar.h\n  src/k2/c_scrollbar_button.cpp\n  src/k2/c_scrollbar_button.h\n  src/k2/c_scrollbar_slider.cpp\n  src/k2/c_scrollbar_slider.h\n  src/k2/c_searchgate.h\n  src/k2/c_searchgateR.h\n  src/k2/c_searchnode.cpp\n  src/k2/c_searchnode.h\n  src/k2/c_serverchatconnection.cpp\n  src/k2/c_serverchatconnection.h\n  src/k2/c_servergamelib.cpp\n  src/k2/c_servergamelib.h\n  src/k2/c_servermanager.cpp\n  src/k2/c_servermanager.h\n  src/k2/c_simpleemitter.cpp\n  src/k2/c_simpleemitter.h\n  src/k2/c_simpleparticle.cpp\n  src/k2/c_simpleparticle.h\n  src/k2/c_skeleton.cpp\n  src/k2/c_skeleton.h\n  src/k2/c_skeletonbonepool.cpp\n  src/k2/c_skeletonbonepool.h\n  src/k2/c_skeletonemitter.cpp\n  src/k2/c_skeletonemitter.h\n  src/k2/c_skin.cpp\n  src/k2/c_skin.h\n  src/k2/c_slider.cpp\n  src/k2/c_slider.h\n  src/k2/c_slider_handle.cpp\n  src/k2/c_slider_handle.h\n  src/k2/c_snapshot.cpp\n  src/k2/c_snapshot.h\n  src/k2/c_snaptarget.cpp\n  src/k2/c_snaptarget.h\n  src/k2/c_socket.cpp\n  src/k2/c_socket.h\n  src/k2/c_soundemitter.cpp\n  src/k2/c_soundemitter.h\n  src/k2/c_soundmanager.cpp\n  src/k2/c_soundmanager.h\n  src/k2/c_sphere.h\n  src/k2/c_stateblock.cpp\n  src/k2/c_stateblock.h\n  src/k2/c_statestring.cpp\n  src/k2/c_statestring.h\n  src/k2/c_stringtable.cpp\n  src/k2/c_stringtable.h\n  src/k2/c_swatch.cpp\n  src/k2/c_swatch.h\n  src/k2/c_system.h\n  # src/k2/c_system_linux.cpp\n  # src/k2/c_system_osx.mm\n  # src/k2/c_system_posix.cpp\n  # src/k2/c_system_win32.cpp\n  src/k2/c_table.cpp\n  src/k2/c_table.h\n  src/k2/c_table_scrollbar.cpp\n  src/k2/c_table_scrollbar.h\n  src/k2/c_temporalproperty.h\n  src/k2/c_temporalpropertyrange.h\n  src/k2/c_temporalrange.h\n  src/k2/c_terrainemitter.cpp\n  src/k2/c_terrainemitter.h\n  src/k2/c_texelalphamap.cpp\n  src/k2/c_texelalphamap.h\n  src/k2/c_texelocclusionmap.cpp\n  src/k2/c_texelocclusionmap.h\n  src/k2/c_textbox.cpp\n  src/k2/c_textbox.h\n  src/k2/c_textbuffer.cpp\n  src/k2/c_textbuffer.h\n  src/k2/c_textbuffer_scrollbar.cpp\n  src/k2/c_textbuffer_scrollbar.h\n  src/k2/c_texture.cpp\n  src/k2/c_texture.h\n  src/k2/c_texturelist.cpp\n  src/k2/c_texturelist.h\n  src/k2/c_tilecliffmap.cpp\n  src/k2/c_tilecliffmap.h\n  src/k2/c_tilefoliagemap.cpp\n  src/k2/c_tilefoliagemap.h\n  src/k2/c_tilematerialmap.cpp\n  src/k2/c_tilematerialmap.h\n  src/k2/c_tilenormalmap.cpp\n  src/k2/c_tilenormalmap.h\n  src/k2/c_tilerampmap.cpp\n  src/k2/c_tilerampmap.h\n  src/k2/c_tilesplitmap.cpp\n  src/k2/c_tilesplitmap.h\n  src/k2/c_tilevisionmap.cpp\n  src/k2/c_tilevisionmap.h\n  src/k2/c_timermanager.cpp\n  src/k2/c_timermanager.h\n  src/k2/c_traceremitter.cpp\n  src/k2/c_traceremitter.h\n  src/k2/c_tracker.cpp\n  src/k2/c_tracker.h\n  src/k2/c_trackeremitter.cpp\n  src/k2/c_trackeremitter.h\n  src/k2/c_trailemitter.cpp\n  src/k2/c_trailemitter.h\n  # src/k2/c_transmitflags.cpp\n  # src/k2/c_transmitflags.h\n  src/k2/c_treemodel.cpp\n  src/k2/c_treemodel.h\n  src/k2/c_twopointemitter.cpp\n  src/k2/c_twopointemitter.h\n  src/k2/c_twopointtrailemitter.cpp\n  src/k2/c_twopointtrailemitter.h\n  src/k2/c_uicmd.cpp\n  src/k2/c_uicmd.h\n  src/k2/c_uicmdregistry.cpp\n  src/k2/c_uicmdregistry.h\n  src/k2/c_uiform.cpp\n  src/k2/c_uiform.h\n  src/k2/c_uimanager.cpp\n  src/k2/c_uimanager.h\n  src/k2/c_uiscript.cpp\n  src/k2/c_uiscript.h\n  src/k2/c_uiscripttoken.cpp\n  src/k2/c_uiscripttoken.h\n  src/k2/c_uitextureregistry.cpp\n  src/k2/c_uitextureregistry.h\n  src/k2/c_uitrigger.cpp\n  src/k2/c_uitrigger.h\n  src/k2/c_uitriggerregistry.cpp\n  src/k2/c_uitriggerregistry.h\n  # src/k2/c_uixmlparser.cpp\n  # src/k2/c_uixmlparser.h\n  src/k2/c_unzip.cpp\n  src/k2/c_unzip.h\n  src/k2/c_updater.cpp\n  src/k2/c_updater.h\n  src/k2/c_upgrades.cpp\n  src/k2/c_upgrades.h\n  src/k2/c_vec.h\n  src/k2/c_vec2.h\n  src/k2/c_vec3.h\n  src/k2/c_vec4.h\n  src/k2/c_vertexblockermap.cpp\n  src/k2/c_vertexblockermap.h\n  src/k2/c_vertexcameraheightmap.cpp\n  src/k2/c_vertexcameraheightmap.h\n  src/k2/c_vertexcliffmap.cpp\n  src/k2/c_vertexcliffmap.h\n  src/k2/c_vertexcolormap.cpp\n  src/k2/c_vertexcolormap.h\n  src/k2/c_vertexfoliagemap.cpp\n  src/k2/c_vertexfoliagemap.h\n  src/k2/c_vertexnormalmap.cpp\n  src/k2/c_vertexnormalmap.h\n  src/k2/c_vertexshader.cpp\n  src/k2/c_vertexshader.h\n  src/k2/c_vertextangentmap.cpp\n  src/k2/c_vertextangentmap.h\n  src/k2/c_vid.cpp\n  src/k2/c_vid.h\n  src/k2/c_voicemanager.cpp\n  src/k2/c_voicemanager.h\n  src/k2/c_voiceserver.cpp\n  src/k2/c_voiceserver.h\n  src/k2/c_voiceuser.cpp\n  src/k2/c_voiceuser.h\n  src/k2/c_webimage.cpp\n  src/k2/c_webimage.h\n  src/k2/c_webpanel.cpp\n  src/k2/c_webpanel.h\n  src/k2/c_widgetreference.cpp\n  src/k2/c_widgetreference.h\n  src/k2/c_widgetstate.cpp\n  src/k2/c_widgetstate.h\n  src/k2/c_widgetstyle.cpp\n  src/k2/c_widgetstyle.h\n  src/k2/c_widgettemplate.cpp\n  src/k2/c_widgettemplate.h\n  src/k2/c_world.cpp\n  src/k2/c_world.h\n  # src/k2/c_worldblock.cpp\n  # src/k2/c_worldblock.h\n  # src/k2/c_worldblockhandle.cpp\n  # src/k2/c_worldblockhandle.h\n  src/k2/c_worldentity.h\n  src/k2/c_worldentitylist.cpp\n  src/k2/c_worldentitylist.h\n  src/k2/c_worldlight.h\n  src/k2/c_worldlightlist.cpp\n  src/k2/c_worldlightlist.h\n  src/k2/c_worldoccluderlist.cpp\n  src/k2/c_worldoccluderlist.h\n  src/k2/c_worldsound.h\n  src/k2/c_worldsoundlist.cpp\n  src/k2/c_worldsoundlist.h\n  src/k2/c_worldtree.cpp\n  src/k2/c_worldtree.h\n  src/k2/c_worldtriggerlist.cpp\n  src/k2/c_worldtriggerlist.h\n  src/k2/c_xmldoc.cpp\n  src/k2/c_xmldoc.h\n  src/k2/c_xmlmanager.cpp\n  src/k2/c_xmlmanager.h\n  src/k2/c_xmlnode.cpp\n  src/k2/c_xmlnode.h\n  src/k2/c_xmlproc_anchor.cpp\n  src/k2/c_xmlproc_animatedimage.cpp\n  src/k2/c_xmlproc_brushmat.cpp\n  src/k2/c_xmlproc_button.cpp\n  src/k2/c_xmlproc_button.h\n  src/k2/c_xmlproc_buttoncatcher.cpp\n  src/k2/c_xmlproc_buttoncatcher.h\n  src/k2/c_xmlproc_combobox.cpp\n  src/k2/c_xmlproc_combobox.h\n  src/k2/c_xmlproc_cursor.cpp\n  src/k2/c_xmlproc_cvar.cpp\n  src/k2/c_xmlproc_cvarlabel.cpp\n  src/k2/c_xmlproc_cvarlabel.h\n  src/k2/c_xmlproc_dirlistitems.cpp\n  src/k2/c_xmlproc_effect.cpp\n  src/k2/c_xmlproc_effectpanel.cpp\n  src/k2/c_xmlproc_effectpanel.h\n  src/k2/c_xmlproc_floater.cpp\n  src/k2/c_xmlproc_floater.h\n  src/k2/c_xmlproc_fontface.cpp\n  src/k2/c_xmlproc_form.cpp\n  src/k2/c_xmlproc_frame.cpp\n  src/k2/c_xmlproc_frame.h\n  src/k2/c_xmlproc_if.cpp\n  src/k2/c_xmlproc_image.cpp\n  src/k2/c_xmlproc_include.cpp\n  src/k2/c_xmlproc_instance.cpp\n  src/k2/c_xmlproc_interface.cpp\n  src/k2/c_xmlproc_interface.h\n  src/k2/c_xmlproc_interfaceset.cpp\n  src/k2/c_xmlproc_interfaceset.h\n  src/k2/c_xmlproc_label.cpp\n  src/k2/c_xmlproc_label.h\n  src/k2/c_xmlproc_listbox.cpp\n  src/k2/c_xmlproc_listbox.h\n  src/k2/c_xmlproc_listitem.cpp\n  src/k2/c_xmlproc_listitem.h\n  src/k2/c_xmlproc_material.cpp\n  src/k2/c_xmlproc_materiallist.cpp\n  src/k2/c_xmlproc_menu.cpp\n  src/k2/c_xmlproc_menu.h\n  src/k2/c_xmlproc_minimap.cpp\n  src/k2/c_xmlproc_minimap.h\n  src/k2/c_xmlproc_model.cpp\n  src/k2/c_xmlproc_modelpanel.cpp\n  src/k2/c_xmlproc_modelpanel.h\n  src/k2/c_xmlproc_panel.cpp\n  src/k2/c_xmlproc_panel.h\n  src/k2/c_xmlproc_piegraph.cpp\n  src/k2/c_xmlproc_piegraph.h\n  src/k2/c_xmlproc_posteffect.cpp\n  src/k2/c_xmlproc_resourcelist.cpp\n  src/k2/c_xmlproc_resourcelist.h\n  src/k2/c_xmlproc_scrollbar.cpp\n  src/k2/c_xmlproc_scrollbar.h\n  src/k2/c_xmlproc_slider.cpp\n  src/k2/c_xmlproc_slider.h\n  src/k2/c_xmlproc_snaptarget.cpp\n  src/k2/c_xmlproc_snaptarget.h\n  src/k2/c_xmlproc_style.cpp\n  src/k2/c_xmlproc_swatch.cpp\n  src/k2/c_xmlproc_swatch.h\n  src/k2/c_xmlproc_table.cpp\n  src/k2/c_xmlproc_table.h\n  src/k2/c_xmlproc_template.cpp\n  src/k2/c_xmlproc_template.h\n  src/k2/c_xmlproc_textbox.cpp\n  src/k2/c_xmlproc_textbox.h\n  src/k2/c_xmlproc_textbuffer.cpp\n  src/k2/c_xmlproc_textbuffer.h\n  src/k2/c_xmlproc_texturelist.cpp\n  src/k2/c_xmlproc_trigger.cpp\n  src/k2/c_xmlproc_webimage.cpp\n  src/k2/c_xmlproc_webpanel.cpp\n  src/k2/c_xmlproc_webpanel.h\n  src/k2/c_xmlproc_widgetstate.cpp\n  src/k2/c_xmlproc_widgetstate.h\n  src/k2/c_xmlproc_world.cpp\n  src/k2/c_xmlproc_worldentitylist.cpp\n  src/k2/c_xmlproc_worldlightlist.cpp\n  src/k2/c_xmlproc_worldoccluderlist.cpp\n  src/k2/c_xmlproc_worldsoundlist.cpp\n  src/k2/c_xmlproc_worldtriggerlist.cpp\n  src/k2/c_xmlprocroot.cpp\n  src/k2/c_xmlprocroot.h\n  src/k2/c_zip.cpp\n  src/k2/c_zip.h\n  src/k2/c_zipfile.cpp\n  src/k2/c_zipfile.h\n  src/k2/client_api.h\n  # src/k2/dllmain.cpp\n  src/k2/evaluator.cpp\n  src/k2/evaluator.h\n  src/k2/host_commands.cpp\n  src/k2/i_baseinput.cpp\n  src/k2/i_baseinput.h\n  src/k2/i_dragwidget.cpp\n  src/k2/i_dragwidget.h\n  src/k2/i_effectcmd.cpp\n  src/k2/i_effectcmd.h\n  src/k2/i_effectinstance.cpp\n  src/k2/i_effectinstance.h\n  src/k2/i_emitter.cpp\n  src/k2/i_emitter.h\n  src/k2/i_entitycomponent.h\n  src/k2/i_inputwidget.h\n  src/k2/i_listwidget.cpp\n  src/k2/i_listwidget.h\n  src/k2/i_model.cpp\n  src/k2/i_model.h\n  src/k2/i_modelallocator.cpp\n  src/k2/i_modelallocator.h\n  src/k2/i_resource.cpp\n  src/k2/i_resource.h\n  src/k2/i_resourcelibrary.cpp\n  src/k2/i_resourcelibrary.h\n  src/k2/i_snapshot.cpp\n  src/k2/i_snapshot.h\n  src/k2/i_tag.cpp\n  src/k2/i_tag.h\n  src/k2/i_widget.cpp\n  src/k2/i_widget.h\n  src/k2/i_worldcomponent.cpp\n  src/k2/i_worldcomponent.h\n  src/k2/i_xmlproc_tag.h\n  src/k2/i_xmlproc_widget.h\n  src/k2/i_xmlprocessor.h\n  src/k2/inotify-syscalls.h\n  src/k2/inotify.h\n  src/k2/intersection.cpp\n  src/k2/intersection.h\n  src/k2/k2_api.h\n  src/k2/k2_common.cpp\n  src/k2/k2_common.h\n  src/k2/k2_constants.h\n  src/k2/k2_endian.h\n  src/k2/k2_mathlib.cpp\n  src/k2/k2_mathlib.h\n  src/k2/k2_protocol.h\n  src/k2/k2_randlib.cpp\n  src/k2/k2_randlib.h\n  src/k2/k2_secure_crt.h\n  src/k2/k2_singleton.h\n  src/k2/k2_stl.h\n  src/k2/k2_strings.h\n  src/k2/k2_types.h\n  src/k2/k2_unicode.h\n  src/k2/k2_utils.cpp\n  src/k2/k2_utils.h\n  src/k2/math_inlines.h\n  src/k2/md5.cpp\n  src/k2/md5.h\n  src/k2/md6.cpp\n  src/k2/md6.h\n  src/k2/MersenneTwister.cpp\n  src/k2/MersenneTwister.h\n  src/k2/parser.cpp\n  src/k2/parser.h\n  src/k2/s_foliagetile.h\n  src/k2/s_foliagevertex.h\n  src/k2/s_tile.h\n  src/k2/s_traceinfo.h\n  src/k2/s_x11info.h\n  src/k2/script_commands.cpp\n  src/k2/server_api.h\n  # src/k2/shared_api.cpp\n  src/k2/stringutils.cpp\n  src/k2/stringutils.h\n  src/k2/tchar_linux.h\n  src/k2/util_inlines.h\n  src/k2/xtoa.cpp\n  src/k2/xtoa.h\n\n  src/k2/MicroAllocator.cpp\n  src/k2/MicroAllocator.h\n\n  src/k2/MemoryTracker.h\n  src/k2/MemoryTrackerBinding.cpp\n  # src/k2/MemoryTrackerDLL.cpp\n\n  src/k2/srp.h\n  src/k2/srp.cpp\n  src/k2/c_srp.h\n  src/k2/c_srp.cpp\n  )\n\nif(WIN32)\n  list(APPEND K2_SOURCES\n    src/k2/MemoryTrackerDLL.cpp\n    src/k2/c_system_win32.cpp\n    src/k2/c_netdriver_win32.cpp\n    )\nelse()\n  list(APPEND K2_SOURCES\n    src/k2/c_system_posix.cpp\n    src/k2/c_netdriver_linux.cpp\n    )\n  if(APPLE)\n    list(APPEND K2_SOURCES src/k2/c_system_osx.mm)\n  elseif(LINUX)\n    list(APPEND K2_SOURCES src/k2/c_system_linux.cpp)\n  endif()\nendif()\n\nadd_library(${K2_LIBRARY} SHARED ${K2_SOURCES})\napp_configure_lib(${K2_LIBRARY})\ntarget_compile_definitions(${K2_LIBRARY} PRIVATE K2_EXPORTS)\ntarget_compile_definitions(${K2_LIBRARY} PUBLIC ${K2_PUBLIC_DEFINITIONS})\ntarget_precompile_headers(${K2_LIBRARY} PRIVATE src/k2/k2_common.h)\ntarget_link_libraries(${K2_LIBRARY} ${K2_LIBRARIES})\ntarget_include_directories(${K2_LIBRARY} PRIVATE ${K2_INCLUDE_DIRS})\ntarget_include_directories(${K2_LIBRARY} PUBLIC ${K2_INCLUDE_DIRS_PUBLIC})\nif(NOT K2_NOSOUND)\n  # copy the fmod DLL to each content directory, along with the build directory.\n  target_copy(${K2_LIBRARY} \"${FMOD_DLL_PATH}\" \"${BIN_DIR}\")\n  foreach(game ${NOH_GAMES})\n    target_copy(${K2_LIBRARY} \"${FMOD_DLL_PATH}\" \"${${game}_CONTENT_DIR}\")\n  endforeach()\nendif()\n\n#========================================\n# vid_gl2_c\n#========================================\nif(NOT K2_NOVID)\nset(VID_GL2_C_SOURCES\n  src/vid_gl2/SOIL/SOIL.c\n  src/vid_gl2/SOIL/image_DXT.c\n  src/vid_gl2/SOIL/image_helper.c\n  src/vid_gl2/SOIL/stb_image_aug.c\n  )\nadd_library(vid_gl2_c STATIC ${VID_GL2_C_SOURCES})\nlist(APPEND VID_GL2_LIBRARIES vid_gl2_c)\nendif() # if(NOT K2_NOVID)\n\n#========================================\n# vid_gl2\n#========================================\nif(NOT K2_NOVID)\nset(VID_GL2_LIBRARY vid_gl2)\nset(VID_GL2_LIBRARY_LIB \"${VID_GL2_LIBRARY}\")\nset(VID_GL2_LIBRARY_DLL \"${BIN_DIR}/${VID_GL2_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(VID_GL2_LIBRARY_LIB \"${LIB_DIR}/${VID_GL2_LIBRARY}${LIB_EXT}\")\nendif()\n\n# vid_gl2 definitions\nlist(APPEND VID_GL2_LIBRARY_DEFINITIONS\n  GLEW_STATIC\n  GL_SILENCE_DEPRECATION\n  )\n\n# vid_gl2 dependencies\nlist(APPEND VID_GL2_LIBRARY_DEPENDENCIES\n  ${K2_LIBRARY}\n  )\n\n# vid_gl2 libraries\nlist(APPEND VID_GL2_LIBRARIES\n  \"${K2_LIBRARY}\"\n  ${OPENGL_LIBRARIES}\n  )\n\n# vid_gl2 sources\nlist(APPEND VID_GL2_SOURCES\n  src/vid_gl2/GLEW/glew.cpp\n  src/vid_gl2/GLEW/glew.h\n  src/vid_gl2/GLEW/glxew.h\n  src/vid_gl2/GLEW/wglew.h\n  #  src/vid_gl2/SOIL/SOIL.c\n  src/vid_gl2/SOIL/SOIL.h\n  #  src/vid_gl2/SOIL/image_DXT.c\n  src/vid_gl2/SOIL/image_DXT.h\n  #  src/vid_gl2/SOIL/image_helper.c\n  src/vid_gl2/SOIL/image_helper.h\n  #  src/vid_gl2/SOIL/stb_image_aug.c\n  src/vid_gl2/SOIL/stb_image_aug.h\n  src/vid_gl2/SOIL/stbi_DDS_aug.h\n  src/vid_gl2/SOIL/stbi_DDS_aug_c.h\n  src/vid_gl2/c_billboardrenderer.cpp\n  src/vid_gl2/c_billboardrenderer.h\n  src/vid_gl2/c_bonelist.h\n  src/vid_gl2/c_boxrenderer.cpp\n  src/vid_gl2/c_boxrenderer.h\n  src/vid_gl2/c_effecttrianglerenderer.cpp\n  src/vid_gl2/c_effecttrianglerenderer.h\n  src/vid_gl2/c_fogofwar.cpp\n  src/vid_gl2/c_fogofwar.h\n  src/vid_gl2/c_foliagerenderer.cpp\n  src/vid_gl2/c_foliagerenderer.h\n  src/vid_gl2/c_gfx2d.cpp\n  src/vid_gl2/c_gfx2d.h\n  src/vid_gl2/c_gfx3d.cpp\n  src/vid_gl2/c_gfx3d.h\n  src/vid_gl2/c_gfxinit.cpp\n  src/vid_gl2/c_gfxinit.h\n  src/vid_gl2/c_gfxmaterials.cpp\n  src/vid_gl2/c_gfxmaterials.h\n  src/vid_gl2/c_gfxmodels.cpp\n  src/vid_gl2/c_gfxmodels.h\n  src/vid_gl2/c_gfxshaders.cpp\n  src/vid_gl2/c_gfxshaders.h\n  src/vid_gl2/c_gfxterrain.cpp\n  src/vid_gl2/c_gfxterrain.h\n  src/vid_gl2/c_gfxtextures.cpp\n  src/vid_gl2/c_gfxtextures.h\n  src/vid_gl2/c_gfxutils.cpp\n  src/vid_gl2/c_gfxutils.h\n  src/vid_gl2/c_glslpreprocessor.cpp\n  src/vid_gl2/c_glslpreprocessor.h\n  src/vid_gl2/c_linerenderer.cpp\n  src/vid_gl2/c_linerenderer.h\n  src/vid_gl2/c_meshrenderer.cpp\n  src/vid_gl2/c_meshrenderer.h\n  src/vid_gl2/c_pointrenderer.cpp\n  src/vid_gl2/c_pointrenderer.h\n  src/vid_gl2/c_postbuffer.cpp\n  src/vid_gl2/c_postbuffer.h\n  src/vid_gl2/c_procedural.cpp\n  src/vid_gl2/c_procedural.h\n  src/vid_gl2/c_proceduralregistry.cpp\n  src/vid_gl2/c_proceduralregistry.h\n  src/vid_gl2/c_renderlist.cpp\n  src/vid_gl2/c_renderlist.h\n  src/vid_gl2/c_scenebuffer.cpp\n  src/vid_gl2/c_scenebuffer.h\n  src/vid_gl2/c_scenepolyrenderer.cpp\n  src/vid_gl2/c_scenepolyrenderer.h\n  src/vid_gl2/c_shaderpreprocessor.cpp\n  src/vid_gl2/c_shaderpreprocessor.h\n  src/vid_gl2/c_shaderregistry.cpp\n  src/vid_gl2/c_shaderregistry.h\n  src/vid_gl2/c_shadersampler.cpp\n  src/vid_gl2/c_shadersampler.h\n  src/vid_gl2/c_shadersamplerregistry.cpp\n  src/vid_gl2/c_shadersamplerregistry.h\n  src/vid_gl2/c_shadervar.cpp\n  src/vid_gl2/c_shadervar.h\n  src/vid_gl2/c_shadervarregistry.cpp\n  src/vid_gl2/c_shadervarregistry.h\n  src/vid_gl2/c_shadowmap.cpp\n  src/vid_gl2/c_shadowmap.h\n  src/vid_gl2/c_skyrenderer.cpp\n  src/vid_gl2/c_skyrenderer.h\n  src/vid_gl2/c_terrainrenderer.cpp\n  src/vid_gl2/c_terrainrenderer.h\n  src/vid_gl2/c_texturearchive.cpp\n  src/vid_gl2/c_texturearchive.h\n  src/vid_gl2/c_texturecache.cpp\n  src/vid_gl2/c_texturecache.h\n  src/vid_gl2/c_treebillboardrenderer.cpp\n  src/vid_gl2/c_treebillboardrenderer.h\n  src/vid_gl2/c_treebranchrenderer.cpp\n  src/vid_gl2/c_treebranchrenderer.h\n  src/vid_gl2/c_treefrondrenderer.cpp\n  src/vid_gl2/c_treefrondrenderer.h\n  src/vid_gl2/c_treeleafrenderer.cpp\n  src/vid_gl2/c_treeleafrenderer.h\n  src/vid_gl2/c_treemodeldef.cpp\n  src/vid_gl2/c_treemodeldef.h\n  src/vid_gl2/c_treescenemanager.cpp\n  src/vid_gl2/c_treescenemanager.h\n  src/vid_gl2/d3dx_shared.cpp\n  src/vid_gl2/d3dx_shared.h\n  #  src/vid_gl2/gl2_common.h\n  src/vid_gl2/gl2_foliage.cpp\n  src/vid_gl2/gl2_foliage.h\n  src/vid_gl2/gl2_main.cpp\n  src/vid_gl2/gl2_os.h\n  #  src/vid_gl2/gl2_osx.mm\n  #  src/vid_gl2/gl2_linux.cpp\n  src/vid_gl2/gl2_procedurals.cpp\n  src/vid_gl2/gl2_shadersamplers.cpp\n  src/vid_gl2/gl2_shadervars.cpp\n  #  src/vid_gl2/gl2_win32.cpp\n  src/vid_gl2/i_debugrenderer.cpp\n  src/vid_gl2/i_debugrenderer.h\n  src/vid_gl2/i_effectrenderer.cpp\n  src/vid_gl2/i_effectrenderer.h\n  src/vid_gl2/i_renderer.cpp\n  src/vid_gl2/i_renderer.h\n  #  src/vid_gl2/libXNVCtrl/NVCtrl.c\n  #  src/vid_gl2/libXNVCtrl/NVCtrl.h\n  #  src/vid_gl2/libXNVCtrl/NVCtrlLib.h\n  #  src/vid_gl2/libXNVCtrl/nv_control.h\n  #  src/vid_gl2/ogl_mac.cpp\n  src/vid_gl2/vid_common.cpp\n  #  src/vid_gl2/vid_common.h\n  )\nif(WIN32)\n  list(APPEND VID_GL2_SOURCES src/vid_gl2/gl2_win32.cpp)\nelseif(LINUX)\n  list(APPEND VID_GL2_SOURCES src/vid_gl2/gl2_linux.cpp)\nelseif(APPLE)\n  list(APPEND VID_GL2_SOURCES src/vid_gl2/gl2_osx.mm)\nendif()\n\nadd_library(${VID_GL2_LIBRARY} MODULE ${VID_GL2_SOURCES})\napp_configure_lib(${VID_GL2_LIBRARY})\ntarget_precompile_headers(${VID_GL2_LIBRARY} PRIVATE src/vid_gl2/vid_common.h)\ntarget_compile_definitions(${VID_GL2_LIBRARY} PRIVATE ${VID_GL2_LIBRARY_DEFINITIONS})\ntarget_link_libraries(${VID_GL2_LIBRARY} ${VID_GL2_LIBRARIES})\nadd_dependencies(${VID_GL2_LIBRARY} ${VID_GL2_LIBRARY_DEPENDENCIES})\nendif() # if(NOT K2_NOVID)\n\n#========================================\n# hon_shared\n#========================================\nset(HON_SHARED_LIBRARY hon_shared)\nset(HON_SHARED_LIBRARY_LIB \"${HON_SHARED_LIBRARY}\")\nset(HON_SHARED_LIBRARY_DLL \"${BIN_DIR}/${HON_SHARED_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(HON_SHARED_LIBRARY_LIB \"${LIB_DIR}/${HON_SHARED_LIBRARY}${LIB_EXT}\")\nendif()\n\nset(HON_SHARED_SOURCES\n  src/hon_shared/c_abilityattributedefinition.h\n  src/hon_shared/c_abilitydefinition.h\n  src/hon_shared/c_affectordefinition.h\n  src/hon_shared/c_asAttacking.cpp\n  src/hon_shared/c_asAttacking.h\n  src/hon_shared/c_ascasting.cpp\n  src/hon_shared/c_asCasting.h\n  src/hon_shared/c_asMoving.cpp\n  src/hon_shared/c_asMoving.h\n  src/hon_shared/c_auradefinition.cpp\n  src/hon_shared/c_auradefinition.h\n  src/hon_shared/c_bability.cpp\n  src/hon_shared/c_bability.h\n  src/hon_shared/c_baggressivewander.cpp\n  src/hon_shared/c_baggressivewander.h\n  src/hon_shared/c_baggro.cpp\n  src/hon_shared/c_baggro.h\n  src/hon_shared/c_bassist.cpp\n  src/hon_shared/c_bassist.h\n  src/hon_shared/c_battack.cpp\n  src/hon_shared/c_battack.h\n  src/hon_shared/c_battackfollow.cpp\n  src/hon_shared/c_battackfollow.h\n  src/hon_shared/c_battackmove.cpp\n  src/hon_shared/c_battackmove.h\n  src/hon_shared/c_bdoubleactivateability.cpp\n  src/hon_shared/c_bdoubleactivateability.h\n  src/hon_shared/c_bdropitem.cpp\n  src/hon_shared/c_bdropitem.h\n  src/hon_shared/c_bevent.cpp\n  src/hon_shared/c_bevent.h\n  src/hon_shared/c_bfollow.cpp\n  src/hon_shared/c_bfollow.h\n  src/hon_shared/c_bfollowguard.cpp\n  src/hon_shared/c_bfollowguard.h\n  src/hon_shared/c_bgiveitem.cpp\n  src/hon_shared/c_bgiveitem.h\n  src/hon_shared/c_bguard.cpp\n  src/hon_shared/c_bguard.h\n  src/hon_shared/c_bguardfollow.cpp\n  src/hon_shared/c_bguardfollow.h\n  src/hon_shared/c_bhold.cpp\n  src/hon_shared/c_bhold.h\n  src/hon_shared/c_bmove.cpp\n  src/hon_shared/c_bmove.h\n  src/hon_shared/c_brain.cpp\n  src/hon_shared/c_brain.h\n  src/hon_shared/c_bsentry.cpp\n  src/hon_shared/c_bsentry.h\n  src/hon_shared/c_bstop.cpp\n  src/hon_shared/c_bstop.h\n  src/hon_shared/c_btouch.cpp\n  src/hon_shared/c_btouch.h\n  src/hon_shared/c_buildingdefinition.h\n  src/hon_shared/c_bwander.cpp\n  src/hon_shared/c_bwander.h\n  src/hon_shared/c_combatevent.cpp\n  src/hon_shared/c_combatevent.h\n  src/hon_shared/c_creepdefinition.h\n  src/hon_shared/c_critterdefinition.h\n  src/hon_shared/c_damageevent.cpp\n  src/hon_shared/c_damageevent.h\n  src/hon_shared/c_entitycamera.cpp\n  src/hon_shared/c_entitycamera.h\n  src/hon_shared/c_entitychest.cpp\n  src/hon_shared/c_entitychest.h\n  src/hon_shared/c_entitycreepspawner.cpp\n  src/hon_shared/c_entitycreepspawner.h\n  src/hon_shared/c_entitycritterspawner.cpp\n  src/hon_shared/c_entitycritterspawner.h\n  src/hon_shared/c_entitydefinitionresource.cpp\n  src/hon_shared/c_entitydefinitionresource.h\n  src/hon_shared/c_entityeffect.cpp\n  src/hon_shared/c_entityeffect.h\n  src/hon_shared/c_entityevent.h\n  src/hon_shared/c_entitykongorcontroller.cpp\n  src/hon_shared/c_entitykongorcontroller.h\n  src/hon_shared/c_entitykongorspawner.cpp\n  src/hon_shared/c_entitykongorspawner.h\n  src/hon_shared/c_entitylanenode.cpp\n  src/hon_shared/c_entitylanenode.h\n  src/hon_shared/c_entityneutralcampcontroller.cpp\n  src/hon_shared/c_entityneutralcampcontroller.h\n  src/hon_shared/c_entityneutralcampspawner.cpp\n  src/hon_shared/c_entityneutralcampspawner.h\n  #  src/hon_shared/c_entitynpccontroller.cpp\n  #  src/hon_shared/c_entitynpccontroller.h\n  src/hon_shared/c_entitypowerupspawner.cpp\n  src/hon_shared/c_entitypowerupspawner.h\n  src/hon_shared/c_entityregistry.cpp\n  src/hon_shared/c_entityregistry.h\n  src/hon_shared/c_entitystate.h\n  src/hon_shared/c_eventdirectory.cpp\n  src/hon_shared/c_eventdirectory.h\n  src/hon_shared/c_gadgetdefinition.h\n  src/hon_shared/c_gamedefinition.h\n  src/hon_shared/c_gameevent.cpp\n  src/hon_shared/c_gameevent.h\n  src/hon_shared/c_gameinfo.cpp\n  src/hon_shared/c_gameinfo.h\n  src/hon_shared/c_gamelogparser.cpp\n  src/hon_shared/c_gamelogparser.h\n  src/hon_shared/c_gamemechanics.cpp\n  src/hon_shared/c_gamemechanics.h\n  src/hon_shared/c_gamemechanicsresource.cpp\n  src/hon_shared/c_gamemechanicsresource.h\n  src/hon_shared/c_gamestats.cpp\n  src/hon_shared/c_gamestats.h\n  src/hon_shared/c_herodefinition.h\n  src/hon_shared/c_itemdefinition.h\n  src/hon_shared/c_lane.cpp\n  src/hon_shared/c_lane.h\n  src/hon_shared/c_lightstatic.cpp\n  src/hon_shared/c_lightstatic.h\n  src/hon_shared/c_linearaffector.cpp\n  src/hon_shared/c_linearaffector.h\n  src/hon_shared/c_linearaffectordefinition.h\n  src/hon_shared/c_neutraldefinition.h\n  src/hon_shared/c_orderdefinition.h\n  #  src/hon_shared/c_petdefinition.cpp\n  #  src/hon_shared/c_petdefinition.h\n  src/hon_shared/c_player.cpp\n  src/hon_shared/c_player.h\n  src/hon_shared/c_playeraccountstats.cpp\n  src/hon_shared/c_playeraccountstats.h\n  src/hon_shared/c_powerupdefinition.h\n  src/hon_shared/c_projectiledefinition.h\n  src/hon_shared/c_propdynamic.cpp\n  src/hon_shared/c_propdynamic.h\n  src/hon_shared/c_propscenery.cpp\n  src/hon_shared/c_propscenery.h\n  src/hon_shared/c_proptree.cpp\n  src/hon_shared/c_proptree.h\n  #  src/hon_shared/c_propwater.cpp\n  #  src/hon_shared/c_propwater.h\n  src/hon_shared/c_replayinfo.cpp\n  src/hon_shared/c_replayinfo.h\n  src/hon_shared/c_replaymanager.cpp\n  src/hon_shared/c_replaymanager.h\n  src/hon_shared/c_scriptdirectory.cpp\n  src/hon_shared/c_scriptdirectory.h\n  src/hon_shared/c_scriptthread.cpp\n  src/hon_shared/c_scriptthread.h\n  #  src/hon_shared/c_serverinfo.cpp\n  #  src/hon_shared/c_serverinfo.h\n  src/hon_shared/c_shopdefinition.h\n  src/hon_shared/c_shopinfo.cpp\n  src/hon_shared/c_shopinfo.h\n  src/hon_shared/c_shopiteminfo.cpp\n  src/hon_shared/c_shopiteminfo.h\n  src/hon_shared/c_statedefinition.h\n  src/hon_shared/c_statenetaccumdefinition.h\n  src/hon_shared/c_teaminfo.cpp\n  src/hon_shared/c_teaminfo.h\n  src/hon_shared/c_triggermarker.cpp\n  src/hon_shared/c_triggermarker.h\n  src/hon_shared/c_triggerspawnpoint.cpp\n  src/hon_shared/c_triggerspawnpoint.h\n  src/hon_shared/c_visibilitymap.cpp\n  src/hon_shared/c_visibilitymap.h\n  src/hon_shared/c_xmlproc_ability.cpp\n  src/hon_shared/c_xmlproc_affector.cpp\n  src/hon_shared/c_xmlproc_building.cpp\n  src/hon_shared/c_xmlproc_combatactions.cpp\n  src/hon_shared/c_xmlproc_creep.cpp\n  src/hon_shared/c_xmlproc_critter.cpp\n  src/hon_shared/c_xmlproc_gadget.cpp\n  src/hon_shared/c_xmlproc_game.cpp\n  src/hon_shared/c_xmlproc_hero.cpp\n  src/hon_shared/c_xmlproc_item.cpp\n  #  src/hon_shared/c_xmlproc_itemdef.cpp\n  src/hon_shared/c_xmlproc_linearaffector.cpp\n  src/hon_shared/c_xmlproc_neutral.cpp\n  src/hon_shared/c_xmlproc_order.cpp\n  src/hon_shared/c_xmlproc_pet.cpp\n  src/hon_shared/c_xmlproc_powerup.cpp\n  src/hon_shared/c_xmlproc_projectile.cpp\n  src/hon_shared/c_xmlproc_shop.cpp\n  src/hon_shared/c_xmlproc_state.cpp\n  src/hon_shared/combat_actions.h\n  src/hon_shared/game_shared_api.h\n  src/hon_shared/game_shared_common.cpp\n  src/hon_shared/game_shared_common.h\n  src/hon_shared/game_shared_constants.h\n  src/hon_shared/game_shared_cvars.cpp\n  src/hon_shared/game_shared_cvars.h\n  src/hon_shared/game_shared_entities.cpp\n  src/hon_shared/game_shared_entities.h\n  src/hon_shared/game_shared_protocol.h\n  src/hon_shared/game_shared_states.h\n  src/hon_shared/game_shared_types.h\n  src/hon_shared/i_areaaffector.cpp\n  src/hon_shared/i_areaaffector.h\n  src/hon_shared/i_ActionState.h\n  src/hon_shared/i_baseentityallocator.h\n  src/hon_shared/i_behavior.cpp\n  src/hon_shared/i_behavior.h\n  src/hon_shared/i_bitentity.cpp\n  src/hon_shared/i_bitentity.h\n  src/hon_shared/i_buildingentity.cpp\n  src/hon_shared/i_buildingentity.h\n  src/hon_shared/i_combataction.cpp\n  src/hon_shared/i_combataction.h\n  src/hon_shared/i_creepentity.cpp\n  src/hon_shared/i_creepentity.h\n  src/hon_shared/i_critterentity.cpp\n  src/hon_shared/i_critterentity.h\n  src/hon_shared/i_entityability.cpp\n  src/hon_shared/i_entityability.h\n  src/hon_shared/i_entityabilityattribute.cpp\n  src/hon_shared/i_entityabilityattribute.h\n  src/hon_shared/i_entitydefinition.cpp\n  src/hon_shared/i_entitydefinition.h\n  src/hon_shared/i_entitydirectory.cpp\n  src/hon_shared/i_entitydirectory.h\n  src/hon_shared/i_entityitem.cpp\n  src/hon_shared/i_entityitem.h\n  src/hon_shared/i_entitystate.cpp\n  src/hon_shared/i_entitystate.h\n  src/hon_shared/i_entitystatenetaccum.cpp\n  src/hon_shared/i_entitystatenetaccum.h\n  src/hon_shared/i_entitytool.cpp\n  src/hon_shared/i_entitytool.h\n  src/hon_shared/i_gadgetentity.cpp\n  src/hon_shared/i_gadgetentity.h\n  src/hon_shared/i_game.cpp\n  src/hon_shared/i_game.h\n  src/hon_shared/i_gameentity.cpp\n  src/hon_shared/i_gameentity.h\n  src/hon_shared/i_heroentity.cpp\n  src/hon_shared/i_heroentity.h\n  src/hon_shared/i_light.cpp\n  src/hon_shared/i_light.h\n  src/hon_shared/i_neutralentity.cpp\n  src/hon_shared/i_neutralentity.h\n  src/hon_shared/i_orderentity.cpp\n  src/hon_shared/i_orderentity.h\n  src/hon_shared/i_petentity.cpp\n  src/hon_shared/i_petentity.h\n  src/hon_shared/i_powerupentity.cpp\n  src/hon_shared/i_powerupentity.h\n  src/hon_shared/i_projectile.cpp\n  src/hon_shared/i_projectile.h\n  src/hon_shared/i_propentity.cpp\n  src/hon_shared/i_propentity.h\n  src/hon_shared/i_shopentity.cpp\n  src/hon_shared/i_shopentity.h\n  src/hon_shared/i_slavedefinition.cpp\n  src/hon_shared/i_slavedefinition.h\n  src/hon_shared/i_slaveentity.cpp\n  src/hon_shared/i_slaveentity.h\n  #  src/hon_shared/i_temporalstate.cpp\n  #  src/hon_shared/i_temporalstate.h\n  src/hon_shared/i_tooldefinition.cpp\n  src/hon_shared/i_tooldefinition.h\n  src/hon_shared/i_unitdefinition.cpp\n  src/hon_shared/i_unitdefinition.h\n  src/hon_shared/i_unitentity.cpp\n  src/hon_shared/i_unitentity.h\n  src/hon_shared/i_visualentity.cpp\n  src/hon_shared/i_visualentity.h\n  src/hon_shared/i_waypoint.cpp\n  src/hon_shared/i_waypoint.h\n  )\n\nadd_library(${HON_SHARED_LIBRARY} SHARED ${HON_SHARED_SOURCES})\napp_configure_lib(${HON_SHARED_LIBRARY})\ntarget_compile_definitions(${HON_SHARED_LIBRARY} PRIVATE GAME_SHARED_EXPORTS)\ntarget_compile_definitions(${HON_SHARED_LIBRARY} PUBLIC ${HON_SHARED_PUBLIC_DEFINITIONS})\ntarget_precompile_headers(${HON_SHARED_LIBRARY} PRIVATE src/hon_shared/game_shared_common.h)\ntarget_link_libraries(${HON_SHARED_LIBRARY}\n  ${HON_SHARED_LIBRARIES}\n  \"${K2_LIBRARY}\"\n  )\n\n#========================================\n# hon_client\n#========================================\nset(HON_CLIENT_LIBRARY hon_client)\nset(HON_CLIENT_LIBRARY_LIB \"${HON_CLIENT_LIBRARY}\")\nset(HON_CLIENT_LIBRARY_DLL \"${BIN_DIR}/${HON_CLIENT_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(HON_CLIENT_LIBRARY_LIB \"${LIB_DIR}/${HON_CLIENT_LIBRARY}${LIB_EXT}\")\nendif()\n\n# hon_client sources\nset(HON_CLIENT_SOURCES\n  src/hon_client/c_clientcommander.cpp\n  src/hon_client/c_clientcommander.h\n  src/hon_client/c_cliententity.cpp\n  src/hon_client/c_cliententity.h\n  src/hon_client/c_cliententitydirectory.cpp\n  src/hon_client/c_cliententitydirectory.h\n  src/hon_client/c_gameclient.cpp\n  src/hon_client/c_gameclient.h\n  src/hon_client/c_gameinterfacemanager.cpp\n  src/hon_client/c_gameinterfacemanager.h\n  src/hon_client/game_client_actions.cpp\n  src/hon_client/game_client_commands.cpp\n  src/hon_client/game_client_common.cpp\n  src/hon_client/game_client_common.h\n  src/hon_client/game_client_main.cpp\n  )\n\nadd_library(${HON_CLIENT_LIBRARY} MODULE ${HON_CLIENT_SOURCES})\napp_configure_lib(${HON_CLIENT_LIBRARY})\ntarget_compile_definitions(${HON_CLIENT_LIBRARY} PRIVATE GAME_CLIENT_EXPORTS)\ntarget_precompile_headers(${HON_CLIENT_LIBRARY} PRIVATE src/hon_client/game_client_common.h)\ntarget_link_libraries(${HON_CLIENT_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n#========================================\n# hon_server\n#========================================\nset(HON_SERVER_LIBRARY hon_server)\nset(HON_SERVER_LIBRARY_LIB \"${HON_SERVER_LIBRARY}\")\nset(HON_SERVER_LIBRARY_DLL \"${BIN_DIR}/${HON_SERVER_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(HON_SERVER_LIBRARY_LIB \"${LIB_DIR}/${HON_SERVER_LIBRARY}${LIB_EXT}\")\nendif()\n\n# hon_server sources\nset(HON_SERVER_SOURCES\n  #  src/hon_server/c_game_server_commands.cpp\n  src/hon_server/c_gamelog.cpp\n  src/hon_server/c_gamelog.h\n  src/hon_server/c_gamelogevent.h\n  src/hon_server/c_gameserver.cpp\n  src/hon_server/c_gameserver.h\n  #  src/hon_server/c_serverentity.cpp\n  #  src/hon_server/c_serverentity.h\n  src/hon_server/c_serverentitydirectory.cpp\n  src/hon_server/c_serverentitydirectory.h\n  #  src/hon_server/c_serverstatstracker.cpp\n  #  src/hon_server/c_serverstatstracker.h\n  #  src/hon_server/c_svent_player.cpp\n  #  src/hon_server/c_svent_player.h\n  src/hon_server/c_triggermanager.cpp\n  src/hon_server/c_triggermanager.h\n  src/hon_server/game_server_commands.cpp\n  src/hon_server/game_server_common.cpp\n  src/hon_server/game_server_common.h\n  src/hon_server/game_server_main.cpp\n  )\n\nadd_library(${HON_SERVER_LIBRARY} MODULE ${HON_SERVER_SOURCES})\napp_configure_lib(${HON_SERVER_LIBRARY})\ntarget_compile_definitions(${HON_SERVER_LIBRARY} PRIVATE GAME_SERVER_EXPORTS)\ntarget_precompile_headers(${HON_SERVER_LIBRARY} PRIVATE src/hon_server/game_server_common.h)\ntarget_link_libraries(${HON_SERVER_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n#========================================\n# modelviewer\n#========================================\nset(MODELVIEWER_LIBRARY modelviewer_client)\nset(MODELVIEWER_LIBRARY_LIB \"${MODELVIEWER_LIBRARY}\")\nset(MODELVIEWER_LIBRARY_DLL \"${BIN_DIR}/${MODELVIEWER_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(MODELVIEWER_LIBRARY_LIB \"${LIB_DIR}/${MODELVIEWER_LIBRARY}${LIB_EXT}\")\nendif()\nset(MODELVIEWER_GAME_NAME \"K2\")\n\n# modelviewer sources\nset(MODELVIEWER_SOURCES\n  src/modelviewer/mv_main.cpp\n  src/modelviewer/mv_common.cpp\n  src/modelviewer/mv_common.h\n  src/modelviewer/mv.h\n  )\n\nadd_library(${MODELVIEWER_LIBRARY} MODULE ${MODELVIEWER_SOURCES})\napp_configure_lib(${MODELVIEWER_LIBRARY})\ntarget_compile_definitions(${MODELVIEWER_LIBRARY} PRIVATE MODELVIEWER_EXPORTS)\ntarget_precompile_headers(${MODELVIEWER_LIBRARY} PRIVATE src/modelviewer/mv_common.h)\ntarget_link_libraries(${MODELVIEWER_LIBRARY}\n  \"${K2_LIBRARY}\"\n  )\n\n#========================================\n# editor\n#========================================\nset(EDITOR_LIBRARY editor_client)\nset(EDITOR_LIBRARY_LIB \"${EDITOR_LIBRARY}\")\nset(EDITOR_LIBRARY_DLL \"${BIN_DIR}/${EDITOR_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(EDITOR_LIBRARY_LIB \"${LIB_DIR}/${EDITOR_LIBRARY}${LIB_EXT}\")\nendif()\n\n# editor sources\nset(EDITOR_SOURCES\n  src/editor/c_blockertool.cpp\n  src/editor/c_clifftool.cpp\n  src/editor/c_deformtool.cpp\n  src/editor/c_editor.cpp\n  src/editor/c_entitytool.cpp\n  src/editor/c_foliagetool.cpp\n  src/editor/c_lightmaptool.cpp\n  src/editor/c_lighttool.cpp\n  src/editor/c_occludertool.cpp\n  src/editor/c_painttool.cpp\n  src/editor/c_soundtool.cpp\n  #  src/editor/c_spawntool.cpp\n  #  src/editor/c_stamptool.cpp\n  src/editor/c_toolbox.cpp\n  src/editor/c_treedefinitionresource.cpp\n  #  src/editor/c_treetool.cpp\n  src/editor/c_watertool.cpp\n  src/editor/c_xmlproc_brushlistitems.cpp\n  src/editor/c_xmlproc_cliff.cpp\n  src/editor/c_xmlproc_skylistitems.cpp\n  src/editor/c_xmlproc_toollistitems.cpp\n  src/editor/c_xmlproc_tree.cpp\n  src/editor/editor_common.cpp\n  src/editor/editor_main.cpp\n  )\n\nadd_library(${EDITOR_LIBRARY} MODULE ${EDITOR_SOURCES})\napp_configure_lib(${EDITOR_LIBRARY})\napp_configure_game_settings(${EDITOR_LIBRARY} \"${HON_GAME_NAME}\" \"Editor\")\ntarget_compile_definitions(${EDITOR_LIBRARY} PRIVATE EDITOR_EXPORTS)\ntarget_precompile_headers(${EDITOR_LIBRARY} PRIVATE src/editor/editor_common.h)\ntarget_link_libraries(${EDITOR_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n\n#========================================\n# bet_client\n#========================================\nset(BET_CLIENT_LIBRARY bet_client)\nset(BET_CLIENT_LIBRARY_LIB \"${BET_CLIENT_LIBRARY}\")\nset(BET_CLIENT_LIBRARY_DLL \"${BIN_DIR}/${BET_CLIENT_LIBRARY}${DLL_EXT}\")\nif (WIN32)\n  set(BET_CLIENT_LIBRARY_LIB \"${LIB_DIR}/${BET_CLIENT_LIBRARY}${LIB_EXT}\")\nendif()\n\n# bet_client sources\nset(BET_CLIENT_SOURCES\n  #  src/bet_client/c_clientcommander.cpp\n  #  src/bet_client/c_clientcommander.h\n  #  src/bet_client/c_cliententity.cpp\n  #  src/bet_client/c_cliententity.h\n  #  src/bet_client/c_cliententitydirectory.cpp\n  #  src/bet_client/c_cliententitydirectory.h\n  src/bet_client/c_gameclient.cpp\n  src/bet_client/c_gameclient.h\n  #  src/bet_client/c_gameinterfacemanager.cpp\n  #  src/bet_client/c_gameinterfacemanager.h\n  #  src/bet_client/game_client_actions.cpp\n  #  src/bet_client/game_client_commands.cpp\n  #  src/bet_client/game_client_common.cpp\n  #  src/bet_client/game_client_common.h\n  src/bet_client/game_client_main.cpp\n  src/bet_client/bet_client_common.cpp\n  src/bet_client/bet_client_common.h\n  )\n\nadd_library(${BET_CLIENT_LIBRARY} MODULE ${BET_CLIENT_SOURCES})\napp_configure_lib(${BET_CLIENT_LIBRARY})\ntarget_compile_definitions(${BET_CLIENT_LIBRARY} PRIVATE GAME_CLIENT_EXPORTS)\ntarget_precompile_headers(${BET_CLIENT_LIBRARY} PRIVATE src/bet_client/bet_client_common.h)\ntarget_link_libraries(${BET_CLIENT_LIBRARY}\n  \"${K2_LIBRARY}\"\n  \"${HON_SHARED_LIBRARY}\"\n  )\n\n#========================================\n# shell\n#========================================\nlist(APPEND SHELL_SOURCES\n  src/shell/shell_common.cpp\n  src/shell/misc_cmds.cpp\n  )\nif(APPLE)\n  list(APPEND SHELL_SOURCES src/shell/main_osx.mm)\nelseif(LINUX)\n  list(APPEND SHELL_SOURCES src/shell/main_linux.cpp)\nelseif(WIN32)\n  list(APPEND SHELL_SOURCES src/shell/main_win32.cpp)\nendif()\n\nadd_library(shell INTERFACE ${SHELL_SOURCES})\ntarget_include_directories(shell INTERFACE src/shell)\n#list(APPEND SHELL_MAIN $<TARGET_OBJECTS:shell>)\nlist(APPEND SHELL_MAIN ${SHELL_SOURCES})\n\n#========================================\n# K2_ModelViewer\n#========================================\nset(K2_MODELVIEWER_EXE K2_ModelViewer)\nset(K2_MODELVIEWER_MODS game editor modelviewer)\n\nlist(APPEND K2_MODELVIEWER_DEPENDENCIES\n  ${K2_LIBRARY}\n  ${VID_GL2_LIBRARY}\n  ${MODELVIEWER_LIBRARY}\n  )\nlist(APPEND K2_MODELVIEWER_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND K2_MODELVIEWER_LIBRARIES\n  ${K2_LIBRARY}\n  shell\n  )\n\nadd_executable(${K2_MODELVIEWER_EXE} ${EXE_TYPE} ${K2_MODELVIEWER_SOURCES})\nadd_dependencies(${K2_MODELVIEWER_EXE} ${K2_MODELVIEWER_DEPENDENCIES})\ntarget_link_libraries(${K2_MODELVIEWER_EXE} ${K2_MODELVIEWER_LIBRARIES})\ntarget_include_directories(${K2_MODELVIEWER_EXE} PRIVATE \"src/Heroes of Newerth_shell\")\ntarget_precompile_headers(${K2_MODELVIEWER_EXE} PRIVATE \"src/Heroes of Newerth_shell/shell_common.h\")\napp_configure_game_settings(${K2_MODELVIEWER_EXE} \"K2\" \"Model Viewer\")\napp_configure_exe(${K2_MODELVIEWER_EXE} \"K2 Model Viewer\" \"${HON_ICON}\" \"${HON_CONTENT_DIR}\" ${K2_MODELVIEWER_MODS})\n\n#========================================\n# NoH\n#========================================\nset(NOH_EXE NoH)\nset(NOH_MODS hon game)\n\nlist(APPEND NOH_DEPENDENCIES\n  ${K2_LIBRARY}\n  ${VID_GL2_LIBRARY}\n  ${HON_CLIENT_LIBRARY}\n  ${HON_SERVER_LIBRARY}\n  )\n\nlist(APPEND NOH_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND NOH_LIBRARIES\n  ${K2_LIBRARY}\n  shell\n  )\n\nadd_executable(${NOH_EXE} ${EXE_TYPE} ${NOH_SOURCES})\nadd_dependencies(${NOH_EXE} ${NOH_DEPENDENCIES})\ntarget_link_libraries(${NOH_EXE} ${NOH_LIBRARIES})\ntarget_include_directories(${NOH_EXE} PRIVATE \"src/Heroes of Newerth_shell\")\ntarget_precompile_headers(${NOH_EXE} PRIVATE \"src/Heroes of Newerth_shell/shell_common.h\")\napp_configure_game_settings(${NOH_EXE} \"${HON_GAME_NAME}\" \"\")\napp_configure_exe(${NOH_EXE} \"NoH\" \"${HON_ICON}\" \"${HON_CONTENT_DIR}\" ${NOH_MODS})\n\n#========================================\n# NoH_Editor\n#========================================\nset(NOH_EDITOR_EXE NoH_Editor)\nset(NOH_EDITOR_MODS ${NOH_MODS} editor)\n\nlist(APPEND NOH_EDITOR_DEPENDENCIES\n  ${NOH_DEPENDENCIES}\n  ${EDITOR_LIBRARY}\n  )\n\nlist(APPEND NOH_EDITOR_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND NOH_EDITOR_LIBRARIES\n  ${NOH_LIBRARIES}\n  shell\n  )\n\nadd_executable(${NOH_EDITOR_EXE} ${EXE_TYPE} ${NOH_EDITOR_SOURCES})\nadd_dependencies(${NOH_EDITOR_EXE} ${NOH_EDITOR_DEPENDENCIES})\ntarget_link_libraries(${NOH_EDITOR_EXE} ${NOH_EDITOR_LIBRARIES})\ntarget_include_directories(${NOH_EDITOR_EXE} PRIVATE \"src/Heroes of Newerth_shell\")\ntarget_precompile_headers(${NOH_EDITOR_EXE} PRIVATE \"src/Heroes of Newerth_shell/shell_common.h\")\napp_configure_game_settings(${NOH_EDITOR_EXE} \"NoH\" \"Editor\")\napp_configure_exe(${NOH_EDITOR_EXE} \"NoH Editor\" \"${HON_ICON}\" \"${HON_CONTENT_DIR}\" ${NOH_EDITOR_MODS})\n\n\n#========================================\n# BeT\n#========================================\nset(BET_EXE Beatopia)\nset(BET_MODS hon bet game)\n\nlist(APPEND BET_DEPENDENCIES\n  ${K2_LIBRARY}\n  ${VID_GL2_LIBRARY}\n  ${HON_CLIENT_LIBRARY}\n  ${HON_SERVER_LIBRARY}\n  ${BET_CLIENT_LIBRARY}\n  )\n\nlist(APPEND BET_SOURCES\n  ${SHELL_MAIN}\n  )\nlist(APPEND BET_LIBRARIES\n  ${K2_LIBRARY}\n  shell\n  )\n\nadd_executable(${BET_EXE} ${EXE_TYPE} ${BET_SOURCES})\nadd_dependencies(${BET_EXE} ${BET_DEPENDENCIES})\ntarget_link_libraries(${BET_EXE} ${BET_LIBRARIES})\ntarget_include_directories(${BET_EXE} PRIVATE src/Beatopia_shell)\ntarget_precompile_headers(${BET_EXE} PRIVATE \"src/Beatopia_shell/shell_common.h\")\napp_configure_game_settings(${BET_EXE} \"${BET_GAME_NAME}\" \"\")\napp_configure_exe(${BET_EXE} \"BeT\" \"${HON_ICON}\" \"${BET_CONTENT_DIR}\" ${BET_MODS})\n\nif(K2_SYMLINK_MOD_DIRS_IN_BUILD_DIR)\n  # This doesn't quite work, because multiple games means we can't symlink the content dirs inside the build dir\n  foreach (mod base game modelviewer)\n    foreach (game HON)\n      target_symlink(${K2_LIBRARY}\n        \"${${game}_CONTENT_DIR}/${mod}\"\n        \"${CMAKE_BINARY_DIR}/${mod}\"\n        )\n    endforeach()\n  endforeach()\nendif()\n\n#\n# Installation\n#\n\n# Set default install prefix to ./install (inside the project source directory)\nif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n  set(CMAKE_INSTALL_PREFIX \"${noh_SOURCE_DIR}/install\" CACHE PATH \"Install path\" FORCE)\nendif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n\n# Bundles\nif(APPLE)\n  install(TARGETS ${NOH_APP}\n    BUNDLE DESTINATION . COMPONENT Runtime\n    RUNTIME DESTINATION bin COMPONENT Runtime\n    LIBRARY DESTINATION lib\n    ARCHIVE DESTINATION lib/static)\n\n  # Note Mac specific extension .app\n  set(APPS \"\\${CMAKE_INSTALL_PREFIX}/${NOH_APP}.app\")\n\n  # Directories to look for dependencies\n  set(DIRS ${CMAKE_BINARY_DIR})\n\n  install(CODE \"include(BundleUtilities)\n    fixup_bundle(\\\"${APPS}\\\" \\\"\\\" \\\"${DIRS}\\\")\")\n\n  set(CPACK_GENERATOR \"DRAGNDROP\")\n  include(CPack)\nendif()\n#install(TARGETS ${K2_LIBRARY}\n#  LIBRARY DESTINATION lib\n#  ARCHIVE DESTINATION lib/static)\n#install (FILES ${HEADERS} DESTINATION include)\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/CMakeLists.txt	(date 1685014029400)
@@ -1172,6 +1172,8 @@
   src/k2/i_resource.h
   src/k2/i_resourcelibrary.cpp
   src/k2/i_resourcelibrary.h
+  src/k2/i_resourcewatcher2.cpp
+  src/k2/i_resourcewatcher2.h
   src/k2/i_snapshot.cpp
   src/k2/i_snapshot.h
   src/k2/i_tag.cpp
@@ -1240,7 +1242,7 @@
   src/k2/srp.cpp
   src/k2/c_srp.h
   src/k2/c_srp.cpp
-  )
+  src/k2/i_resourcecommon.h)
 
 if(WIN32)
   list(APPEND K2_SOURCES
@@ -1932,7 +1934,7 @@
   src/bet_client/game_client_main.cpp
   src/bet_client/bet_client_common.cpp
   src/bet_client/bet_client_common.h
-  )
+)
 
 add_library(${BET_CLIENT_LIBRARY} MODULE ${BET_CLIENT_SOURCES})
 app_configure_lib(${BET_CLIENT_LIBRARY})
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Newerth of Heroes\n\n<img width=\"320\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236418122-c052ff68-467a-470f-9f90-fc53d51de862.png\">\n\nAn open source implementation of [dota](https://www.youtube.com/watch?v=qTsaS1Tm-Ic&ab_channel=BASSHUNTER). \n\nCross platform; multiplayer; lobby system; map editor; replay system; semicolon. Builds in 3 minutes flat on an M1 Air.\n\n\nTable of Contents\n=================\n\n* [About](#about)\n* [Media](#media)\n  * [Newerth dev stream #1](#newerth-dev-stream-1)\n  * [\"I was a former HoN dev. AMA\"](#i-was-a-former-hon-dev-ama)\n* [License](#license)\n* [Compiling NoH](#compiling-noh)\n  * [Building NoH on macOS](#building-noh-on-macos)\n     * [Install macOS dependencies](#install-macos-dependencies)\n     * [Clone the repository (--recursive is important!)](#clone-the-repository---recursive-is-important)\n     * [Build on macOS with CMake](#build-on-macos-with-cmake)\n     * [Building NoH on macOS with CLion](#building-noh-on-macos-with-clion)\n        * [Open the repo in CLion](#open-the-repo-in-clion)\n        * [Once CLion is open](#once-clion-is-open)\n        * [If things go wrong](#if-things-go-wrong)\n  * [Building NoH on Windows](#building-noh-on-windows)\n     * [Install Git for Windows](#install-git-for-windows)\n     * [Install CMake for Windows](#install-cmake-for-windows)\n     * [Install Visual Studio](#install-visual-studio)\n     * [Install CLion](#install-clion)\n     * [Build with CLion](#build-with-clion)\n\n<!-- Created by https://github.com/ekalinin/github-markdown-toc -->\n\n## About\n\nIntended to be the game engine that my 13yo self wished he'd had. Think of it as a baseline \"here's a fully working game engine, along with an actual game\" reference that you can use for whatever you want. It's small enough that you can understand it, build it yourself, and customize.\n\nMy long term goal is to implement a custom game system reminiscent of the StarCraft 1 \"Use Map Settings\" era. There was [something magical about it](https://www.youtube.com/watch?v=hu_ekZfW6wE&t=76s&ab_channel=RedDevouringOne) that modern \"custom game\" attempts don't really capture. If you remember it, you know what I mean -- point to any modern equivalent that makes you feel the same spark of joy of joining a random lobby and discovering that it's actually a weirdly-detailed esoteric RPG that some 14yo crafted in StarEdit, or an intense tower defense experience that you didn't expect.\n\n<img width=\"595\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236426949-89ac5d63-f391-4701-978c-63f93e31cb5d.png\">\n\nIt also makes my heart ache that your only realistic choices for becoming a professional gamedev circa 2023 is to build everything from scratch yourself (Celeste) or to spend years learning Unreal Engine or Unity. Good luck understanding the inner workings of those behemoths, much less getting UE to build.\n\nSo hopefully this will give you a leg up as a lone wolf gamedev.\n\n<img width=\"595\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236428981-60051d51-eeda-4e99-9846-e5024ae8f37f.png\">\n\nUltimately, I expect this to take somewhere between three months and three years, and for roughly seven people to care about it. But if you're one of those seven, know that you'll have all my heart and soul pushing you forward, for whatever it's worth. I fell in love with the K2 engine when I worked at S2 in 2010. Perhaps one or two others might too.\n\n## Media\n\n### Newerth dev stream #1\n\nhttps://youtu.be/VBj0RcpxCIc?t=132\n\nI wanted to give hackers a sense of how it feels to work with the engine, so I recorded about an hour of random work.\n\nBe sure to read the chapter titles as you watch; it's a detailed blow-by-blow of my thought process as I went.\n\n### \"I was a former HoN dev. AMA\"\n\nhttps://www.reddit.com/r/DotA2/comments/asc14j/i_was_a_former_hon_dev_ama/\n\nThis was an AMA I did when S2 officially shuttered Hon after Valve steamrolled them. The timestamp says four years ago, but it feels like a decade.\n\nI originally joined S2 because I loved the game, and a certain bug was so frustrating that I simply had to annihilate it. Joining the company was the only way I could, so I did.\n\n## License\n\nAll code and assets are MIT licensed, to the extent that I'm authorized to do so. Which is to say, not at all. But nobody cares at this point.\n\n## Compiling NoH\n\n### Building NoH on macOS\n\n##### Install macOS dependencies\n\nInstall [Homebrew](https://brew.sh/):\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\nInstall the dependencies:\n\n```\nbrew install cmake llvm ninja speex speexdsp giflib libpng libjpeg openssl@1.1 freetype fswatch fileicon\n```\n\n##### Clone the repository (`--recursive` is important!)\n\n```\ngit clone --recursive https://github.com/shawwn/noh\n```\n\n##### Build on macOS with CMake\n\n```\ncd noh\nmkdir build\ncd build\ncmake ..\ncmake --build . -j12\n```\n\nThings you can do:\n\n- Run `./K2\\ Model\\ Viewer` and play with some effects\n- Run `./NoH` and click \"Local Game\" to start a game\n- Run `./NoH\\ Editor`\n\n\n### Building NoH on macOS with [CLion](https://www.jetbrains.com/clion/download/#section=mac)\n\n##### Open the repo in [CLion](https://www.jetbrains.com/clion/download/#section=mac):\n```\ncd noh\nclion .\n```\n ##### Once CLion is open\n\n- Open Project view (press `Cmd-1`)\n\n- Open `CMakeLists.txt`\n\n- Click \"Load CMake project\" in the upper right\n\n<img width=\"1512\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236375944-0f028a9f-79b9-4939-b063-a9657fafe59b.png\">\n\nIgnore the scary-looking errors and just click the play button (`Run -> Run 'NoH'`)\n\n<img width=\"1398\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376120-22f8d300-5b8c-4615-bf48-f3c2b03256cb.png\">\n\nIf things go well, NoH will launch. Congratulations!\n\n<img width=\"1440\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376813-77395c90-89e6-4713-9a6b-09859caf33f9.png\">\n\n#### If things go wrong\n\nOpen CMake tab, click \"Reset Cache and Reload Project\" (the icon in the upper left of the tab with two arrows)\n\n<img width=\"889\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376625-105f0786-06b2-4032-bdaf-7d7f97144d17.png\">\n\nBuild -> Rebuild all in Release\n\n<img width=\"297\" alt=\"image\" src=\"https://user-images.githubusercontent.com/59632/236376681-1eff6c59-43d8-462f-8a84-20ebe6f341b1.png\">\n\nRun -> Run NoH, or just click the play button\n\nIf things still aren't working, [post an issue](https://github.com/shawwn/noh/issues) or DM me on Twitter: [@theshawwn](https://twitter.com/theshawwn)\n\n### Building NoH on Windows\n\n##### Install Git for Windows\n\nInstall [Git for Windows](https://gitforwindows.org/)\n\nDuring setup, you can leave everything as default, **except make sure you check \"Enable symbolic links\"**:\n\n<img width=\"514\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/0d03e2a0-dac6-4176-b427-6c30c3dcec5e\">\n\n##### Install CMake for Windows\n\n[Download CMake](https://cmake.org/download/) (probably choose \"Windows x64 Installer\")\n\n\n<img width=\"498\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/7735c747-a017-4aae-b775-042fe48c7bfc\">\n\nDuring setup, click \"Add CMake to the system PATH for the current user\":\n\n<img width=\"497\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/a7e6fde2-ef1e-4e86-b753-416ee6390b4d\">\n\n##### Install Visual Studio\n\nIf you have Visual Studio 2019 or later instsalled, you can skip this step.\n\nInstall [Visual Studio 2022 Community](https://visualstudio.microsoft.com/downloads/):\n\n<img width=\"478\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/4fde72d4-204b-4a16-a7d6-40e3b2640de2\">\n\nDuring setup, choose \"Desktop development with C++\":\n\n<img width=\"1238\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/ebbeaefd-9d92-4bff-a3e3-f5dd6116e0d3\">\n\n(If you want to save around 6GB, you can you can uncheck \".NET desktop development\")\n\nCheck \"Install\", then wait awhile.\n\nEventually you'll see this:\n\n<img width=\"985\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/ad9953d8-685d-4489-b251-a8d7b0daf1ba\">\n\n##### Install CLion\n\nInstall CLion: [https://www.jetbrains.com/clion/download/](https://www.jetbrains.com/clion/download/)\n\n##### Build with CLion\n\nOpen CLion and clone the repo:\n\n<img width=\"804\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/67ec32d6-b4b3-4287-9281-6cb7bc8fc009\">\n\nClick \"Trust Project\"\n\n<img width=\"505\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/49fdfb05-fb27-46d3-ae26-d4539ef233ad\">\n\nConfigure Microsoft Defender:\n\n<img width=\"310\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/6826b757-5465-4a0e-ab07-b114c310c118\">\n\nGo to File -> Settings, then \"Build, Execution, Deployment\" and click \"Toolchains\". Verify that your settings look similar to this:\n\n<img width=\"1247\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/cf06074e-1935-4e92-a8b2-5cc232c72688\">\n\nOpen the Project tool window (Press `Alt-1`):\n\n<img width=\"501\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/d7760437-8338-4ca0-8b3b-10345c50619d\">\n\nOpen CMakeLists.txt, then click \"Load CMake project\" in the upper right:\n\n![image](https://github.com/shawwn/noh/assets/59632/eb0f2eda-3d61-4b32-b529-b1a9ea073d52)\n\nYou'll see some errors:\n\n<img width=\"1247\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/467b950c-6f3c-48fb-a9c7-b39c704fc769\">\n\nClick the Vcpkg tab:\n\n<img width=\"553\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/0d2b9025-8096-4f36-8985-bd445142510c\">\n\nClick the plus sign (\"Add vcpkg\")\n\n<img width=\"206\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/e9cc456a-c127-457b-8082-949e65dc9f66\">\n\nVerify that \"Add vcpkg integration to existing CMake profiles\" is selected, then click ok:\n\n<img width=\"335\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/18ab935b-bf8d-405d-8560-8130ce486014\">\n\nVcpkg will now start building the required dependencies:\n\n<img width=\"855\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/db1b4bf2-f744-48df-bb21-1e1a6f5ad295\">\n\nYou can click the \"CMake\" tab to watch its progress:\n\n<img width=\"1052\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/ae0bdfbb-8d0f-4ce3-883e-b042e12f2c4b\">\n\n<img width=\"1240\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/72e1e901-abf8-4c1a-8ff4-43d598f01c02\">\n\nWait awhile (~40 minutes, sorry; luckily you only need to do this once, ever).\n\nEventually \"Loading CMake project...\" in the status bar will disappear.\n\n<img width=\"1260\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/29028649-0feb-4a7c-abaa-32daab3c98b4\">\n\nClick the run button.\n\n<img width=\"683\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/b43a48cf-9432-46c9-b9c3-ec9ddbfda110\">\n\nThe engine will start building:\n\n<img width=\"1264\" alt=\"image\" src=\"https://github.com/shawwn/noh/assets/59632/53d043bf-fdc9-4bab-91a7-41a0f8c90f02\">\n\nWith any luck, it'll launch. You're done!\n\nTo get into a game, change the configuration to NoH, then click the run button again. Once NoH starts, click \"Local Game\" -> Create Game, join a lobby\nslot, start game, then choose a hero.\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/README.md	(date 1685013058147)
@@ -150,6 +150,24 @@
 
 If things still aren't working, [post an issue](https://github.com/shawwn/noh/issues) or DM me on Twitter: [@theshawwn](https://twitter.com/theshawwn)
 
+### Building NoH on Ubuntu
+
+```
+sudo apt update
+sudo apt install build-essential libtool autoconf -y
+sudo apt install cmake ninja-build -y
+# graphics deps
+sudo apt-get install -y libgl-dev libglu1-mesa-dev libxrandr-devsudo xorg-dev
+# K2 engine deps
+sudo apt-get install -y libspeex-dev libspeexdsp-dev libssl-dev libgif-dev libpng-dev libcurl4-openssl-dev libjpeg-dev libxml2-dev libfreetype-dev libncurses-dev libxrandr-dev -y
+```
+
+```
+cd noh
+cmake -S . -B build -G ninja
+cmake --build build
+```
+
 ### Building NoH on Windows
 
 ##### Install Git for Windows
Index: .idea/scopes/NoH.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"DependencyValidationManager\">\n  <scope name=\"NoH\" pattern=\"(file:src//*||file:Heroes of Newerth//*||file:lib/k2public//*||file:Beatopia//*)&amp;&amp;!file:src/aba_client//*&amp;&amp;!file:src/aba_server//*&amp;&amp;!file:src/aba_shared//*&amp;&amp;!file:src/Abaddon_shell//*&amp;&amp;!file:src/editor_x//*&amp;&amp;!file:src/game_client//*&amp;&amp;!file:src/game_server//*&amp;&amp;!file:src/game_shared//*&amp;&amp;!file:src/HoN.xcodeproj//*&amp;&amp;!file:src/Savage 2_shell//*&amp;&amp;!file:src/Abaddon.sln&amp;&amp;!file:src/Savage 2.sln&amp;&amp;!file:*.dylib&amp;&amp;!file:src/vid_d3d9//*&amp;&amp;!file:src/vid_d3d9f//*&amp;&amp;!file:src/vid_d3d9g//*&amp;&amp;!file:src/vid_gl2/GLEW//*&amp;&amp;!file:src/vid_gl2/libXNVCtrl//*&amp;&amp;!file:src/vid_gl2/SOIL//*\" />\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/scopes/NoH.xml b/.idea/scopes/NoH.xml
--- a/.idea/scopes/NoH.xml	(revision 321ba946296e80e0bb00af1694be44729de3c006)
+++ b/.idea/scopes/NoH.xml	(date 1685007427086)
@@ -1,3 +1,3 @@
 <component name="DependencyValidationManager">
-  <scope name="NoH" pattern="(file:src//*||file:Heroes of Newerth//*||file:lib/k2public//*||file:Beatopia//*)&amp;&amp;!file:src/aba_client//*&amp;&amp;!file:src/aba_server//*&amp;&amp;!file:src/aba_shared//*&amp;&amp;!file:src/Abaddon_shell//*&amp;&amp;!file:src/editor_x//*&amp;&amp;!file:src/game_client//*&amp;&amp;!file:src/game_server//*&amp;&amp;!file:src/game_shared//*&amp;&amp;!file:src/HoN.xcodeproj//*&amp;&amp;!file:src/Savage 2_shell//*&amp;&amp;!file:src/Abaddon.sln&amp;&amp;!file:src/Savage 2.sln&amp;&amp;!file:*.dylib&amp;&amp;!file:src/vid_d3d9//*&amp;&amp;!file:src/vid_d3d9f//*&amp;&amp;!file:src/vid_d3d9g//*&amp;&amp;!file:src/vid_gl2/GLEW//*&amp;&amp;!file:src/vid_gl2/libXNVCtrl//*&amp;&amp;!file:src/vid_gl2/SOIL//*" />
+  <scope name="NoH" pattern="(file:src//*||file:Heroes of Newerth//*||file:lib/k2public//*||file:Beatopia//*)&amp;&amp;!file:src/aba_client//*&amp;&amp;!file:src/aba_server//*&amp;&amp;!file:src/aba_shared//*&amp;&amp;!file:src/Abaddon_shell//*&amp;&amp;!file:src/editor_x//*&amp;&amp;!file:src/game_client//*&amp;&amp;!file:src/game_server//*&amp;&amp;!file:src/game_shared//*&amp;&amp;!file:src/HoN.xcodeproj//*&amp;&amp;!file:src/Savage 2_shell//*&amp;&amp;!file:src/Abaddon.sln&amp;&amp;!file:src/Savage 2.sln&amp;&amp;!file:*.dylib&amp;&amp;!file:src/vid_d3d9//*&amp;&amp;!file:src/vid_d3d9f//*&amp;&amp;!file:src/vid_d3d9g//*&amp;&amp;!file:src/vid_gl2/GLEW//*&amp;&amp;!file:src/vid_gl2/libXNVCtrl//*&amp;&amp;!file:src/vid_gl2/SOIL//*&amp;&amp;!file[noh]:src/k2/k2.vcproj" />
 </component>
\ No newline at end of file
