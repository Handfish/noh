Index: src/shell/main_osx.mm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2008 S2 Games\n// main_osx.cpp\n//\n//=============================================================================\n\n//=============================================================================\n// Headers  \n//=============================================================================\n#ifndef __APPLE__\n#error main_osx.mm can only be compiled for OS X\n#endif\n\n#include \"shell_common.h\"\n#include \"../k2/c_vid.h\"\n\n#include <Cocoa/Cocoa.h>\n//=============================================================================\n\n//=============================================================================\n// Definitions\n//=============================================================================\n\n@interface AppDelegate : NSObject<NSApplicationDelegate>\n{\n    BOOL    m_bMinimized;\n}\n- (void)applicationWillFinishLaunching:(NSNotification*)aNotification;\n- (void)applicationDidFinishLaunching:(NSNotification*)aNotification;\n- (void)applicationDidBecomeActive:(NSNotification*)aNotification;\n- (void)applicationDidResignActive:(NSNotification*)aNotification;\n- (void)applicationWillHide:(NSNotification*)aNotification;\n- (void)applicationDidUnhide:(NSNotification *)aNotification;\n- (BOOL)validateMenuItem:(NSMenuItem*)item;\n- (void)toggleFullscreen:(id)sender;\n- (void)minimize:(id)sender;\n- (void)quit:(id)sender;\n@end\n//=============================================================================\n\n\n@implementation AppDelegate\n- (void)applicationWillFinishLaunching:(NSNotification*)aNotification\n{\n    // ensure the menu won't freeze: https://stackoverflow.com/questions/34469718/top-left-menu-bar-is-frozen-when-main-window-shows-up\n    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\n    // set up the menu\n    NSMenu *pMainMenu = [[NSMenu alloc] init];\n    NSMenu *pMenu = [[NSMenu alloc] initWithTitle:@(GAME_TITLE)];\n    // about (standard entry)\n    [pMenu addItemWithTitle:@(\"About \" GAME_TITLE) action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@\"\"];\n    [pMenu addItem:[NSMenuItem separatorItem]];\n    // editor/modelviewer\n    NSMenuItem *pMenuItem;\n    // toggle fullscreen\n    pMenuItem = (NSMenuItem*)[[NSMenuItem alloc] initWithTitle:@\"Toggle Fullscreen\" action:@selector(toggleFullscreen:) keyEquivalent:@\"f\"];\n    [pMenu addItem:pMenuItem];\n    // minimize\n    pMenuItem = (NSMenuItem*)[[NSMenuItem alloc] initWithTitle:@\"Minimize\" action:@selector(minimize:) keyEquivalent:@\"m\"];\n    [pMenu addItem:pMenuItem];\n    // hide/show (standard entries)\n    [pMenu addItemWithTitle:@(\"Hide \" GAME_TITLE) action:@selector(hide:) keyEquivalent:@\"h\"];\n    pMenuItem = (NSMenuItem*)[pMenu addItemWithTitle:@\"Hide Others\" action:@selector(hideOtherApplications:) keyEquivalent:@\"h\"];\n    [pMenuItem setKeyEquivalentModifierMask:(NSEventModifierFlagOption|NSEventModifierFlagCommand)];\n    [pMenu addItemWithTitle:@\"Show All\" action:@selector(unhideAllApplications:) keyEquivalent:@\"\"];\n    // quit\n    [pMenu addItem:[NSMenuItem separatorItem]];\n    pMenuItem = (NSMenuItem*)[pMenu addItemWithTitle:@(\"Quit \" GAME_TITLE) action:@selector(quit:) keyEquivalent:@\"q\"];\n    [pMenuItem setKeyEquivalentModifierMask:(NSEventModifierFlagCommand)];\n    // add to menu bar\n    pMenuItem = [[NSMenuItem alloc] initWithTitle:@\"\" action:nil keyEquivalent:@\"\"];\n    [pMenuItem setSubmenu:pMenu];\n    [pMainMenu addItem:pMenuItem];\n    #if TKTK\n    // private method that we need to call to set this to be the main/\"apple\" menu\n    [NSApp performSelector:NSSelectorFromString(@\"setAppleMenu:\") withObject:pMenu];\n    #else\n    [NSApp setMainMenu:pMainMenu];\n    #endif\n}\n\n- (void)applicationDidFinishLaunching:(NSNotification*)aNotification\n{\n    // ensure the menu won't freeze: https://stackoverflow.com/questions/34469718/top-left-menu-bar-is-frozen-when-main-window-shows-up\n    [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];\n    [[[NSApplication sharedApplication] mainWindow] makeKeyAndOrderFront:self];\n    // bring the window to the front\n    #if 1\n    int processID = [[NSProcessInfo processInfo] processIdentifier];\n    NSRunningApplication* app = [NSRunningApplication runningApplicationWithProcessIdentifier: processID];\n    [app activateWithOptions: NSApplicationActivateAllWindows | NSApplicationActivateIgnoringOtherApps];\n    #elif 0\n    Console.Execute(_T(\"BringActiveWindowToFront\"));\n    #endif\n\n    K2System.Init(_T(GAME_TITLE), VERSION_STRING, BUILD_INFO_STRING, BUILDNUMBER, BUILD_OS, BUILD_OS_INFO, BUILD_ARCH, MASTER_SERVER_ADDRESS);\n\n    try\n    {\n        Host.Init(_T(GAME_MODS));\n        Host.Execute();\n    }\n    catch (CException &ex)\n    {\n        ex.Process(_T(\"Unhandled exception - \"), NO_THROW);\n        K2System.Error(ex.GetMsg());\n    }\n    \n    Host.Shutdown();\n    exit(0);\n}\n\n- (void)applicationDidBecomeActive:(NSNotification*)aNotification\n{\n    K2System.SetFocus(true);\n}\n\n- (void)applicationDidResignActive:(NSNotification*)aNotification\n{\n    K2System.SetFocus(false);\n}\n\n- (void)applicationWillHide:(NSNotification*)aNotification\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win respondsToSelector:NSSelectorFromString(@\"willHide:\")])\n            [win performSelector:NSSelectorFromString(@\"willHide:\") withObject:aNotification];\n    }\n}\n\n- (void)applicationDidUnhide:(NSNotification *)aNotification\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win respondsToSelector:NSSelectorFromString(@\"didUnhide:\")])\n            [win performSelector:NSSelectorFromString(@\"didUnhide:\") withObject:aNotification];\n    }\n}\n\n\n- (BOOL)validateMenuItem:(NSMenuItem*)item\n{\n    BOOL enable = [self respondsToSelector:[item action]];\n    \n    if (([item action] == @selector(launchEditor:) || [item action] == @selector(launchModelviewer:))\n        && (Host.HasClient() || Host.HasServer()))\n        enable = NO;\n    \n    return enable;\n}\n\n- (void)toggleFullscreen:(id)sender\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win && [win isMiniaturized])\n        [win deminiaturize:nil];\n    vid_fullscreen = !vid_fullscreen;\n    Console.Execute(_T(\"VidReset\"));\n}\n\n- (void)minimize:(id)sender\n{\n    NSWindow *win = (NSWindow*)K2System.GetWindowHandle();\n    if (win)\n    {\n        if ([win isMiniaturized])\n            [win deminiaturize:nil];\n        else\n            [win miniaturize:nil];\n    }\n}\n\n- (void)quit:(id)sender\n{\n    Console.Execute(_T(\"Quit\"));\n}\n@end\n\n\nstatic void signal_handler_quit(int signal, siginfo_t* info, void* context)\n{\n    static bool quit_handled = false;\n    if (!quit_handled)\n    {\n        quit_handled = true;\n        Console.Execute(_T(\"quit\"));\n    }\n}\n\n\nint main(int argc, char *argv[])\n{\n    struct sigaction act {};\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = SA_SIGINFO;\n    act.sa_sigaction = signal_handler_quit;\n    sigaction(SIGHUP, &act, nullptr);\n    sigaction(SIGINT, &act, nullptr);\n    sigaction(SIGQUIT, &act, nullptr);\n    sigaction(SIGTERM, &act, nullptr);\n    signal(SIGPIPE, SIG_IGN);\n    // not handling fatal signals, as apple's default crash logging is sufficient\n    \n    // transform it to a gui application & bring it to the front\n    ProcessSerialNumber psn = { 0, kCurrentProcess };\n    TransformProcessType(&psn, kProcessTransformToForegroundApplication);\n#if TKTK  // SetFrontProcess is deprecated\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n    SetFrontProcess(&psn);\n#pragma clang diagnostic pop\n#else\n    int processID = [[NSProcessInfo processInfo] processIdentifier];\n    NSRunningApplication* app = [NSRunningApplication runningApplicationWithProcessIdentifier: processID];\n    [app activateWithOptions: NSApplicationActivateAllWindows];\n#endif\n    \n    #if TKTK\n    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];\n    [NSApplication sharedApplication];\n    [NSApp setDelegate:[[AppDelegate alloc] init]];\n    [NSApp run];\n    [pool release];\n    #else\n    @autoreleasepool {\n        NSApplication *pApplication = [NSApplication sharedApplication];\n        AppDelegate *delegate = [AppDelegate new];\n        [pApplication setDelegate:delegate];\n        [pApplication run];\n    }\n    #endif\n    \n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/shell/main_osx.mm b/src/shell/main_osx.mm
--- a/src/shell/main_osx.mm	(revision 3a1d4242bf3515fce1a27d25622593de44b2abab)
+++ b/src/shell/main_osx.mm	(date 1685014604631)
@@ -234,3 +234,108 @@
     
     return 0;
 }
+
+
+/*====================
+  FtoA(CGFloat)
+  ====================*/
+tstring  FtoA(CGFloat f, int flags = FMT_NONE, int width = 0, int minPrecision = 0, int maxPrecision = XTOA_DEFAULT_FLOAT_PRECISION)
+{
+    tstring s;
+    FormatFloat(f, flags, width, minPrecision, maxPrecision, s);
+    return s;
+}
+
+/*====================
+  CConsoleStream::operator<<(const NSString*)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const NSString* it)
+{
+    self << [it UTF8String];
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGPoint&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGPoint& pt)
+{
+    self << _T("");
+    self << _T("x=") << FtoA(pt.x);
+    self << _T(", ");
+    self << _T("y=") << FtoA(pt.y);
+    self << _T("");
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGSize&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGSize& it)
+{
+    self << NSStringFromSize(it);
+//    self << _T("width=") << FtoA(it.width);
+//    self << _T(", ");
+//    self << _T("height=") << FtoA(it.height);
+    return self;
+}
+
+/*====================
+  CConsoleStream::operator<<(const CGRect&)
+  ====================*/
+CConsoleStream& operator<<(CConsoleStream& self, const CGRect& it)
+{
+    self << NSStringFromRect(it);
+    // self << it.origin << _T(", ") << it.size;
+    return self;
+}
+
+/*====================
+  GetWindowFrame
+  ====================*/
+NSRect GetWindowFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [window frame];
+}
+
+/*====================
+  GetWindowFrameForContent
+  ====================*/
+NSRect GetWindowContentFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [window contentRectForFrameRect:[window frame]];
+}
+
+/*====================
+  GetTitlebarHeight
+  ====================*/
+CGFloat GetTitlebarHeight(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return GetWindowFrame(window).size.height - GetWindowContentFrame(window).size.height;
+}
+
+/*====================
+  GetScreenVisibleFrame
+  ====================*/
+NSRect GetScreenVisibleFrame(NSWindow* window = [[NSApplication sharedApplication] mainWindow])
+{
+    return [[window screen] visibleFrame];
+}
+
+CMD(WindowOuterRect)
+{
+    Console.Std << GetWindowFrame() << newl;
+    return true;
+}
+
+CMD(WindowInnerRect)
+{
+    Console.Std << GetWindowContentFrame() << newl;
+    return true;
+}
+
+CMD(ScreenVisibleRect)
+{
+    Console.Std << GetScreenVisibleFrame() << newl;
+    return true;
+}
\ No newline at end of file
Index: src/vid_gl2/gl2_win32.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// (C)2008 S2 Games\n// gl2_win32.cpp\n//\n// Win32 specific renderer API functions\n//=============================================================================\n\n//=============================================================================\n// Headers\n//=============================================================================\n#include \"vid_common.h\"\n\n#include \"../k2/c_uimanager.h\"\n#include \"../k2/c_cursor.h\"\n#include \"../k2/c_resourcemanager.h\"\n//=============================================================================\n\n//=============================================================================\n// Globals\n//=============================================================================\nWNDPROC     MainWndProc;\nHINSTANCE   g_hInstance;\nHWND        g_hWnd;\nHDC         g_hDC;\nHGLRC       g_hglrc;\nICONINFO    g_IconInfo = {0};\nHICON       g_hCursorIcon = nullptr;\n\nCVAR_BOOL   (win_changeDisplayMode,     false);\n//=============================================================================\n\n/*====================\n  InitAPIs\n\n  This is what's exported by the DLL and called by the rest of\n  the engine. It's a wrapper to do the windows-specific stuff\n  and call the shared API initialization function, basically.\n  ====================*/\nextern \"C\" __declspec(dllexport)\nvoid    InitAPIs(SVidDriver *vid_api, WNDPROC _MainWndProc, HINSTANCE hInstance)\n{\n    g_hInstance = hInstance;\n    MainWndProc = _MainWndProc;\n\n    InitAPIs_Global(vid_api);\n}\n\n\n/*====================\n  GL_GetHWnd\n  ====================*/\nvoid*   GL_GetHWnd()\n{\n    return g_hWnd;\n}\n\n\n/*====================\n  GL_Init\n  ====================*/\nint     GL_Init()\n{\n    int modenum = 0;\n    BOOL bSuccess(FALSE);\n    DEVMODE devmode;\n    \n    gl_initialized = false;\n\n    ZeroMemory(&devmode, sizeof(devmode));\n    devmode.dmSize = sizeof(DEVMODE);\n\n    // Fill in the default mode (Desktop)\n    if (EnumDisplaySettings(nullptr, ENUM_REGISTRY_SETTINGS, &devmode))\n    {\n        g_VidModes[0].iWidth = devmode.dmPelsWidth;\n        g_VidModes[0].iHeight = devmode.dmPelsHeight;\n        g_VidModes[0].iBpp = devmode.dmBitsPerPel;\n        g_VidModes[0].iRefreshRate = devmode.dmDisplayFrequency;\n        g_VidModes[0].sName = _T(\"Desktop \") + ParenStr(XtoA(g_VidModes[0].iWidth) + _T(\"x\") + XtoA(g_VidModes[0].iHeight) + _T(\"x\") + XtoA(g_VidModes[0].iBpp) + _T(\"@\") + XtoA(g_VidModes[0].iRefreshRate));\n    }\n    else\n        K2System.Error(_T(\"EnumDisplaySettings failed on mode 0\"));\n\n    g_iNumVidModes = 1;  // Always keep mode 0 open\n\n    do\n    {\n        bool bModeExists(false);\n        bSuccess = EnumDisplaySettings(nullptr, modenum, &devmode);\n        if (!bSuccess)\n        {\n            if (modenum == 0)\n                K2System.Error(_T(\"EnumDisplaySettings failed on mode 0\"));\n            break;\n        }\n\n        if (devmode.dmBitsPerPel >= 15 && devmode.dmPelsWidth >= 1024 && devmode.dmPelsHeight >= 720 && g_iNumVidModes < MAX_VID_MODES)\n        {\n            // See if the mode is valid\n            devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;\n            if (ChangeDisplaySettings(&devmode, CDS_TEST | CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL)\n            {\n                // Make sure the mode doesn't already exist\n                for (int n = 1; n < g_iNumVidModes; ++n)\n                {\n                    if (g_VidModes[n].iWidth == int(devmode.dmPelsWidth) &&\n                        g_VidModes[n].iHeight == int(devmode.dmPelsHeight) &&\n                        g_VidModes[n].iBpp == int(devmode.dmBitsPerPel) &&\n                        g_VidModes[n].iRefreshRate == int(devmode.dmDisplayFrequency))\n                        bModeExists = true;\n                }\n                if (!bModeExists)\n                {\n                    // The mode is valid, so add it to g_VidModes\n                    g_VidModes[g_iNumVidModes].iWidth = int(devmode.dmPelsWidth);\n                    g_VidModes[g_iNumVidModes].iHeight = int(devmode.dmPelsHeight);\n                    g_VidModes[g_iNumVidModes].iBpp = int(devmode.dmBitsPerPel);\n                    g_VidModes[g_iNumVidModes].iRefreshRate = int(devmode.dmDisplayFrequency);\n                    g_VidModes[g_iNumVidModes].sName = XtoA(devmode.dmPelsWidth) + _T(\"x\") + XtoA(devmode.dmPelsHeight) + _T(\"x\") + XtoA(devmode.dmBitsPerPel) + _T(\" @ \") + XtoA(devmode.dmDisplayFrequency) + _T(\" Hz\");\n\n                    Console.Video << _T(\"Vid mode \") << g_iNumVidModes << _T(\": \")\n                                << _T(\"Width: \") << devmode.dmPelsWidth\n                                << _T(\", Height: \") << devmode.dmPelsHeight\n                                << _T(\", Bpp: \") << devmode.dmBitsPerPel\n                                << _T(\", Refresh rate: \") << devmode.dmDisplayFrequency << newl;\n                    ++g_iNumVidModes;\n                }\n            }\n        }\n        ++modenum;\n    }\n    while (bSuccess);\n    \n    return GL_Global_Init();\n}\n\n\n/*====================\n  GL_SetupPixelFormat\n  ====================*/\nvoid    GL_SetupPixelFormat()\n{\n    int pixelformat;\n    static PIXELFORMATDESCRIPTOR pfd = {\n    sizeof(PIXELFORMATDESCRIPTOR),  // size of this pfd\n    1,                      // version number\n    PFD_DRAW_TO_WINDOW      // support window\n    | PFD_SUPPORT_OPENGL    // support OpenGL\n    | PFD_DOUBLEBUFFER,     // double buffered\n    PFD_TYPE_RGBA,          // RGBA type\n    24,                     // 24-bit color depth\n    0, 0, 0, 0, 0, 0,       // color bits ignored\n    0,                      // no alpha buffer\n    0,                      // shift bit ignored\n    0,                      // no accumulation buffer\n    0, 0, 0, 0,             // accum bits ignored\n    24,                     // 24-bit z-buffer  \n    0,                      // no stencil buffer\n    0,                      // no auxiliary buffer\n    PFD_MAIN_PLANE,         // main layer\n    0,                      // reserved\n    0, 0, 0                 // layer masks ignored\n    };\n    \n    if (!(pixelformat = ChoosePixelFormat(g_hDC, &pfd)))    \n       K2System.Error(_T(\"GL_SetupPixelFormat: ChoosePixelFormat failed\"));            \n\n    if (!SetPixelFormat(g_hDC, pixelformat, &pfd))\n        K2System.Error(_T(\"SetPixelFormat failed\"));\n}\n\n\n/*====================\n  GL_Start\n  ====================*/\nvoid    GL_Start()\n{\n    static bool class_registered = false;\n\n    // Register window class\n    if (!class_registered)\n    {\n        WNDCLASS wc;\n\n        MemManager.Set(&wc, 0, sizeof(WNDCLASS));       \n        wc.lpfnWndProc = MainWndProc;\n        wc.hInstance = g_hInstance;\n        wc.lpszClassName = _T(\"K2_OpenGL\");\n#if TKTK // LoadIcon\n        wc.hIcon = LoadIcon(wc.hInstance, MAKEINTRESOURCE(IDI_ICON1));\n#endif\n\n        if (!RegisterClass(&wc))\n            K2System.Error(_T(\"GL_Start: RegisterClass() failed\"));\n        class_registered = true;\n    }\n\n    // Create the window\n    HWND hWnd = CreateWindowEx\n    (\n        WS_EX_ACCEPTFILES,\n        _T(\"K2_OpenGL\"),\n        K2System.GetGameName().c_str(),\n        WS_MAXIMIZE | WS_POPUP,\n        0, \n        0, \n        g_CurrentVidMode.iWidth,\n        g_CurrentVidMode.iHeight,\n        nullptr,\n        nullptr,\n        g_hInstance,\n        nullptr\n    );\n\n    if (!hWnd)\n        K2System.Error(_T(\"GL_Start: CreateWindow() failed\"));\n    K2System.SetWindowHandle(hWnd);\n\n    g_hWnd = hWnd;\n    g_hDC = GetDC(g_hWnd);\n\n    GL_SetMode();\n\n    ShowWindow(hWnd, SW_SHOW);\n    UpdateWindow(hWnd);\n\n    PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n\n    GL_SetupPixelFormat();\n\n    if (!(g_hglrc = wglCreateContext(g_hDC)))\n        K2System.Error(_T(\"GL_Start: wglCreateContext() failed\"));\n\n    if (!wglMakeCurrent(g_hDC, g_hglrc))\n        K2System.Error(_T(\"GL_Start: wglMakeCurrent() failed\"));\n\n    gl_initialized = true;\n\n    PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n\n    GL_Global_Start();\n\n    // Build anti-aliasing mode list\n    g_AAModes[0].iSamples = 0;\n    g_AAModes[0].iQuality = 0;\n    g_AAModes[0].sName = _T(\"None\");\n    g_iNumAAModes = 1; // Always keep mode 0 open\n\n    for (int i(2); i <= 16; ++i)\n    {\n        int iAttributes[] =\n        {\n            WGL_DRAW_TO_WINDOW_ARB, GL_TRUE,\n            WGL_SUPPORT_OPENGL_ARB, GL_TRUE,\n            WGL_ACCELERATION_ARB, WGL_FULL_ACCELERATION_ARB,\n            WGL_COLOR_BITS_ARB, 24,\n            WGL_ALPHA_BITS_ARB, 8,\n            WGL_DEPTH_BITS_ARB, 16,\n            WGL_STENCIL_BITS_ARB, 0,\n            WGL_DOUBLE_BUFFER_ARB, GL_TRUE,\n            WGL_SAMPLE_BUFFERS_ARB, GL_TRUE,\n            WGL_SAMPLES_ARB, i,\n            0, 0\n        };\n\n        float fAttributes[] = {0, 0};\n        int iPixelFormat;\n        UINT uiNumFormats;\n\n        BOOL bValid(wglChoosePixelFormatARB(g_hDC, iAttributes, fAttributes, 1, &iPixelFormat, &uiNumFormats));\n     \n        if (!bValid || uiNumFormats == 0)\n            continue;\n\n        g_AAModes[g_iNumAAModes].iSamples = i;\n        g_AAModes[g_iNumAAModes].iQuality = 0;\n        g_AAModes[g_iNumAAModes].sName = XtoA(i) + _T(\"x\");\n\n        ++g_iNumAAModes;\n    }\n\n    GL_SetGamma(DEFAULT_OVERBRIGHT);\n}\n\n\n/*====================\n  GL_SetMode\n  ====================*/\nint     GL_SetMode()\n{\n    int iMode(-1);\n\n    // Try to match a valid mode\n    for (int i(0); i < g_iNumVidModes; ++i)\n    {\n        if (g_VidModes[i].iWidth == vid_resolution[0] &&\n            g_VidModes[i].iHeight == vid_resolution[1] &&\n            g_VidModes[i].iBpp == vid_bpp &&\n            g_VidModes[i].iRefreshRate == vid_refreshRate)\n        {\n            g_CurrentVidMode = g_VidModes[i];\n            iMode = i;\n            break;\n        }\n    }\n\n    if (iMode == -1)\n    {\n        if (vid_fullscreen)\n        {\n            g_CurrentVidMode = g_VidModes[0];\n            iMode = 0;\n        }\n        else\n        {\n            g_CurrentVidMode.iWidth = vid_resolution[0];\n            g_CurrentVidMode.iHeight = vid_resolution[1];\n            g_CurrentVidMode.iBpp = vid_bpp;\n            g_CurrentVidMode.iRefreshRate = vid_refreshRate;\n        }\n    }\n    \n    g_iCurrentVideoMode = iMode;\n\n    if (vid_antialiasing.GetSize() != 2)\n        vid_antialiasing.Resize(2, 0);\n\n    g_CurrentAAMode.iSamples = vid_antialiasing[0];\n    g_CurrentAAMode.iQuality = vid_antialiasing[1];\n    g_CurrentAAMode.sName = _T(\"\");\n\n    if (vid_fullscreen)\n    {\n        if (iMode != 0 || win_changeDisplayMode)\n        {\n            DEVMODE devmode;\n            MemManager.Set(&devmode, 0, sizeof(devmode));\n            devmode.dmPelsWidth = g_CurrentVidMode.iWidth;\n            devmode.dmPelsHeight = g_CurrentVidMode.iHeight;\n            devmode.dmBitsPerPel = g_CurrentVidMode.iBpp;\n            devmode.dmDisplayFrequency = g_CurrentVidMode.iRefreshRate;\n            devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY;\n\n            devmode.dmSize = sizeof(devmode);\n\n            bool bSuccess(false);\n\n            bSuccess = ChangeDisplaySettings(&devmode, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL;\n\n            if (!bSuccess && iMode != 0)\n            {\n                if (win_changeDisplayMode)\n                {\n                    DEVMODE devmode0;\n                    MemManager.Set(&devmode0, 0, sizeof(devmode0));\n                    devmode0.dmPelsWidth = g_VidModes[0].iWidth;\n                    devmode0.dmPelsHeight = g_VidModes[0].iHeight;\n                    devmode0.dmBitsPerPel = g_VidModes[0].iBpp;\n                    devmode0.dmDisplayFrequency = g_VidModes[0].iRefreshRate;\n                    devmode0.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;\n\n                    bSuccess = ChangeDisplaySettings(&devmode0, CDS_FULLSCREEN) == DISP_CHANGE_SUCCESSFUL;\n\n                    devmode = devmode0;\n                }\n                else\n                {\n                    bSuccess = ChangeDisplaySettings(nullptr, 0) == DISP_CHANGE_SUCCESSFUL;\n                }\n\n                g_iCurrentVideoMode = 0;\n            }\n\n            if (!bSuccess)\n            {\n                K2System.Error(_T(\"GL_SetMode: Unable to set Mode 0\"));\n            }\n        }\n        else\n        {\n            if (ChangeDisplaySettings(nullptr, 0) != DISP_CHANGE_SUCCESSFUL)\n                K2System.Error(_T(\"GL_SetMode: Unable to set desktop video mode\"));\n        }\n\n        g_bFullscreen = true;\n    }\n    else\n    {\n        g_bFullscreen = false;\n\n        if (ChangeDisplaySettings(nullptr, 0) != DISP_CHANGE_SUCCESSFUL)\n            K2System.Error(_T(\"GL_SetMode: Unable to set desktop video mode\"));\n    }\n\n    if (g_hWnd)\n    {\n        if (!vid_fullscreen)\n        {\n            DWORD dwWindowStyle(WS_CAPTION | WS_MINIMIZEBOX | WS_VISIBLE | WS_SYSMENU);\n\n            if (vid_windowResize)\n                dwWindowStyle |= WS_SIZEBOX;\n\n            if (!SetWindowLong(g_hWnd, GWL_STYLE, dwWindowStyle))\n                K2System.Error(_TS(\"SetWindowLong() - \") + K2System.GetLastErrorString());\n\n            RECT    winsize;\n            winsize.left = 0;\n            winsize.right = g_CurrentVidMode.iWidth;\n            winsize.top = 0;\n            winsize.bottom = g_CurrentVidMode.iHeight;\n            AdjustWindowRect(&winsize, dwWindowStyle, false);\n            if (!SetWindowPos(g_hWnd, HWND_TOP, 0, 0, winsize.right - winsize.left, winsize.bottom - winsize.top, SWP_SHOWWINDOW))\n                K2System.Error(_TS(\"SetWindowPos() - \") + K2System.GetLastErrorString());\n            GetClientRect(g_hWnd, &winsize);\n    \n            // Resize render surface to match new window size (if it was clipped)\n            g_CurrentVidMode.iWidth = MIN<int>(g_CurrentVidMode.iWidth, winsize.right - winsize.left);\n            g_CurrentVidMode.iHeight = MIN<int>(g_CurrentVidMode.iHeight, winsize.bottom - winsize.top);\n        }\n        else\n        {\n            if (!SetWindowLong(g_hWnd, GWL_STYLE, WS_MAXIMIZE))\n                K2System.Error(_TS(\"SetWindowLong() - \") + K2System.GetLastErrorString());\n\n            if (!SetWindowPos(g_hWnd, HWND_TOP, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, SWP_SHOWWINDOW))\n                K2System.Error(_TS(\"SetWindowPos() - \") + K2System.GetLastErrorString());\n        }\n\n        ShowWindow(g_hWnd, SW_SHOW);\n        UpdateWindow(g_hWnd);\n\n        PatBlt(g_hDC, 0, 0, g_CurrentVidMode.iWidth, g_CurrentVidMode.iHeight, BLACKNESS);\n    }\n\n    return g_iCurrentVideoMode;\n}\n\n\n/*====================\n  GL_SetGamma\n  ====================*/\nvoid    GL_SetGamma(float gamma)\n{\n}\n\n\n/*====================\n  GL_ShowCursor\n  ====================*/\nvoid    GL_ShowCursor(bool bShow)\n{\n    if (bShow)\n        while(ShowCursor(true) < 0);\n    else\n        while(::ShowCursor(false) >= 0);\n}\n\n\n/*====================\n  GL_SetCursor\n  ====================*/\nvoid    GL_SetCursor(ResHandle hCursor)\n{\n    if (hCursor == g_hCursor)\n        return;\n    g_hCursor = hCursor;\n\n    if (g_hCursor == INVALID_RESOURCE)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    CCursor *pCursor(g_ResourceManager.GetCursor(hCursor));\n    if (pCursor == nullptr)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    CBitmap *pBitmap(pCursor->GetBitmapPointer());\n    if (pBitmap == nullptr)\n    {\n        ShowCursor(false);\n        return;\n    }\n\n    const int WIDTH(32), HEIGHT(32), BYTEPP(4);\n    \n    if (pBitmap->GetWidth() != WIDTH || pBitmap->GetHeight() != HEIGHT || pBitmap->GetBMPType() != BYTEPP)\n        return;\n\n    byte yBuffer[WIDTH * HEIGHT * 4];\n\n    const byte *pSrcData(static_cast<const byte *>(pBitmap->GetBuffer()));\n    byte *pDstData(yBuffer);\n    int iDeltaPitch(0);\n\n    // Invert\n    pSrcData += pBitmap->GetWidth() * 4 * (pBitmap->GetHeight() - 1);\n    iDeltaPitch -= pBitmap->GetWidth() * 4 * 2;\n\n    for (int y(0); y < pBitmap->GetHeight(); ++y)\n    {\n        for (int x(0); x < pBitmap->GetWidth(); ++x)\n        {\n            pDstData[0] = pSrcData[2];\n            pDstData[1] = pSrcData[1];\n            pDstData[2] = pSrcData[0];\n            pDstData[3] = pSrcData[3];\n\n            pDstData += 4;\n            pSrcData += 4;\n        }\n\n        pSrcData += iDeltaPitch;\n    }\n\n    CVec2i v2Hotspot(pCursor->GetHotspot());\n\n    if (g_hCursorIcon != nullptr) {\n        DeleteObject(g_IconInfo.hbmMask);\n        DeleteObject(g_IconInfo.hbmColor);\n        DestroyIcon(g_hCursorIcon);\n    }\n\n    g_IconInfo.fIcon = false;\n    g_IconInfo.xHotspot = v2Hotspot.x;\n    g_IconInfo.yHotspot = v2Hotspot.y;\n    g_IconInfo.hbmMask = CreateBitmap(WIDTH, HEIGHT, 1, 1, nullptr);\n    g_IconInfo.hbmColor = CreateBitmap(WIDTH, HEIGHT, 1, BYTEPP * 8, yBuffer);\n\n    g_hCursorIcon = CreateIconIndirect(&g_IconInfo);\n\n#ifdef _WIN64\n    SetClassLongPtr(g_hWnd, GCLP_HCURSOR, LONG_PTR(g_hCursorIcon));\n#else\n    SetClassLongPtr(g_hWnd, GCL_HCURSOR, LONG_PTR(g_hCursorIcon));\n#endif\n}\n\n\n/*====================\n  GL_Shutdown\n  ====================*/\nvoid    GL_Shutdown()\n{\n    if (!gl_initialized)\n        return;\n\n    GL_Global_Shutdown();\n\n    wglMakeCurrent(nullptr, nullptr);\n    \n    GL_SetGamma(1);\n\n    if (g_hglrc)\n    {\n        wglDeleteContext(g_hglrc);\n        g_hglrc = 0;\n    }\n\n    if (g_hDC)\n    {\n        ReleaseDC(g_hWnd, g_hDC);\n        g_hDC = 0;\n    }\n\n    if (g_hCursorIcon != nullptr)\n        DestroyIcon(g_hCursorIcon);\n\n    DestroyWindow(g_hWnd);\n    UnregisterClass(_T(\"K2_OpenGL\"), g_hInstance);\n\n    ChangeDisplaySettings(nullptr, 0);\n\n    ShowCursor(TRUE);\n    DestroyIcon(g_hCursorIcon);\n    DeleteObject(g_IconInfo.hbmMask);\n    DeleteObject(g_IconInfo.hbmColor);\n\n    gl_initialized = false;\n    g_bValidScene = false;\n}\n\n\n/*====================\n  GL_EndFrame\n  ====================*/\nvoid    GL_EndFrame()\n{\n    GL_Global_EndFrame();\n    SwapBuffers(g_hDC);\n    \n    PRINT_GLERROR_BREAK();\n}\n\n\n/*====================\n  GL_Break\n  ====================*/\nvoid    GL_Break()\n{\n#ifndef _WIN64\n    __asm int 0x03;\n#else\n    // TODO\n#endif\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/vid_gl2/gl2_win32.cpp b/src/vid_gl2/gl2_win32.cpp
--- a/src/vid_gl2/gl2_win32.cpp	(revision 3a1d4242bf3515fce1a27d25622593de44b2abab)
+++ b/src/vid_gl2/gl2_win32.cpp	(date 1685014604650)
@@ -44,6 +44,19 @@
     InitAPIs_Global(vid_api);
 }
 
+inline int get_title_bar_thickness(HWND window_handle)
+{
+    RECT window_rectangle, client_rectangle;
+    int height, width;
+    GetWindowRect(window_handle, &window_rectangle);
+    GetClientRect(window_handle, &client_rectangle);
+    height = (window_rectangle.bottom - window_rectangle.top) -
+    (client_rectangle.bottom - client_rectangle.top);
+    width = (window_rectangle.right - window_rectangle.left) -
+    (client_rectangle.right - client_rectangle.left);
+    return height - (width/2);
+}
+
 
 /*====================
   GL_GetHWnd
